// Generated by polka.codes
import { code, commit, fix, plan, reviewCode } from '@polka-codes/cli'
import { execSync } from 'child_process'
import * as fs from 'fs'
import * as path from 'path'

// Configuration
const DEFAULT_PLANS_DIR = '.polka/plans'
const DISCOVERY_TASKS = [
  'Review the repo for duplicated code, unused code, security issues, or unnecessary complexity',
  'Find missing or low-value tests; propose high-signal tests to add',
  'Look for error handling gaps (missing retries/timeouts/backoff) and propose improvements',
  'Look for observability gaps (missing logs/metrics/traces) and propose what to add',
  'Look for performance hotspots (N+1 queries, inefficient loops, unnecessary allocations) and propose fixes',
  'Look for API/UX papercuts and propose small quality-of-life improvements',
  'Identify unclear naming/structure areas and propose refactors with clear boundaries',
  'Suggest the top 3 new product improvements/features',
  'Create a new user story and break it down into implementable features',
  'Review open TODO/FIXME comments and convert the most important ones into a task',
  'Review recently changed code and look for follow-up work (tech debt, missing tests, edge cases)',
]

// State
let buildCommand = 'npm run build'
let testCommand = 'npm test'
const plansDirectory = DEFAULT_PLANS_DIR

/**
 * Setup the environment: detect commands and ensure directories exist
 */
async function setup() {
  // 1. Determine build and test commands
  if (fs.existsSync('package.json')) {
    try {
      const pkg = JSON.parse(fs.readFileSync('package.json', 'utf-8'))
      const scripts = pkg.scripts || {}

      // Prefer bun if available
      const pm = pkg.packageManager?.startsWith('bun') ? 'bun' : 'npm'
      const run = (cmd: string) => `${pm} run ${cmd}`

      if (scripts.build) buildCommand = run('build')
      else if (scripts.compile) buildCommand = run('compile')

      if (scripts.test) testCommand = run('test')
      else if (scripts.check) testCommand = run('check')

      console.log(`[Setup] Detected build command: ${buildCommand}`)
      console.log(`[Setup] Detected test command: ${testCommand}`)
    } catch (e) {
      console.warn('[Setup] Failed to parse package.json, using defaults.')
    }
  }

  // 2. Determine plans directory
  if (!fs.existsSync(plansDirectory)) {
    fs.mkdirSync(plansDirectory, { recursive: true })
    console.log(`[Setup] Created plans directory: ${plansDirectory}`)
  }
}

/**
 * Ensure the repo is in a good state (builds and tests pass)
 */
async function ensureGoodStatus() {
  console.log('[Status] Ensuring good status...')

  // 1. Build
  try {
    console.log(`[Status] Running build: ${buildCommand}`)
    execSync(buildCommand, { stdio: 'pipe' })
  } catch (error: any) {
    console.log('[Status] Build failed. Attempting to fix...')
    await fix({
      command: buildCommand,
      task: 'Fix build errors. Ensure the project builds successfully.',
      interactive: false,
    })
    // Retry build to confirm
    execSync(buildCommand, { stdio: 'inherit' })
  }

  // 2. Test
  try {
    console.log(`[Status] Running tests: ${testCommand}`)
    execSync(testCommand, { stdio: 'pipe' })
  } catch (error: any) {
    console.log('[Status] Tests failed. Attempting to fix...')
    await fix({
      command: testCommand,
      task: 'Fix failing tests. Ensure all tests pass.',
      interactive: false,
    })
    // Retry tests to confirm
    execSync(testCommand, { stdio: 'inherit' })
  }

  // 3. Commit if dirty
  try {
    const status = execSync('git status --porcelain').toString().trim()
    if (status) {
      console.log('[Status] Uncommitted changes detected. Committing...')
      await commit({
        message: 'chore: ensure good status',
        all: true,
        interactive: false,
      })
    }
  } catch (e) {
    console.warn('[Status] Failed to check git status or commit.')
  }
}

/**
 * Create a plan for a task, refine it, and save it
 */
async function createPlan(task: string) {
  console.log(`[Plan] Creating plan for: ${task}`)

  const planId = `plan-${Date.now()}`
  const planFile = path.join(plansDirectory, `${planId}.md`)

  // Initial Plan
  await plan({
    task: `Create a detailed implementation plan for: ${task}. Include scope, acceptance criteria, and risks.`,
    planFile: planFile,
    interactive: false,
  })

  // Refine Plan
  await refinePlan(planFile, task)

  console.log(`[Plan] Plan saved to ${planFile}`)
  return planFile
}

/**
 * Refine a plan using Challenger/Researcher/Planner personas
 */
async function refinePlan(planFile: string, originalTask: string) {
  console.log(`[Refine] Refining plan: ${planFile}`)
  const critiqueFile = `${planFile}.critique.md`
  const researchFile = `${planFile}.research.md`

  // 1. Challenger
  await code({
    task: `Read ${planFile}. Act as a Challenger. Review the plan for:
    - Ambiguity and missing acceptance criteria
    - Non-goals and scope creep risks
    - Edge cases
    - Security considerations
    - Better alternatives / simpler approaches
    - Whether additional research would reduce risk
    
    Write your critique to ${critiqueFile}.
    If research is needed, include the text "RESEARCH NEEDED" in the critique.`,
    interactive: false,
  })

  // 2. Researcher (if needed)
  let critiqueContent = ''
  try {
    critiqueContent = fs.readFileSync(critiqueFile, 'utf-8')
  } catch (e) {}

  if (critiqueContent.includes('RESEARCH NEEDED')) {
    console.log('[Refine] Research requested by Challenger.')
    await code({
      task: `Read ${critiqueFile}. Act as a Researcher. Perform targeted research based on the challenger's notes.
      Write your findings to ${researchFile}.`,
      interactive: false,
    })
  }

  // 3. Planner (Update)
  await code({
    task: `Read ${planFile}, ${critiqueFile}, and (if it exists) ${researchFile}.
    Act as a Planner. Produce an updated plan based on the challenger's feedback and any research findings.
    Overwrite ${planFile} with the improved plan.
    Ensure the plan is clear, actionable, and addresses the original goal: "${originalTask}"`,
    interactive: false,
  })

  // Cleanup temporary files
  try {
    fs.unlinkSync(critiqueFile)
  } catch (e) {}
  try {
    fs.unlinkSync(researchFile)
  } catch (e) {}
}

/**
 * Find the next task or create a discovery task
 */
async function nextTask(): Promise<{ task: string; planFile: string }> {
  const files = fs.readdirSync(plansDirectory).filter((f) => f.endsWith('.md') && !f.endsWith('.done.md'))

  if (files.length > 0) {
    const planFile = path.join(plansDirectory, files[0])
    // Extract a task summary from the plan content or filename
    const task = `Implement plan from ${files[0]}`
    return { task, planFile }
  }

  // No tasks found, run discovery
  await discoveryTask()
  return nextTask()
}

/**
 * Create a new task from discovery strategies
 */
async function discoveryTask() {
  console.log('[Discovery] Running discovery task...')
  const strategy = DISCOVERY_TASKS[Math.floor(Math.random() * DISCOVERY_TASKS.length)]
  await createPlan(strategy)
}

/**
 * Implement a task based on a plan
 */
async function implementTask(task: string, planFile: string) {
  console.log(`[Implement] Implementing: ${task}`)

  // Check if plan matches task (simplified: just reload plan)
  const planContent = fs.readFileSync(planFile, 'utf-8')

  await code({
    task: `Implement the following plan:\n\n${planContent}`,
    interactive: false,
  })

  await ensureGoodStatus()

  // Mark plan as done
  const doneFile = planFile.replace('.md', '.done.md')
  fs.renameSync(planFile, doneFile)
  console.log(`[Implement] Marked plan as done: ${doneFile}`)
}

/**
 * Review code changes
 */
async function reviewChanges(range: string) {
  console.log(`[Review] Reviewing range: ${range}`)

  const result = await reviewCode({
    range: range,
    interactive: false,
  })

  if (result && result.specificReviews && result.specificReviews.length > 0) {
    console.log('[Review] Issues found. Creating fix plan.')
    const issues = result.specificReviews.map((r) => `${r.file}: ${r.review}`).join('\n')
    const fixTask = `Fix issues found in code review:\n${issues}`
    const planFile = await createPlan(fixTask)
    await implementTask(fixTask, planFile)
    return false
  }

  return true
}

/**
 * Cleanup old plans
 */
function cleanupPlans() {
  console.log('[Cleanup] Cleaning up old plans...')
  const files = fs.readdirSync(plansDirectory)
  for (const file of files) {
    if (file.endsWith('.done.md')) {
      fs.unlinkSync(path.join(plansDirectory, file))
    }
  }
}

export async function main(args: string[]) {
  const userTask = args.join(' ')

  await setup()

  if (userTask) {
    console.log(`[Main] User provided task: ${userTask}`)
    await createPlan(userTask)
  }

  let i = 0
  while (true) {
    console.log(`\n[Loop] Iteration ${i}`)

    const { task, planFile } = await nextTask()

    if (!task) {
      console.log('[Loop] No task returned. Exiting.')
      break
    }

    await implementTask(task, planFile)

    // Review last commit
    await reviewChanges('HEAD~1..HEAD')

    if (i % 2 === 0) {
      // Review last 30 commits (or as many as exist)
      try {
        await reviewChanges('HEAD~30..HEAD')
      } catch (e) {
        // Ignore if not enough commits
      }
    }

    if (i % 4 === 0) {
      cleanupPlans()
    }

    i++
  }

  console.log('Script completed successfully')
}

// Only run main if this is the entry point
if (import.meta.main) {
  main(process.argv.slice(2))
}
