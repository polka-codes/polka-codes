// Generated by polka.codes

import { existsSync, readFileSync } from 'node:fs'
import { readFile } from 'node:fs/promises'
import { homedir } from 'node:os'
import { join } from 'node:path'
import { type Config, type ConfigRule, configSchema } from '@polka-codes/core'
import { merge } from 'lodash-es'
import { parse } from 'yaml'
import { ZodError } from 'zod'

export { configSchema, type Config }

export function getGlobalConfigPath(home = homedir()): string {
  return join(home, '.config', 'polkacodes', 'config.yml')
}

export function loadConfigAtPath(path: string): Config | undefined {
  try {
    return readConfig(path)
  } catch (error) {
    // Log debug message - this function is used to check if config exists, so undefined is acceptable
    if (error instanceof ZodError) {
      // Validation errors should be logged as warnings
      console.warn(`Config validation failed for ${path}: ${error.message}`)
    }
    return undefined
  }
}

export const localConfigFileName = '.polkacodes.yml'

const mergeArray = <T>(a: T[] | undefined, b: T[] | undefined): T[] | undefined => {
  if (!a && !b) {
    return undefined
  }
  if (!a) {
    return b
  }
  if (!b) {
    return a
  }
  return [...a, ...b]
}

export function mergeConfigs(configs: Config[]): Config {
  if (configs.length === 0) {
    return {}
  }

  const mergedConfig = configs.reduce((acc, config) => {
    const merged = merge({}, acc, config)

    // Special handling for rules array
    const accRules = acc.rules ? (Array.isArray(acc.rules) ? acc.rules : [acc.rules]) : undefined
    const configRules = config.rules ? (Array.isArray(config.rules) ? config.rules : [config.rules]) : undefined
    merged.rules = mergeArray(accRules, configRules)

    // Special handling for excludeFiles array
    merged.excludeFiles = mergeArray(acc.excludeFiles, config.excludeFiles)

    return merged
  }, {} as Config) // Add initial value to prevent potential errors with empty arrays

  return mergedConfig
}

export type LoadedConfig = Omit<Config, 'rules'> & { rules?: string }

export async function resolveRules(rules?: ConfigRule[] | string) {
  if (!rules) {
    return undefined
  }
  if (typeof rules === 'string') {
    return rules
  }

  const resolvedRules = await Promise.all(
    rules.map(async (rule) => {
      if (typeof rule === 'string') {
        return rule
      }
      if ('url' in rule) {
        try {
          const controller = new AbortController()
          const timeoutId = setTimeout(() => controller.abort(), 30000) // 30 second timeout
          const response = await fetch(rule.url, { signal: controller.signal })
          clearTimeout(timeoutId)
          if (response.ok) {
            return await response.text()
          }
          console.warn(`Failed to fetch rule from ${rule.url}: ${response.statusText}`)
        } catch (error) {
          if (error instanceof Error && error.name === 'AbortError') {
            console.warn(`Timeout fetching rule from ${rule.url} (30s)`)
          } else {
            console.warn(`Error fetching rule from ${rule.url}: ${error}`)
          }
        }
      } else if ('repo' in rule) {
        const ref = rule.commit ?? rule.tag ?? rule.branch ?? 'main'
        const url = `https://raw.githubusercontent.com/${rule.repo}/${ref}/${rule.path}`
        try {
          const controller = new AbortController()
          const timeoutId = setTimeout(() => controller.abort(), 30000) // 30 second timeout
          const response = await fetch(url, { signal: controller.signal })
          clearTimeout(timeoutId)
          if (response.ok) {
            return await response.text()
          }
          console.warn(`Failed to fetch rule from ${url}: ${response.statusText}`)
        } catch (error) {
          if (error instanceof Error && error.name === 'AbortError') {
            console.warn(`Timeout fetching rule from ${url} (30s)`)
          } else {
            console.warn(`Error fetching rule from ${url}: ${error}`)
          }
        }
      } else if ('path' in rule) {
        if (existsSync(rule.path)) {
          return await readFile(rule.path, 'utf-8')
        }
        console.warn(`Rule file not found: ${rule.path}`)
      }
      return undefined
    }),
  )

  return resolvedRules.filter((rule): rule is string => rule !== undefined).join('\n\n')
}

export async function loadConfig(
  paths?: string | string[],
  cwd: string = process.cwd(),
  home = homedir(),
): Promise<LoadedConfig | undefined> {
  const configs: Config[] = []

  // Load global config if exists
  const globalConfigPath = getGlobalConfigPath(home)
  if (existsSync(globalConfigPath)) {
    try {
      const globalConfig = readConfig(globalConfigPath)
      configs.push(globalConfig)
    } catch (error) {
      console.warn(`Error loading global config file: ${globalConfigPath}\n${error}`)
    }
  }

  // Load project configs
  if (paths && paths.length > 0) {
    const configPaths = Array.isArray(paths) ? paths : [paths]
    for (const path of configPaths) {
      try {
        const config = readConfig(path)
        configs.push(config)
      } catch (error) {
        // Check for ENOENT (file not found) - silently skip these
        const errorCode = (error as NodeJS.ErrnoException)?.code
        if (errorCode === 'ENOENT') {
          // File not found is not an error
          continue
        }
        // All other errors should be reported (YAML parse errors, validation errors, etc)
        console.error(`Error loading config file: ${path}\n${error}`)
        throw error
      }
    }
  } else {
    const configPath = join(cwd, localConfigFileName)
    try {
      const projectConfig = readConfig(configPath)
      configs.push(projectConfig)
    } catch (error) {
      if (error instanceof ZodError) {
        console.error(`Error in config file: ${configPath}\n${error}`)
        throw error
      }
    }
  }

  const mergedConfig = configs.length > 0 ? mergeConfigs(configs) : undefined

  if (!mergedConfig) {
    return undefined
  }

  const resolvedRules = await resolveRules(mergedConfig.rules)

  return {
    ...mergedConfig,
    rules: resolvedRules,
  }
}

export const readConfig = (path: string): Config => {
  const file = readFileSync(path, 'utf8')
  const config = parse(file)
  const result = configSchema.parse(config)
  if (result == null) {
    return {}
  }
  return result
}

export const readLocalConfig = (path?: string): Config | undefined => {
  try {
    return readConfig(path ?? localConfigFileName)
  } catch (error) {
    // Log debug message - this function is used to check if local config exists
    if (error instanceof ZodError) {
      // Validation errors should be logged as warnings
      console.warn(`Local config validation failed for ${path ?? localConfigFileName}: ${error.message}`)
    } else {
      // Other errors (file not found, parse errors) are expected
      console.debug(
        `Could not load local config from ${path ?? localConfigFileName}: ${error instanceof Error ? error.message : String(error)}`,
      )
    }
    return undefined
  }
}
