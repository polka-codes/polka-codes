// generated by polka.codes
import { existsSync } from 'node:fs'
import { readdir, readFile } from 'node:fs/promises'
import { join } from 'node:path'
import { parse } from 'yaml'
import { IGNORED_DIRECTORIES, SKILL_ERROR_MESSAGES, SKILL_LIMITS } from './constants'
import type { Skill, SkillContext, SkillMetadata } from './types'
import { SkillDiscoveryError, skillMetadataSchema } from './types'

/**
 * Service for discovering and loading Agent Skills from filesystem
 *
 * Skills are discovered from three sources with priority:
 * 1. Project skills at .claude/skills/ (highest priority)
 * 2. Personal skills at ~/.claude/skills/
 * 3. Plugin skills at node_modules (lowest priority)
 */
export class SkillDiscoveryService {
  private personalSkillsDir: string
  private projectSkillsDir: string
  private pluginSkillsDirs: string[]

  constructor(options: {
    cwd: string
    personalSkillsDir?: string
    pluginSkillsDirs?: string[]
  }) {
    this.personalSkillsDir = options.personalSkillsDir ?? join(process.env.HOME || '', '.claude', 'skills')
    this.projectSkillsDir = join(options.cwd, '.claude', 'skills')
    this.pluginSkillsDirs = options.pluginSkillsDirs ?? []
  }

  /**
   * Discover all available skills from all sources
   * Removes duplicates (project skills take priority over personal/plugin)
   */
  async discoverAll(): Promise<Skill[]> {
    const skills: Skill[] = []

    // Load in parallel but handle failures gracefully
    const results = await Promise.allSettled([
      this.discoverInDirectory(this.projectSkillsDir, 'project'),
      this.discoverInDirectory(this.personalSkillsDir, 'personal'),
      this.discoverPlugins(),
    ])

    // Extract successful results
    const projectSkills = results[0].status === 'fulfilled' ? results[0].value : []
    const personalSkills = results[1].status === 'fulfilled' ? results[1].value : []
    const pluginSkills = results[2].status === 'fulfilled' ? results[2].value : []

    // Log errors if any failed
    if (results[0].status === 'rejected') {
      console.warn(`Failed to load project skills: ${results[0].reason}`)
    }
    if (results[1].status === 'rejected') {
      console.warn(`Failed to load personal skills: ${results[1].reason}`)
    }
    if (results[2].status === 'rejected') {
      console.warn(`Failed to load plugin skills: ${results[2].reason}`)
    }

    // Filter out duplicates (project skills take priority)
    const seenNames = new Set<string>()
    const allSkills = [...projectSkills, ...personalSkills, ...pluginSkills]

    for (const skill of allSkills) {
      if (!seenNames.has(skill.metadata.name)) {
        seenNames.add(skill.metadata.name)
        skills.push(skill)
      }
    }

    return skills
  }

  /**
   * Discover skills in a specific directory
   */
  async discoverInDirectory(dir: string, source: 'personal' | 'project' | 'plugin'): Promise<Skill[]> {
    if (!existsSync(dir)) {
      return []
    }

    const skills: Skill[] = []
    const entries = await readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      if (!entry.isDirectory()) {
        continue
      }

      const skillPath = join(dir, entry.name)
      const skillMdPath = join(skillPath, 'SKILL.md')

      if (!existsSync(skillMdPath)) {
        continue
      }

      try {
        const skill = await this.loadSkill(skillPath, source)
        skills.push(skill)
      } catch (error) {
        if (error instanceof SkillDiscoveryError) {
          console.warn(`Warning: ${error.message} (path: ${error.path})`)
        } else {
          throw error
        }
      }
    }

    return skills
  }

  /**
   * Discover skills from plugin directories (node_modules)
   */
  async discoverPlugins(): Promise<Skill[]> {
    const skills: Skill[] = []

    for (const pluginDir of this.pluginSkillsDirs) {
      if (!existsSync(pluginDir)) {
        continue
      }

      const pluginSkills = await this.discoverInDirectory(pluginDir, 'plugin')
      skills.push(...pluginSkills)
    }

    return skills
  }

  /**
   * Load a single skill from its directory
   */
  async loadSkill(skillPath: string, source: 'personal' | 'project' | 'plugin'): Promise<Skill> {
    const skillMdPath = join(skillPath, 'SKILL.md')

    if (!existsSync(skillMdPath)) {
      throw new SkillDiscoveryError('SKILL.md not found', skillPath)
    }

    const content = await readFile(skillMdPath, 'utf-8')
    const { metadata, content: instructions } = this.parseSkillMd(content)

    // Load additional files
    const files = new Map<string, string>()
    const entries = await readdir(skillPath, { withFileTypes: true })

    for (const entry of entries) {
      if (entry.name === 'SKILL.md') {
        continue
      }

      const filePath = join(skillPath, entry.name)

      if (entry.isFile()) {
        const fileContent = await readFile(filePath, 'utf-8')
        files.set(entry.name, fileContent)
      } else if (entry.isDirectory()) {
        // Recursively load directory contents
        await this.loadDirectoryFiles(filePath, entry.name, files)
      }
    }

    return {
      metadata,
      content: instructions,
      files,
      path: skillPath,
      source,
    }
  }

  /**
   * Parse SKILL.md content and extract frontmatter
   */
  private parseSkillMd(content: string): { metadata: SkillMetadata; content: string } {
    // Use \r?\n to support both LF and CRLF line endings
    // Use \s* to allow optional trailing spaces after ---
    const frontmatterRegex = /^---\r?\n([\s\S]+?)\r?\n---\r?\n([\s\S]*)$/
    const match = content.match(frontmatterRegex)

    if (!match || match.length < 3) {
      throw new SkillDiscoveryError(SKILL_ERROR_MESSAGES.MISSING_FRONTMATTER, '')
    }

    const frontmatter = match[1] ?? ''
    const instructions = match[2] ?? ''

    try {
      const metadata = this.parseMetadata(frontmatter)
      return { metadata, content: instructions }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      throw new SkillDiscoveryError(`Invalid frontmatter: ${message}`, '')
    }
  }

  /**
   * Parse and validate YAML frontmatter
   */
  private parseMetadata(frontmatter: string): SkillMetadata {
    const parsed = parse(frontmatter)
    return skillMetadataSchema.parse(parsed)
  }

  /**
   * Recursively load files from a directory into the files map
   */
  private async loadDirectoryFiles(dirPath: string, prefix: string, files: Map<string, string>, depth = 0): Promise<void> {
    const { MAX_DEPTH, MAX_FILES } = SKILL_LIMITS

    // Prevent stack overflow from deep recursion
    if (depth > MAX_DEPTH) {
      return
    }

    // Prevent memory exhaustion from too many files
    if (files.size >= MAX_FILES) {
      return
    }

    // Check if the current directory (from prefix) should be ignored
    const currentDirName = prefix.split('/').pop() ?? prefix
    if ((IGNORED_DIRECTORIES as readonly string[]).includes(currentDirName)) {
      return
    }

    const entries = await readdir(dirPath, { withFileTypes: true })

    for (const entry of entries) {
      // Check file count limit before processing each entry
      if (files.size >= MAX_FILES) {
        break
      }

      const filePath = join(dirPath, entry.name)
      const key = `${prefix}/${entry.name}`

      if (entry.isFile()) {
        const content = await readFile(filePath, 'utf-8')
        files.set(key, content)
      } else if (entry.isDirectory()) {
        // Skip ignored directories
        if ((IGNORED_DIRECTORIES as readonly string[]).includes(entry.name)) {
          continue
        }
        await this.loadDirectoryFiles(filePath, key, files, depth + 1)
      }
    }
  }

  /**
   * Create an initial skill context object
   */
  async createContext(): Promise<SkillContext> {
    const availableSkills = await this.discoverAll()

    return {
      activeSkill: null,
      availableSkills,
      skillLoadingHistory: [],
    }
  }
}
