// generated by polka.codes
import { existsSync } from 'node:fs'
import { readdir, readFile, stat } from 'node:fs/promises'
import { join } from 'node:path'
import { parse } from 'yaml'
import { ZodError } from 'zod'
import { IGNORED_DIRECTORIES, SKILL_ERROR_MESSAGES, SKILL_LIMITS } from './constants'
import type { Skill, SkillContext, SkillMetadata } from './types'
import { SkillDiscoveryError, skillMetadataSchema } from './types'

/**
 * List of binary file extensions that should not be loaded as text
 */
const BINARY_EXTENSIONS = [
  '.png',
  '.jpg',
  '.jpeg',
  '.gif',
  '.bmp',
  '.ico',
  '.webp',
  '.pdf',
  '.zip',
  '.tar',
  '.gz',
  '.exe',
  '.dll',
  '.so',
  '.dylib',
  '.bin',
  '.dat',
  '.db',
  '.sqlite',
  '.woff',
  '.woff2',
  '.ttf',
  '.eot',
]

/**
 * Check if a file is likely binary based on its extension
 *
 * This is a simple check based on file extensions. For more reliable detection,
 * consider reading the first few bytes and checking for null bytes.
 */
function isBinaryFile(filename: string): boolean {
  const ext = filename.toLowerCase().slice(filename.lastIndexOf('.'))
  return BINARY_EXTENSIONS.includes(ext)
}

/**
 * Service for discovering and loading Agent Skills from filesystem
 *
 * Skills are discovered from three sources with priority:
 * 1. Project skills at .claude/skills/ (highest priority)
 * 2. Personal skills at ~/.claude/skills/
 * 3. Plugin skills at node_modules (lowest priority)
 */
export class SkillDiscoveryService {
  private personalSkillsDir: string
  private projectSkillsDir: string
  private pluginSkillsDirs: string[]

  constructor(options: {
    cwd: string
    personalSkillsDir?: string
    pluginSkillsDirs?: string[]
  }) {
    this.personalSkillsDir = options.personalSkillsDir ?? join(process.env.HOME || '', '.claude', 'skills')
    this.projectSkillsDir = join(options.cwd, '.claude', 'skills')
    this.pluginSkillsDirs = options.pluginSkillsDirs ?? []
  }

  /**
   * Discover all available skills from all sources
   * Removes duplicates (project skills take priority over personal/plugin)
   */
  async discoverAll(): Promise<Skill[]> {
    const skills: Skill[] = []

    // Load in parallel but handle failures gracefully
    const results = await Promise.allSettled([
      this.discoverInDirectory(this.projectSkillsDir, 'project'),
      this.discoverInDirectory(this.personalSkillsDir, 'personal'),
      this.discoverPlugins(),
    ])

    // Extract successful results
    const projectSkills = results[0].status === 'fulfilled' ? results[0].value : []
    const personalSkills = results[1].status === 'fulfilled' ? results[1].value : []
    const pluginSkills = results[2].status === 'fulfilled' ? results[2].value : []

    // Log errors if any failed
    if (results[0].status === 'rejected') {
      console.warn(`Failed to load project skills: ${results[0].reason}`)
    }
    if (results[1].status === 'rejected') {
      console.warn(`Failed to load personal skills: ${results[1].reason}`)
    }
    if (results[2].status === 'rejected') {
      console.warn(`Failed to load plugin skills: ${results[2].reason}`)
    }

    // Filter out duplicates (project skills take priority)
    const seenNames = new Set<string>()
    const allSkills = [...projectSkills, ...personalSkills, ...pluginSkills]

    for (const skill of allSkills) {
      if (!seenNames.has(skill.metadata.name)) {
        seenNames.add(skill.metadata.name)
        skills.push(skill)
      }
    }

    return skills
  }

  /**
   * Discover skills in a specific directory
   */
  async discoverInDirectory(dir: string, source: 'personal' | 'project' | 'plugin'): Promise<Skill[]> {
    if (!existsSync(dir)) {
      return []
    }

    const skills: Skill[] = []
    const entries = await readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      if (!entry.isDirectory()) {
        continue
      }

      const skillPath = join(dir, entry.name)
      const skillMdPath = join(skillPath, 'SKILL.md')

      if (!existsSync(skillMdPath)) {
        continue
      }

      try {
        const skill = await this.loadSkill(skillPath, source)
        skills.push(skill)
      } catch (error) {
        // Log all errors and continue to discover other skills
        let message = 'Unknown error'
        let path = skillPath

        if (error instanceof SkillDiscoveryError) {
          message = error.message
          path = error.path
        } else if (error instanceof ZodError) {
          message = error.issues[0]?.message ?? 'Invalid skill metadata'
        } else if (error instanceof Error) {
          message = error.message
        }

        console.warn(`Warning: Failed to load skill at ${path}: ${message}`)
      }
    }

    return skills
  }

  /**
   * Discover skills from plugin directories (node_modules)
   */
  async discoverPlugins(): Promise<Skill[]> {
    const skills: Skill[] = []

    for (const pluginDir of this.pluginSkillsDirs) {
      if (!existsSync(pluginDir)) {
        continue
      }

      const pluginSkills = await this.discoverInDirectory(pluginDir, 'plugin')
      skills.push(...pluginSkills)
    }

    return skills
  }

  /**
   * Load a single skill from its directory
   */
  async loadSkill(skillPath: string, source: 'personal' | 'project' | 'plugin'): Promise<Skill> {
    const skillMdPath = join(skillPath, 'SKILL.md')

    if (!existsSync(skillMdPath)) {
      throw new SkillDiscoveryError('SKILL.md not found', skillPath)
    }

    const content = await readFile(skillMdPath, 'utf-8')
    const { metadata, content: instructions } = this.parseSkillMd(content)

    // Load additional files
    const files = new Map<string, string>()
    let totalSize = 0
    const entries = await readdir(skillPath, { withFileTypes: true })

    for (const entry of entries) {
      if (entry.name === 'SKILL.md') {
        continue
      }

      const filePath = join(skillPath, entry.name)

      if (entry.isFile()) {
        // Skip binary files to avoid corruption
        if (isBinaryFile(entry.name)) {
          continue
        }

        // Check file size before reading to prevent OOM
        const fileSize = (await stat(filePath)).size
        if (fileSize > SKILL_LIMITS.MAX_FILE_SIZE) {
          throw new SkillDiscoveryError(`File size exceeds limit (${fileSize} > ${SKILL_LIMITS.MAX_FILE_SIZE}): ${entry.name}`, skillPath)
        }

        // Track cumulative size to prevent resource exhaustion
        totalSize += fileSize
        if (totalSize > SKILL_LIMITS.MAX_SKILL_SIZE) {
          throw new SkillDiscoveryError(
            `Total skill size exceeds limit (${totalSize} > ${SKILL_LIMITS.MAX_SKILL_SIZE}): ${skillPath}`,
            skillPath,
          )
        }

        const fileContent = await readFile(filePath, 'utf-8')
        files.set(entry.name, fileContent)
      } else if (entry.isDirectory()) {
        // Recursively load directory contents
        await this.loadDirectoryFiles(filePath, entry.name, files, 0, { value: totalSize })
      }
    }

    return {
      metadata,
      content: instructions,
      files,
      path: skillPath,
      source,
    }
  }

  /**
   * Parse SKILL.md content and extract frontmatter
   */
  private parseSkillMd(content: string): { metadata: SkillMetadata; content: string } {
    // Use \r?\n to support both LF and CRLF line endings
    // Use \s* to allow optional trailing spaces after ---
    const frontmatterRegex = /^---\r?\n([\s\S]+?)\r?\n---\r?\n([\s\S]*)$/
    const match = content.match(frontmatterRegex)

    if (!match || match.length < 3) {
      throw new SkillDiscoveryError(SKILL_ERROR_MESSAGES.MISSING_FRONTMATTER, '')
    }

    const frontmatter = match[1] ?? ''
    const instructions = match[2] ?? ''

    const metadata = this.parseMetadata(frontmatter)
    return { metadata, content: instructions }
  }

  /**
   * Parse and validate YAML frontmatter
   */
  private parseMetadata(frontmatter: string): SkillMetadata {
    const parsed = parse(frontmatter)
    return skillMetadataSchema.parse(parsed)
  }

  /**
   * Recursively load files from a directory into the files map
   * @param totalSizeRef Reference to track cumulative size (updated in place)
   */
  private async loadDirectoryFiles(
    dirPath: string,
    prefix: string,
    files: Map<string, string>,
    depth = 0,
    totalSizeRef: { value: number },
  ): Promise<void> {
    const { MAX_DEPTH, MAX_FILES } = SKILL_LIMITS

    // Prevent stack overflow from deep recursion
    if (depth > MAX_DEPTH) {
      return
    }

    // Prevent memory exhaustion from too many files
    if (files.size >= MAX_FILES) {
      return
    }

    // Check if the current directory (from prefix) should be ignored
    const currentDirName = prefix.split('/').pop() ?? prefix
    if ((IGNORED_DIRECTORIES as readonly string[]).includes(currentDirName)) {
      return
    }

    const entries = await readdir(dirPath, { withFileTypes: true })

    for (const entry of entries) {
      // Check file count limit before processing each entry
      if (files.size >= MAX_FILES) {
        break
      }

      const filePath = join(dirPath, entry.name)
      // Normalize key to avoid double slashes
      const key = `${prefix}/${entry.name}`.replace(/\/+/g, '/')

      if (entry.isFile()) {
        // Skip binary files to avoid corruption
        if (isBinaryFile(entry.name)) {
          continue
        }

        // Check file size before reading to prevent OOM
        const fileSize = (await stat(filePath)).size
        if (fileSize > SKILL_LIMITS.MAX_FILE_SIZE) {
          throw new SkillDiscoveryError(`File size exceeds limit (${fileSize} > ${SKILL_LIMITS.MAX_FILE_SIZE}): ${key}`, dirPath)
        }

        // Track cumulative size to prevent resource exhaustion
        totalSizeRef.value += fileSize
        if (totalSizeRef.value > SKILL_LIMITS.MAX_SKILL_SIZE) {
          throw new SkillDiscoveryError(
            `Total skill size exceeds limit (${totalSizeRef.value} > ${SKILL_LIMITS.MAX_SKILL_SIZE}): ${dirPath}`,
            dirPath,
          )
        }

        const content = await readFile(filePath, 'utf-8')
        files.set(key, content)
      } else if (entry.isDirectory()) {
        // Skip ignored directories
        if ((IGNORED_DIRECTORIES as readonly string[]).includes(entry.name)) {
          continue
        }
        await this.loadDirectoryFiles(filePath, key, files, depth + 1, totalSizeRef)
      }
    }
  }

  /**
   * Create an initial skill context object
   */
  async createContext(): Promise<SkillContext> {
    const availableSkills = await this.discoverAll()

    return {
      activeSkill: null,
      availableSkills,
      skillLoadingHistory: [],
    }
  }
}
