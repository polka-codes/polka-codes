// generated by polka.codes
import { existsSync } from 'node:fs'
import { readdir, readFile, stat } from 'node:fs/promises'
import { join } from 'node:path'
import { parse } from 'yaml'
import { ZodError } from 'zod'
import { IGNORED_DIRECTORIES, SKILL_ERROR_MESSAGES, SKILL_LIMITS } from './constants'
import type { Skill, SkillContext, SkillMetadata, SkillReference } from './types'
import { SkillDiscoveryError, skillMetadataSchema } from './types'

/**
 * PERFORMANCE CONSIDERATION
 *
 * The current implementation eagerly loads all skill files into memory during
 * discovery. This means every CLI command reads the full content of all skills
 * from disk, which can cause performance degradation with many skills.
 *
 * Future optimization: Implement lazy loading where discoverAll() only reads
 * SKILL.md metadata, and full skill content is loaded on-demand when the loadSkill
 * tool is called. This would significantly improve CLI startup time.
 */

/**
 * List of binary file extensions that should not be loaded as text
 */
const BINARY_EXTENSIONS = [
  '.png',
  '.jpg',
  '.jpeg',
  '.gif',
  '.bmp',
  '.ico',
  '.webp',
  '.pdf',
  '.zip',
  '.tar',
  '.gz',
  '.exe',
  '.dll',
  '.so',
  '.dylib',
  '.bin',
  '.dat',
  '.db',
  '.sqlite',
  '.woff',
  '.woff2',
  '.ttf',
  '.eot',
]

/**
 * Check if a file is likely binary based on its extension.
 *
 * For performance, this is a fast check based on known binary extensions.
 * Files without known extensions are assumed to be text and will be read.
 * If reading fails with encoding errors, the file will be skipped.
 *
 * @param filename - The filename to check
 * @returns true if the file has a known binary extension
 */
function isBinaryFile(filename: string): boolean {
  const ext = filename.toLowerCase().slice(filename.lastIndexOf('.'))
  return BINARY_EXTENSIONS.includes(ext)
}

/**
 * Check if a buffer contains binary content by looking for null bytes.
 * This is a simple heuristic that works for most binary files.
 *
 * @param buffer - The buffer to check
 * @returns true if the buffer appears to contain binary data
 */
function isBinaryContent(buffer: Buffer): boolean {
  // Check for null bytes in the first 8KB (common in binary files)
  const checkLength = Math.min(buffer.length, 8192)
  for (let i = 0; i < checkLength; i++) {
    if (buffer[i] === 0) {
      return true
    }
  }
  return false
}

/**
 * Try to read a file as UTF-8 text, returning null if it appears to be binary.
 * This handles binary files that don't have known extensions by checking content.
 *
 * @param filePath - The path to the file to read
 * @returns The file content as a string, or null if it appears to be binary
 */
async function tryReadTextFile(filePath: string): Promise<string | null> {
  try {
    // First, read as a buffer to check for binary content
    const buffer = await readFile(filePath)

    // Check if the file contains binary content
    if (isBinaryContent(buffer)) {
      return null
    }

    // If not binary, decode as UTF-8
    return buffer.toString('utf-8')
  } catch (error) {
    // If reading fails (e.g., directory), skip it
    if (error && typeof error === 'object' && 'code' in error && (error.code === 'EINVAL' || error.code === 'EISDIR')) {
      return null
    }
    throw error
  }
}

/**
 * Service for discovering and loading Agent Skills from filesystem
 *
 * Skills are discovered from three sources with priority:
 * 1. Project skills at .claude/skills/ (highest priority)
 * 2. Personal skills at ~/.claude/skills/
 * 3. Plugin skills at node_modules (lowest priority)
 */
export class SkillDiscoveryService {
  private personalSkillsDir: string
  private projectSkillsDir: string
  private pluginSkillsDirs: string[]

  constructor(options: {
    cwd: string
    personalSkillsDir?: string
    pluginSkillsDirs?: string[]
  }) {
    this.personalSkillsDir = options.personalSkillsDir ?? join(process.env.HOME || '', '.claude', 'skills')
    this.projectSkillsDir = join(options.cwd, '.claude', 'skills')
    this.pluginSkillsDirs = options.pluginSkillsDirs ?? []
  }

  /**
   * Discover all available skills from all sources
   * Removes duplicates (project skills take priority over personal/plugin)
   */
  async discoverAll(): Promise<SkillReference[]> {
    const skills: SkillReference[] = []

    // Load in parallel but handle failures gracefully
    const results = await Promise.allSettled([
      this.discoverInDirectory(this.projectSkillsDir, 'project'),
      this.discoverInDirectory(this.personalSkillsDir, 'personal'),
      this.discoverPlugins(),
    ])

    // Extract successful results
    const projectSkills = results[0].status === 'fulfilled' ? results[0].value : []
    const personalSkills = results[1].status === 'fulfilled' ? results[1].value : []
    const pluginSkills = results[2].status === 'fulfilled' ? results[2].value : []

    // Log errors if any failed
    if (results[0].status === 'rejected') {
      console.warn(`Failed to load project skills: ${results[0].reason}`)
    }
    if (results[1].status === 'rejected') {
      console.warn(`Failed to load personal skills: ${results[1].reason}`)
    }
    if (results[2].status === 'rejected') {
      console.warn(`Failed to load plugin skills: ${results[2].reason}`)
    }

    // Filter out duplicates (project skills take priority)
    const seenNames = new Set<string>()
    const allSkills = [...projectSkills, ...personalSkills, ...pluginSkills]

    for (const skill of allSkills) {
      if (!seenNames.has(skill.metadata.name)) {
        seenNames.add(skill.metadata.name)
        skills.push(skill)
      }
    }

    return skills
  }

  /**
   * Discover skills in a specific directory
   */
  async discoverInDirectory(dir: string, source: 'personal' | 'project' | 'plugin'): Promise<SkillReference[]> {
    if (!existsSync(dir)) {
      return []
    }

    const skills: SkillReference[] = []
    const entries = await readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      if (!entry.isDirectory()) {
        continue
      }

      const skillPath = join(dir, entry.name)
      const skillMdPath = join(skillPath, 'SKILL.md')

      if (!existsSync(skillMdPath)) {
        continue
      }

      try {
        // Only load metadata
        const content = await readFile(skillMdPath, 'utf-8')
        const { metadata } = this.parseSkillMd(content)

        skills.push({
          metadata,
          path: skillPath,
          source,
        })
      } catch (error) {
        // Log all errors and continue to discover other skills
        let message = 'Unknown error'
        let path = skillPath

        if (error instanceof SkillDiscoveryError) {
          message = error.message
          path = error.path
        } else if (error instanceof ZodError) {
          message = error.issues[0]?.message ?? 'Invalid skill metadata'
        } else if (error instanceof Error) {
          message = error.message
        }

        console.warn(`Warning: Failed to load skill at ${path}: ${message}`)
      }
    }

    return skills
  }

  /**
   * Discover skills from plugin directories (node_modules)
   */
  async discoverPlugins(): Promise<SkillReference[]> {
    const skills: SkillReference[] = []

    for (const pluginDir of this.pluginSkillsDirs) {
      if (!existsSync(pluginDir)) {
        continue
      }

      const pluginSkills = await this.discoverInDirectory(pluginDir, 'plugin')
      skills.push(...pluginSkills)
    }

    return skills
  }

  /**
   * Load a single skill from its directory
   */
  async loadSkill(skillPath: string, source: 'personal' | 'project' | 'plugin'): Promise<Skill> {
    const skillMdPath = join(skillPath, 'SKILL.md')

    if (!existsSync(skillMdPath)) {
      throw new SkillDiscoveryError('SKILL.md not found', skillPath)
    }

    const content = await readFile(skillMdPath, 'utf-8')
    const { metadata, content: instructions } = this.parseSkillMd(content)

    // Load additional files
    const files = new Map<string, string>()
    let totalSize = 0
    const entries = await readdir(skillPath, { withFileTypes: true })

    for (const entry of entries) {
      if (entry.name === 'SKILL.md') {
        continue
      }

      const filePath = join(skillPath, entry.name)

      if (entry.isFile()) {
        // Skip binary files to avoid corruption
        if (isBinaryFile(entry.name)) {
          continue
        }

        // Check file size before reading to prevent OOM
        const fileSize = (await stat(filePath)).size
        if (fileSize > SKILL_LIMITS.MAX_FILE_SIZE) {
          throw new SkillDiscoveryError(`File size exceeds limit (${fileSize} > ${SKILL_LIMITS.MAX_FILE_SIZE}): ${entry.name}`, skillPath)
        }

        // Check if we would exceed the total skill size limit
        if (totalSize + fileSize > SKILL_LIMITS.MAX_SKILL_SIZE) {
          throw new SkillDiscoveryError(
            `Total skill size exceeds limit (${totalSize + fileSize} > ${SKILL_LIMITS.MAX_SKILL_SIZE}): ${skillPath}`,
            skillPath,
          )
        }

        const fileContent = await tryReadTextFile(filePath)
        if (fileContent === null) {
          // Skip binary files - don't count them towards total size
          continue
        }

        // Track cumulative size to prevent resource exhaustion
        totalSize += fileSize

        files.set(entry.name, fileContent)
      } else if (entry.isDirectory()) {
        // Recursively load directory contents and update total size
        totalSize = await this.loadDirectoryFiles(filePath, entry.name, files, 0, totalSize)
      }
    }

    return {
      metadata,
      content: instructions,
      files,
      path: skillPath,
      source,
    }
  }

  /**
   * Parse SKILL.md content and extract frontmatter
   */
  private parseSkillMd(content: string): { metadata: SkillMetadata; content: string } {
    // Use \r?\n to support both LF and CRLF line endings
    // Use \s* to allow optional trailing spaces after ---
    const frontmatterRegex = /^---\r?\n([\s\S]+?)\r?\n---\r?\n([\s\S]*)$/
    const match = content.match(frontmatterRegex)

    if (!match || match.length < 3) {
      throw new SkillDiscoveryError(SKILL_ERROR_MESSAGES.MISSING_FRONTMATTER, '')
    }

    const frontmatter = match[1] ?? ''
    const instructions = match[2] ?? ''

    const metadata = this.parseMetadata(frontmatter)
    return { metadata, content: instructions }
  }

  /**
   * Parse and validate YAML frontmatter
   */
  private parseMetadata(frontmatter: string): SkillMetadata {
    const parsed = parse(frontmatter)
    return skillMetadataSchema.parse(parsed)
  }

  /**
   * Recursively load files from a directory into the files map
   * @returns The total size of all files loaded (in bytes)
   */
  private async loadDirectoryFiles(
    dirPath: string,
    prefix: string,
    files: Map<string, string>,
    depth = 0,
    currentTotal: number = 0,
  ): Promise<number> {
    const { MAX_DEPTH, MAX_FILES } = SKILL_LIMITS
    let totalSize = currentTotal

    // Prevent stack overflow from deep recursion
    if (depth > MAX_DEPTH) {
      return totalSize
    }

    // Prevent memory exhaustion from too many files
    if (files.size >= MAX_FILES) {
      return totalSize
    }

    // Check if the current directory (from prefix) should be ignored
    const currentDirName = prefix.split('/').pop() ?? prefix
    if ((IGNORED_DIRECTORIES as readonly string[]).includes(currentDirName)) {
      return totalSize
    }

    const entries = await readdir(dirPath, { withFileTypes: true })

    for (const entry of entries) {
      // Check file count limit before processing each entry
      if (files.size >= MAX_FILES) {
        break
      }

      const filePath = join(dirPath, entry.name)
      // Normalize key to avoid double slashes
      const key = `${prefix}/${entry.name}`.replace(/\/+/g, '/')

      if (entry.isFile()) {
        // Skip binary files to avoid corruption
        if (isBinaryFile(entry.name)) {
          continue
        }

        // Check file size before reading to prevent OOM
        const fileSize = (await stat(filePath)).size
        if (fileSize > SKILL_LIMITS.MAX_FILE_SIZE) {
          throw new SkillDiscoveryError(`File size exceeds limit (${fileSize} > ${SKILL_LIMITS.MAX_FILE_SIZE}): ${key}`, dirPath)
        }

        // Check if we would exceed the total skill size limit
        if (totalSize + fileSize > SKILL_LIMITS.MAX_SKILL_SIZE) {
          throw new SkillDiscoveryError(
            `Total skill size exceeds limit (${totalSize + fileSize} > ${SKILL_LIMITS.MAX_SKILL_SIZE}): ${dirPath}`,
            dirPath,
          )
        }

        const content = await tryReadTextFile(filePath)
        if (content === null) {
          // Skip binary files - don't count them towards total size
          continue
        }

        // Track cumulative size to prevent resource exhaustion
        totalSize += fileSize

        files.set(key, content)
      } else if (entry.isDirectory()) {
        // Skip ignored directories
        if ((IGNORED_DIRECTORIES as readonly string[]).includes(entry.name)) {
          continue
        }
        totalSize = await this.loadDirectoryFiles(filePath, key, files, depth + 1, totalSize)
      }
    }

    return totalSize
  }

  /**
   * Create an initial skill context object
   */
  async createContext(): Promise<SkillContext> {
    const availableSkills = await this.discoverAll()

    return {
      activeSkill: null,
      availableSkills,
      skillLoadingHistory: [],
      loadSkill: async (name: string) => {
        const ref = availableSkills.find((s) => s.metadata.name === name)
        if (!ref) return null
        return this.loadSkill(ref.path, ref.source)
      },
    }
  }
}
