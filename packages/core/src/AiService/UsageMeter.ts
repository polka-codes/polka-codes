/**
 * UsageMeter class for tracking API usage metrics
 * Generated by polka.codes
 */

import type { ApiUsage } from './AiServiceBase'
import { type ModelInfo, type ModelPricingConfig, applyCustomPricing } from './ModelInfo'

export class UsageMeter {
  #modelPricingConfig?: ModelPricingConfig
  #usage = {
    inputTokens: 0,
    outputTokens: 0,
    cacheWriteTokens: 0,
    cacheReadTokens: 0,
    totalCost: 0,
  }

  #messageCount = 0

  readonly maxCost: number
  readonly maxMessageCount: number

  constructor(
    options: {
      maxCost?: number
      maxMessageCount?: number
      modelPricingConfig?: ModelPricingConfig
    } = {},
  ) {
    // default to some something is definitely wrong if ever exceeded value
    this.maxCost = options.maxCost || 1000
    this.maxMessageCount = options.maxMessageCount || 1000
    this.#modelPricingConfig = options.modelPricingConfig
  }

  /**
   * Add usage metrics to the current totals
   */
  addUsage(usage: Partial<ApiUsage>, model?: ModelInfo, provider?: string, modelId?: string): void {
    // Use atomic operations for thread safety
    this.#usage.inputTokens += usage.inputTokens ?? 0
    this.#usage.outputTokens += usage.outputTokens ?? 0
    this.#usage.cacheWriteTokens += usage.cacheWriteTokens ?? 0
    this.#usage.cacheReadTokens += usage.cacheReadTokens ?? 0

    if (!usage.totalCost && model) {
      // Apply custom pricing if available
      const modelWithCustomPricing =
        provider && modelId && this.#modelPricingConfig ? applyCustomPricing(model, modelId, provider, this.#modelPricingConfig) : model

      usage.totalCost =
        ((modelWithCustomPricing.inputPrice ?? 0) * (usage.inputTokens ?? 0) +
          (modelWithCustomPricing.outputPrice ?? 0) * (usage.outputTokens ?? 0) +
          (modelWithCustomPricing.cacheWritesPrice ?? 0) * (usage.cacheWriteTokens ?? 0) +
          (modelWithCustomPricing.cacheReadsPrice ?? 0) * (usage.cacheReadTokens ?? 0)) /
        1_000_000
    }

    this.#usage.totalCost += usage.totalCost ?? 0
  }

  incrementMessageCount(count = 1) {
    this.#messageCount += count
  }

  isLimitExceeded() {
    const messageCount = this.#messageCount >= this.maxMessageCount
    const cost = this.#usage.totalCost >= this.maxCost
    return {
      messageCount,
      cost,
      result: messageCount || cost,
    }
  }

  /**
   * Get current usage totals
   */
  get usage(): ApiUsage {
    return { ...this.#usage }
  }

  printUsage() {
    const { inputTokens, outputTokens, cacheReadTokens, cacheWriteTokens } = this.#usage
    const allTokensZero = inputTokens === 0 && outputTokens === 0 && cacheReadTokens === 0 && cacheWriteTokens === 0

    console.log('Usages:')
    if (!allTokensZero) {
      console.log(`Input tokens: ${this.#usage.inputTokens}`)
      console.log(`Output tokens: ${this.#usage.outputTokens}`)
      console.log(`Cache read tokens: ${this.#usage.cacheReadTokens}`)
      console.log(`Cache write tokens: ${this.#usage.cacheWriteTokens}`)
    }
    console.log(`Total cost: ${this.#usage.totalCost}`)
  }
}
