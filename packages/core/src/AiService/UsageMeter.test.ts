/**
 * Tests for UsageMeter class
 * Generated by polka.codes
 */

import { describe, expect, spyOn, test } from 'bun:test'
import { UsageMeter } from './UsageMeter'

describe('UsageMeter', () => {
  test('should initialize with zero values', () => {
    const meter = new UsageMeter()
    expect(meter.usage).toMatchSnapshot()
  })

  test('should correctly add usage metrics', () => {
    const meter = new UsageMeter()

    meter.addUsage({
      inputTokens: 100,
      outputTokens: 50,
      cacheWriteTokens: 25,
      cacheReadTokens: 10,
      totalCost: 0.002,
    })

    expect(meter.usage).toMatchSnapshot()
  })

  test('should handle partial usage updates', () => {
    const meter = new UsageMeter()

    meter.addUsage({ inputTokens: 100 })
    meter.addUsage({ outputTokens: 50 })
    meter.addUsage({ totalCost: 0.001 })

    expect(meter.usage).toMatchSnapshot()
  })

  test('should handle multiple consecutive updates', () => {
    const meter = new UsageMeter()

    meter.addUsage({ inputTokens: 50, outputTokens: 25 })
    meter.addUsage({ inputTokens: 30, cacheReadTokens: 10 })
    meter.addUsage({ outputTokens: 15, totalCost: 0.001 })

    expect(meter.usage).toMatchSnapshot()
  })

  test('should calculate cost when not provided but model info is available', () => {
    const meter = new UsageMeter()

    // Add usage without totalCost but with model info
    meter.addUsage(
      {
        inputTokens: 1000,
        outputTokens: 500,
        cacheWriteTokens: 100,
        cacheReadTokens: 50,
      },
      { provider: 'anthropic', id: 'claude-3-haiku-20240307' },
    )

    // Calculation:
    // (0.25 * 1000 + 1.25 * 500 + 0.3 * 100 + 0.03 * 50) / 1_000_000
    // = (250 + 625 + 30 + 1.5) / 1_000_000
    // = 906.5 / 1_000_000
    // = 0.0009065

    expect(meter.usage.totalCost).toBeCloseTo(0.0009065, 6)
    expect(meter.usage).toMatchSnapshot()
  })

  test('should not calculate cost when model info is not available', () => {
    const meter = new UsageMeter()

    // Add usage without totalCost with non-existent model
    meter.addUsage(
      {
        inputTokens: 1000,
        outputTokens: 500,
      },
      { provider: 'unknown-provider', id: 'unknown-model' },
    )

    // Should not add any cost since the model info isn't available
    expect(meter.usage.totalCost).toBe(0)
    expect(meter.usage).toMatchSnapshot()
  })

  test('should increment message count by default amount', () => {
    const meter = new UsageMeter({ maxMessageCount: 10 })

    meter.incrementMessageCount()

    // Check if limit is not exceeded after 1 increment
    expect(meter.isLimitExceeded().messageCount).toBe(false)

    // Add 9 more to reach the limit
    for (let i = 0; i < 9; i++) {
      meter.incrementMessageCount()
    }

    // Now the message count limit should be exceeded
    expect(meter.isLimitExceeded().messageCount).toBe(true)
  })

  test('should increment message count by custom amount', () => {
    const meter = new UsageMeter({ maxMessageCount: 10 })

    meter.incrementMessageCount(5)

    // Check if limit is not exceeded after incrementing by 5
    expect(meter.isLimitExceeded().messageCount).toBe(false)

    // Add 5 more to just reach the limit
    meter.incrementMessageCount(5)

    // Now the message count limit should be exactly reached
    expect(meter.isLimitExceeded().messageCount).toBe(true)
  })

  test('should detect when cost limit is exceeded', () => {
    const meter = new UsageMeter({ maxCost: 0.1 })

    // Add usage below the limit
    meter.addUsage({ totalCost: 0.05 })
    expect(meter.isLimitExceeded().cost).toBe(false)

    // Add more usage to exceed the limit
    meter.addUsage({ totalCost: 0.06 })
    expect(meter.isLimitExceeded().cost).toBe(true)
    expect(meter.isLimitExceeded().result).toBe(true)
  })

  test('should report overall limit exceeded status correctly', () => {
    const meter = new UsageMeter({ maxCost: 0.2, maxMessageCount: 5 })

    // Case 1: Neither limit is exceeded
    expect(meter.isLimitExceeded().result).toBe(false)

    // Case 2: Only message count limit is exceeded
    meter.incrementMessageCount(5)
    expect(meter.isLimitExceeded().messageCount).toBe(true)
    expect(meter.isLimitExceeded().cost).toBe(false)
    expect(meter.isLimitExceeded().result).toBe(true)

    // Create a new instance for testing only cost limit
    const meter2 = new UsageMeter({ maxCost: 0.2, maxMessageCount: 100 })

    // Case 3: Only cost limit is exceeded
    meter2.addUsage({ totalCost: 0.21 })
    expect(meter2.isLimitExceeded().messageCount).toBe(false)
    expect(meter2.isLimitExceeded().cost).toBe(true)
    expect(meter2.isLimitExceeded().result).toBe(true)
  })

  test('should use custom pricing configuration', () => {
    // Create custom pricing configuration
    const customPrices = {
      'custom-provider': {
        'custom-model': {
          inputPrice: 5.0,
          outputPrice: 10.0,
          cacheWritesPrice: 2.0,
          cacheReadsPrice: 1.0,
        },
      },
    }

    const meter = new UsageMeter({ prices: customPrices })

    // Add usage with the custom model
    meter.addUsage(
      {
        inputTokens: 1000,
        outputTokens: 500,
        cacheWriteTokens: 200,
        cacheReadTokens: 100,
      },
      { provider: 'custom-provider', id: 'custom-model' },
    )

    // Calculation:
    // (5.0 * 1000 + 10.0 * 500 + 2.0 * 200 + 1.0 * 100) / 1_000_000
    // = (5000 + 5000 + 400 + 100) / 1_000_000
    // = 10500 / 1_000_000
    // = 0.0105

    expect(meter.usage.totalCost).toBeCloseTo(0.0105, 5)
    expect(meter.usage).toMatchSnapshot()
  })

  test('should override existing pricing with custom configuration', () => {
    // Create custom pricing that overrides an existing model
    const customPrices = {
      anthropic: {
        'claude-3-haiku-20240307': {
          inputPrice: 1.0, // Override from 0.25
          outputPrice: 2.0, // Override from 1.25
          cacheWritesPrice: 0.5, // Override from 0.3
          cacheReadsPrice: 0.1, // Override from 0.03
        },
      },
    }

    const meter = new UsageMeter({ prices: customPrices })

    // Add usage with the overridden model
    meter.addUsage(
      {
        inputTokens: 1000,
        outputTokens: 500,
        cacheWriteTokens: 200,
        cacheReadTokens: 100,
      },
      { provider: 'anthropic', id: 'claude-3-haiku-20240307' },
    )

    // Calculation:
    // (1.0 * 1000 + 2.0 * 500 + 0.5 * 200 + 0.1 * 100) / 1_000_000
    // = (1000 + 1000 + 100 + 10) / 1_000_000
    // = 2110 / 1_000_000
    // = 0.00211

    expect(meter.usage.totalCost).toBeCloseTo(0.00211, 5)
    expect(meter.usage).toMatchSnapshot()
  })

  test('should handle printUsage for zero token counts', () => {
    const meter = new UsageMeter()

    // Spy on console.log
    const consoleSpy = spyOn(console, 'log')

    // Call printUsage with zero token counts (initial state)
    meter.printUsage()

    // Verify only the "Usages:" and "Total cost:" lines were logged
    expect(consoleSpy).toHaveBeenCalledTimes(2)
    expect(consoleSpy).toHaveBeenCalledWith('Usages:')
    expect(consoleSpy).toHaveBeenCalledWith('Total cost: 0')

    // Reset the spy
    consoleSpy.mockReset()

    // Add some usage
    meter.addUsage({
      inputTokens: 100,
      outputTokens: 50,
      cacheWriteTokens: 25,
      cacheReadTokens: 10,
      totalCost: 0.002,
    })

    // Call printUsage with non-zero token counts
    meter.printUsage()

    // Verify all token counts and cost were logged
    expect(consoleSpy).toHaveBeenCalledTimes(6)
    expect(consoleSpy).toHaveBeenCalledWith('Usages:')
    expect(consoleSpy).toHaveBeenCalledWith('Input tokens: 100')
    expect(consoleSpy).toHaveBeenCalledWith('Output tokens: 50')
    expect(consoleSpy).toHaveBeenCalledWith('Cache read tokens: 10')
    expect(consoleSpy).toHaveBeenCalledWith('Cache write tokens: 25')
    expect(consoleSpy).toHaveBeenCalledWith('Total cost: 0.002')

    // Restore the spy
    consoleSpy.mockRestore()
  })
})
