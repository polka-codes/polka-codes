/**
 * UsageMeter class for tracking API usage metrics
 * Generated by polka.codes
 */

import type { LanguageModelV2, LanguageModelV2Usage } from '@ai-sdk/provider'

export type ModelInfo = {
  inputPrice: number
  outputPrice: number
  cacheWritesPrice: number
  cacheReadsPrice: number
}

type Totals = { input: number; output: number; reasoning: number; cached: number; cost: number }
const PER_M = 1_000_000

function costFor(m: ModelInfo, uncached: number, cached: number, outs: number, cache: boolean): number {
  const promptCost = cache ? uncached * m.cacheWritesPrice + cached * m.cacheReadsPrice : uncached * m.inputPrice // cached === 0 when cache disabled
  const completionCost = outs * m.outputPrice
  return (promptCost + completionCost) / PER_M
}

/**
 * Tracks token / cost usage across any mix of LLM models.
 * Supports optional caps on total messages and total cost.
 */
export class UsageMeter {
  #totals: Totals = { input: 0, output: 0, reasoning: 0, cached: 0, cost: 0 }
  #calls = 0

  readonly #modelInfos: Record<string, ModelInfo>
  readonly #cacheOn: boolean
  readonly #maxMessages: number
  readonly #maxCost: number

  constructor(
    modelInfos: Record<string, Record<string, Partial<ModelInfo>>> = {},
    opts: { cacheEnabledDefault?: boolean; maxMessages?: number; maxCost?: number } = {},
  ) {
    const infos: Record<string, ModelInfo> = {}
    for (const [provider, providerInfo] of Object.entries(modelInfos)) {
      for (const [model, modelInfo] of Object.entries(providerInfo)) {
        infos[`${provider}:${model}`] = {
          inputPrice: modelInfo.inputPrice ?? 0,
          outputPrice: modelInfo.outputPrice ?? 0,
          cacheWritesPrice: modelInfo.cacheWritesPrice ?? 0,
          cacheReadsPrice: modelInfo.cacheReadsPrice ?? 0,
        }
      }
    }

    this.#modelInfos = infos
    this.#cacheOn = opts.cacheEnabledDefault ?? false
    this.#maxMessages = opts.maxMessages ?? 1000
    this.#maxCost = opts.maxCost ?? 100
  }

  addUsage(
    llm: LanguageModelV2,
    resp: { usage: LanguageModelV2Usage; providerMetadata?: any } | { totalUsage: LanguageModelV2Usage; providerMetadata?: any },
    callOpts: { modelInfo?: ModelInfo; cacheEnabled?: boolean } = {},
  ) {
    const m = callOpts.modelInfo ??
      this.#modelInfos[`${llm.provider}-${llm.modelId}`] ?? {
        inputPrice: 0,
        outputPrice: 0,
        cacheWritesPrice: 0,
        cacheReadsPrice: 0,
      }

    const usage = 'usage' in resp ? resp.usage : resp.totalUsage
    const openrouterCost = resp.providerMetadata?.openrouter?.usage?.cost ?? 0

    const cache = callOpts.cacheEnabled ?? this.#cacheOn
    const input = usage.inputTokens ?? 0
    const cached = cache ? (usage.cachedInputTokens ?? 0) : 0
    const uncached = Math.max(0, input - cached)
    const outs = (usage.outputTokens ?? 0) + (usage.reasoningTokens ?? 0)

    const cost = openrouterCost ?? costFor(m, uncached, cached, outs, cache)

    // accumulate
    this.#totals.input += input
    this.#totals.cached += cached
    this.#totals.output += usage.outputTokens ?? 0
    this.#totals.reasoning += usage.reasoningTokens ?? 0
    this.#totals.cost += cost
    this.#calls++
  }

  /** Override the running totals (e.g., restore from saved state). */
  setUsage(newUsage: Partial<Totals & { calls: number }>) {
    if (newUsage.input != null) this.#totals.input = newUsage.input
    if (newUsage.output != null) this.#totals.output = newUsage.output
    if (newUsage.reasoning != null) this.#totals.reasoning = newUsage.reasoning
    if (newUsage.cached != null) this.#totals.cached = newUsage.cached
    if (newUsage.cost != null) this.#totals.cost = newUsage.cost
    if (newUsage.calls != null) this.#calls = newUsage.calls
  }

  /** Manually bump the message count (useful if you record some calls without token info). */
  incrementMessageCount(n = 1) {
    this.#calls += n
  }

  /** Return true once either messages or cost exceed the configured caps. */
  isLimitExceeded() {
    const messageCount = this.#maxMessages !== undefined && this.#calls >= this.#maxMessages
    const cost = this.#maxCost !== undefined && this.#totals.cost >= this.#maxCost

    return {
      messageCount,
      maxMessages: this.#maxMessages,
      cost,
      maxCost: this.#maxCost,
      result: messageCount || cost,
    }
  }

  /** Same as isLimitExceeded but throws an error if a limit is hit. */
  checkLimit() {
    const result = this.isLimitExceeded()
    if (result.result) {
      throw new Error(
        `Usage limit exceeded. Message count: ${result.messageCount}/${result.maxMessages}, cost: ${result.cost}/${result.maxCost}`,
      )
    }
  }

  /** Getter for the aggregated totals (immutable copy). */
  get usage() {
    return { ...this.#totals, messageCount: this.#calls }
  }

  /** Print a concise usage summary to console. */
  printUsage() {
    const u = this.usage
    console.log(
      `Usage â€” messages: ${u.messageCount}, input: ${u.input}, cached: ${u.cached}, ` +
        `output: ${u.output}, reasoning: ${u.reasoning}, cost: $${u.cost.toFixed(4)}`,
    )
  }

  onFinishHandler(llm: LanguageModelV2) {
    return (evt: { totalUsage: LanguageModelV2Usage; providerMetadata: any }) => {
      this.addUsage(llm, evt)
    }
  }
}
