// Generated by polka.codes

/**
 * Deep merge utility with EXPLICIT path specification
 *
 * This utility performs a shallow merge by default, with deep merging
 * ONLY for paths explicitly specified. This prevents accidental deep
 * merging of unexpected properties.
 *
 * @example
 * ```typescript
 * const config = { a: 1, b: { x: 1, y: 2 }, c: { z: 3 } }
 * const override = { a: 2, b: { x: 10 }, c: 'not-an-object' }
 *
 * // Deep merge only 'b', shallow merge everything else
 * const result = deepMerge(config, override, ['b'])
 * // Result: { a: 2, b: { x: 10, y: 2 }, c: 'not-an-object' }
 *
 * // Note: 'c' was NOT deep merged because it's not in deepPaths
 * // Note: 'b.x' was updated while 'b.y' was preserved (deep merge)
 * ```
 *
 * @param base - The base object to merge into
 * @param override - The object with values to override
 * @param deepPaths - Array of keys that should be deep merged (must be plain objects)
 * @returns A new object with merged values
 */
export function deepMerge<T extends object>(base: T, override: Partial<T>, deepPaths: Array<keyof T>): T {
  const result = { ...base, ...override }

  // Explicit deep merge - only merge paths specified in deepPaths
  for (const path of deepPaths) {
    const baseValue = base[path]
    const overrideValue = override[path]

    // Only merge plain objects (not arrays, dates, null, etc.)
    if (
      typeof baseValue === 'object' &&
      baseValue !== null &&
      !Array.isArray(baseValue) &&
      typeof overrideValue === 'object' &&
      overrideValue !== null &&
      !Array.isArray(overrideValue)
    ) {
      result[path] = { ...baseValue, ...overrideValue } as T[Extract<keyof T, string>]
    }
  }

  return result
}
