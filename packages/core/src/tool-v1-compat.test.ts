// generated by polka.codes
import { describe, expect, it } from 'bun:test'
import { z } from 'zod'
import type { FullToolInfoV2 } from './tool'
import { ToolResponseType } from './tool'
import { toToolInfoV1 } from './tool-v1-compat'
import { askFollowupQuestion } from './tools'

describe('toToolInfoV1', () => {
  it('should convert a simple V2 tool to V1', () => {
    const toolV2: FullToolInfoV2 = {
      name: 'test-tool',
      description: 'A test tool',
      isAvailable: () => true,
      handler: async () => ({ type: ToolResponseType.Exit, message: 'test' }),
      parameters: z.object({
        param1: z.string().describe('Parameter 1'),
        param2: z.number().optional().describe('Parameter 2'),
      }),
    }

    const toolV1 = toToolInfoV1(toolV2)

    expect(toolV1.name).toBe('test-tool')
    expect(toolV1.description).toBe('A test tool')
    expect(toolV1.parameters).toMatchSnapshot()
  })

  it('should handle nested objects', () => {
    const toolV2: FullToolInfoV2 = {
      name: 'nested-tool',
      description: 'A tool with nested objects',
      isAvailable: () => true,
      handler: async () => ({ type: ToolResponseType.Exit, message: 'test' }),
      parameters: z.object({
        level1: z.object({
          level2: z.string().describe('Level 2 parameter'),
        }),
      }),
    }

    const toolV1 = toToolInfoV1(toolV2)

    expect(toolV1.parameters).toMatchSnapshot()
  })

  it('should handle arrays of strings', () => {
    const toolV2: FullToolInfoV2 = {
      name: 'array-tool',
      description: 'A tool with an array of strings',
      isAvailable: () => true,
      handler: async () => ({ type: ToolResponseType.Exit, message: 'test' }),
      parameters: z.object({
        items: z.array(z.string()).describe('List of items'),
      }),
    }

    const toolV1 = toToolInfoV1(toolV2)

    expect(toolV1.parameters).toMatchSnapshot()
  })

  it('should handle arrays of objects', () => {
    const toolV2: FullToolInfoV2 = {
      name: 'array-of-objects-tool',
      description: 'A tool with an array of objects',
      isAvailable: () => true,
      handler: async () => ({ type: ToolResponseType.Exit, message: 'test' }),
      parameters: z.object({
        objects: z
          .array(
            z.object({
              prop1: z.string().describe('Property 1'),
              prop2: z.boolean().describe('Property 2'),
            }),
          )
          .describe('List of objects'),
      }),
    }

    const toolV1 = toToolInfoV1(toolV2)

    expect(toolV1.parameters).toMatchSnapshot()
  })

  it('should match snapshot for a complex tool', () => {
    const toolV2: FullToolInfoV2 = {
      name: 'complex-tool',
      description: 'A complex tool for snapshot testing',
      isAvailable: () => true,
      handler: async () => ({ type: ToolResponseType.Exit, message: 'test' }),
      parameters: z.object({
        requiredString: z.string().describe('A required string'),
        optionalNumber: z.number().optional().describe('An optional number'),
        objectParam: z.object({
          nestedString: z.string().describe('A nested string'),
          nestedOptional: z.boolean().optional().describe('A nested optional boolean'),
        }),
        arrayString: z.array(z.string()).describe('An array of strings'),
        arrayObject: z
          .array(
            z.object({
              objProp: z.string().describe('An object property'),
            }),
          )
          .describe('An array of objects'),
      }),
    }

    const toolV1 = toToolInfoV1(toolV2)
    expect(toolV1).toMatchSnapshot()
  })

  it('should correctly convert a tool with nested optional arrays', () => {
    const toolV2: FullToolInfoV2 = askFollowupQuestion

    const toolV1 = toToolInfoV1(toolV2)

    expect(toolV1.parameters).toMatchSnapshot()
  })
})
