// generated by polka.codes
import type { Anthropic } from '@anthropic-ai/sdk'
import type { ApiStreamChunk, UserContent } from '../AiService'
import type { ApiStreamToolCallChunk } from '../AiService/AiServiceBase'
import type { FullToolInfo, ToolParameter } from '../tool'
import type { AssistantMessageContent, ToolUse } from './parseAssistantMessage'

/**
 * Process a tool call chunk from the API into a ToolUse object
 */
export function processToolCallChunk(chunk: ApiStreamToolCallChunk): ToolUse {
  return {
    type: 'tool_use',
    name: chunk.name,
    params: chunk.input,
  }
}

/**
 * Type guard to check if a chunk is a tool call chunk
 */
export function isToolCallChunk(chunk: any): chunk is ApiStreamToolCallChunk {
  return chunk.type === 'tool_call'
}

/**
 * Process a stream chunk and update the message state
 */
export function processStreamChunk(
  chunk: ApiStreamChunk,
  currentMessage: string,
  callback: (kind: 'Usage' | 'Text' | 'Reasoning', text?: string) => Promise<void>,
): string {
  let updatedMessage = currentMessage

  switch (chunk.type) {
    case 'usage':
      callback('Usage').catch(console.error)
      break
    case 'text':
      updatedMessage += chunk.text
      callback('Text', chunk.text).catch(console.error)
      break
    case 'reasoning':
      callback('Reasoning', chunk.text).catch(console.error)
      break
  }

  return updatedMessage
}

/**
 * Process a tool call chunk and update tool calls
 */
export function processToolCallAndUpdateMessage(
  chunk: ApiStreamToolCallChunk,
  toolCalls: ToolUse[],
  currentMessage: string,
  toolNamePrefix: string,
): string {
  const toolUse = processToolCallChunk(chunk)
  toolCalls.push(toolUse)

  // Update the message text to include the tool call
  let updatedMessage = currentMessage
  updatedMessage += `\n<${toolNamePrefix}${toolUse.name}>\n`

  // Add parameters
  for (const [key, value] of Object.entries(toolUse.params)) {
    updatedMessage += `<${toolNamePrefix}parameter_${key}>${value}</${toolNamePrefix}parameter_${key}>\n`
  }

  updatedMessage += `</${toolNamePrefix}${toolUse.name}>\n`

  return updatedMessage
}

/**
 * Handle the result of processing the assistant message
 */
export function handleAssistantMessageResult(
  currentMessage: string,
  toolCalls: ToolUse[],
  useNativeToolFormat: boolean,
  tools: FullToolInfo[],
  toolNamePrefix: string,
): AssistantMessageContent[] {
  if (useNativeToolFormat && toolCalls.length > 0) {
    // If using native format and received tool calls, use those directly
    let result: AssistantMessageContent[] = []

    if (currentMessage) {
      result.push({ type: 'text', content: currentMessage })
    }

    // Add tool calls
    result = result.concat(toolCalls)

    return result
  }
  // Otherwise parse the message text using the polka-codes format
  const { parseAssistantMessage } = require('./parseAssistantMessage')
  return parseAssistantMessage(currentMessage, tools, toolNamePrefix)
}

function paramToJsonSchema(param: ToolParameter): any {
  let schema: any

  if (param.children?.length) {
    const properties = param.children.reduce(
      (acc, child) => {
        acc[child.name] = paramToJsonSchema(child)
        return acc
      },
      {} as Record<string, any>,
    )

    const required = param.children.filter((p) => p.required).map((p) => p.name)

    schema = {
      type: 'object',
      properties,
    }
    if (required.length > 0) {
      schema.required = required
    }
  } else {
    schema = {
      type: 'string', // Assuming string for primitive types
      description: param.description,
    }
  }

  if (param.allowMultiple) {
    return {
      type: 'array',
      items: schema,
      description: param.description,
    }
  }

  schema.description = param.description
  return schema
}

export function toolToAnthropicTool(tool: FullToolInfo): Anthropic.Tool {
  const properties = tool.parameters.reduce(
    (acc, p) => {
      acc[p.name] = paramToJsonSchema(p)
      return acc
    },
    {} as Record<string, any>,
  )

  const required = tool.parameters.filter((p) => p.required).map((p) => p.name)

  return {
    name: tool.name,
    description: tool.description,
    input_schema: {
      type: 'object',
      properties,
      ...(required.length > 0 && { required }),
    },
  }
}

export function userContentToString(content: UserContent): string {
  if (typeof content === 'string') {
    return content
  }
  return content
    .map((item) => {
      if ('text' in item) {
        return item.text
      }
      return ''
    })
    .join('')
}
