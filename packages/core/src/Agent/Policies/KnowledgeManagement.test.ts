/**
 * Tests for KnowledgeManagement policy
 * Generated by polka.codes
 */

import { describe, expect, test } from 'bun:test'
import { Policies } from '../../config'
import { readFile, writeToFile } from '../../tools'
import { KnowledgeManagementPolicy } from './KnowledgeManagement'

describe('KnowledgeManagementPolicy', () => {
  test('returns undefined when readFile tool is not available', () => {
    const tools = {}
    const policy = KnowledgeManagementPolicy(tools)
    expect(policy).toBeUndefined()
  })

  describe('with readFile tool', () => {
    const tools = {
      [readFile.name]: readFile,
    }

    test('when writeToFile tool is not available', () => {
      const policy = KnowledgeManagementPolicy(tools)
      expect(policy?.name).toBe(Policies.KnowledgeManagement)
      expect(policy?.prompt).toBeUndefined()
    })

    test('includes prompt when writeToFile tool is available', () => {
      const policy = KnowledgeManagementPolicy({
        ...tools,
        [writeToFile.name]: writeToFile,
      })
      expect(policy?.prompt).toBeDefined()
      expect(policy?.prompt).toMatchSnapshot()
    })

    describe('getKnowledgeFilePaths', () => {
      test('returns correct paths for single file', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const paths = await policy.getKnowledgeFilePaths(['src/foo/bar.ts'])
        expect(paths).toEqual(['src/foo/knowledge.ai.yml', 'src/knowledge.ai.yml'])
      })

      test('returns correct paths for multiple files', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const paths = await policy.getKnowledgeFilePaths(['src/foo/bar.ts', 'src/baz/qux.ts'])
        expect(paths).toEqual(['src/foo/knowledge.ai.yml', 'src/knowledge.ai.yml', 'src/baz/knowledge.ai.yml'])
      })

      test('ignores root directory', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const paths = await policy.getKnowledgeFilePaths(['foo.ts'])
        expect(paths).toEqual([])
      })
    })

    describe('updateResponse', () => {
      test('adds readFile for knowledge files when readFile tool is used', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const response = await policy.updateResponse([
          {
            type: 'tool_use',
            name: 'read_file',
            params: { path: 'src/foo/bar.ts' },
          },
        ])
        expect(response).toMatchSnapshot()
      })

      test('adds readFile for knowledge files when listFiles tool is used', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const response = await policy.updateResponse([
          {
            type: 'tool_use',
            name: 'list_files',
            params: { path: 'src/foo' },
          },
        ])
        expect(response).toMatchSnapshot()
      })

      test('does not add readFile for other tool uses', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const response = await policy.updateResponse([
          {
            type: 'tool_use',
            name: 'write_to_file',
            params: { path: 'src/foo/bar.ts', content: 'test' },
          },
        ])
        expect(response).toMatchSnapshot()
      })

      test('combines paths from multiple tool uses', async () => {
        const policy = KnowledgeManagementPolicy(tools)!
        const response = await policy.updateResponse([
          {
            type: 'tool_use',
            name: 'read_file',
            params: { path: 'src/foo/bar.ts' },
          },
          {
            type: 'tool_use',
            name: 'list_files',
            params: { path: 'src/baz' },
          },
        ])
        expect(response).toMatchSnapshot()
      })
    })
  })
})
