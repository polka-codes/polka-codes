// TruncateContext policy - generated by polka.codes
// Truncates conversation messages when context size becomes too large to prevent token limit overflows

import type { MessageParam } from '../../AiService'
import { Policies } from '../../config'
import type { AgentBase, AgentPolicy } from '../AgentBase'

// Default max token threshold
const DEFAULT_MAX_TOKENS_ESTIMATE = 8000

// Get max tokens from parameters with fallback to thinkingBudgetTokens or default
function getMaxTokens(agent: AgentBase): number {
  const params = agent.parameters || {}

  // First try to get maxTokens parameter if it exists
  if (params.maxTokens && typeof params.maxTokens === 'number' && params.maxTokens > 0) {
    return params.maxTokens
  }

  // Final fallback to default
  return DEFAULT_MAX_TOKENS_ESTIMATE
}

// Simple token estimation (1 token â‰ˆ 4 characters)
function estimateTokens(text: string): number {
  return Math.ceil(text.length / 4)
}

export const TruncateContextPolicy = (tools: Parameters<AgentPolicy>[0]) => {
  return {
    name: Policies.TruncateContext,
    async onBeforeRequest(agent: AgentBase): Promise<void> {
      const messages = agent.messages

      // Skip if there aren't enough messages to truncate
      if (messages.length < 3) {
        return
      }

      // Calculate total token estimate
      let totalTokens = 0
      for (const msg of messages) {
        if (typeof msg.content === 'string') {
          totalTokens += estimateTokens(msg.content)
        } else if (Array.isArray(msg.content)) {
          // Handle content blocks
          for (const block of msg.content) {
            if (typeof block === 'object' && 'text' in block && typeof block.text === 'string') {
              totalTokens += estimateTokens(block.text)
            }
          }
        }
      }

      // Get the max tokens threshold from parameters
      const maxTokens = getMaxTokens(agent)

      // If under threshold, no truncation needed
      if (totalTokens <= maxTokens) {
        return
      }

      // Truncation strategy: remove half of messages from the middle
      // Calculate how many messages to keep (half of total)
      const totalMessages = messages.length
      const messagesToKeep = Math.ceil(totalMessages / 2)

      // Ensure we keep at least 2 messages and preserve message pairs
      const minKeep = Math.max(2, messagesToKeep)

      if (minKeep >= totalMessages) {
        // If we would keep all messages anyway, no truncation needed
        return
      }

      // Calculate how many to keep from start and end
      const keepFromStart = Math.floor(minKeep / 2)
      const keepFromEnd = minKeep - keepFromStart

      // Get messages from start and end
      const startMessages = messages.slice(0, keepFromStart)
      const endMessages = messages.slice(-keepFromEnd)

      // Count how many messages were truncated
      const truncatedCount = totalMessages - minKeep

      // Rebuild the truncated message list
      const truncatedMessages: MessageParam[] = [
        ...startMessages,
        // Add a message explaining truncation
        {
          role: 'user' as const,
          content: `Note: ${truncatedCount} messages were truncated from the middle to prevent context overflow.`,
        },
        ...endMessages,
      ]

      // Update the agent's messages
      agent.setMessages(truncatedMessages)
    },
  }
}
