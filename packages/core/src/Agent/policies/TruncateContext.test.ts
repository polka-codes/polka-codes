// TruncateContext policy tests - generated by polka.codes

import { expect, spyOn, test } from 'bun:test'

import type { ModelMessage } from 'ai'
import { TruncateContextPolicy } from './TruncateContext'

test('TruncateContextPolicy should truncate messages when over threshold', async () => {
  // Create mock agent
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1'.repeat(500) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(500) },
      { role: 'user', content: 'User message 2' },
      { role: 'assistant', content: 'Assistant message 2' },
      { role: 'user', content: 'User message 3' },
      { role: 'assistant', content: 'Assistant message 3' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: {},
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should not truncate small message lists', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'Short user message' },
      { role: 'assistant', content: 'Short assistant message' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: {},
  }

  const setMessagesSpy = spyOn(mockAgent, 'setMessages')
  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(setMessagesSpy).not.toHaveBeenCalled()
  expect(mockAgent.messages.length).toBe(2)
})

test('TruncateContextPolicy should preserve messages from start and end', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'Old user message 1'.repeat(300) },
      { role: 'assistant', content: 'Old assistant message 1'.repeat(300) },
      { role: 'user', content: 'Old user message 2'.repeat(300) },
      { role: 'assistant', content: 'Old assistant message 2'.repeat(300) },
      { role: 'user', content: 'Middle user message 1'.repeat(300) },
      { role: 'assistant', content: 'Middle assistant message 1'.repeat(300) },
      { role: 'user', content: 'Middle user message 2'.repeat(300) },
      { role: 'assistant', content: 'Middle assistant message 2'.repeat(300) },
      { role: 'user', content: 'Recent user message' },
      { role: 'assistant', content: 'Recent assistant message' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: {},
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should use maxTokens parameter when provided', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1'.repeat(100) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(100) },
      { role: 'user', content: 'User message 2' },
      { role: 'assistant', content: 'Assistant message 2' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: { maxTokens: 500 }, // Low threshold to trigger truncation
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should use thinkingBudgetTokens as fallback', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1'.repeat(100) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(100) },
      { role: 'user', content: 'User message 2' },
      { role: 'assistant', content: 'Assistant message 2' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: { thinkingBudgetTokens: 600 }, // Low threshold to trigger truncation
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should prefer maxTokens over thinkingBudgetTokens', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1'.repeat(100) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(100) },
      { role: 'user', content: 'User message 2' },
      { role: 'assistant', content: 'Assistant message 2' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: {
      maxTokens: 500, // Should use this
      thinkingBudgetTokens: 2000, // Should ignore this
    },
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should truncate exactly half of messages', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'Message 1'.repeat(200) },
      { role: 'assistant', content: 'Response 1'.repeat(200) },
      { role: 'user', content: 'Message 2'.repeat(200) },
      { role: 'assistant', content: 'Response 2'.repeat(200) },
      { role: 'user', content: 'Message 3'.repeat(200) },
      { role: 'assistant', content: 'Response 3'.repeat(200) },
      { role: 'user', content: 'Message 4'.repeat(200) },
      { role: 'assistant', content: 'Response 4'.repeat(200) },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: { maxTokens: 1000 },
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  // Should keep 4 messages (half of 8) plus 1 truncation notice = 5 total
  expect(mockAgent.messages.length).toBe(5)
  expect(mockAgent.messages).toMatchSnapshot()
})
