// TruncateContext.test.ts - generated by polka.codes
import { describe, expect, it } from 'bun:test'
import type { AgentBase, MessageParam } from '../AgentBase'
import { TruncateContextPolicy } from './TruncateContext'

describe('TruncateContextPolicy', () => {
  it('should return original messages if count is small', async () => {
    const policy = TruncateContextPolicy({})
    if (!policy || !policy.onBeforeRequest) {
      throw new Error('Policy or onBeforeRequest hook not defined')
    }

    const messages: MessageParam[] = [
      { role: 'user', content: 'Hello' },
      { role: 'assistant', content: 'Hi there' },
      { role: 'user', content: 'How are you?' },
    ]

    const mockAgent = {} as AgentBase

    const result = await policy.onBeforeRequest(mockAgent, messages)
    expect(result).toEqual(messages)
    expect(result.length).toBe(3)
  })

  it('should truncate messages when they exceed the token limit', async () => {
    const policy = TruncateContextPolicy({})
    if (!policy || !policy.onBeforeRequest) {
      throw new Error('Policy or onBeforeRequest hook not defined')
    }

    // Create a large number of messages with long content to exceed the token limit
    const longContent = 'a'.repeat(5000) // This should be around 1250 tokens
    const messages: MessageParam[] = []

    // Add 10 messages (should exceed token limit)
    for (let i = 0; i < 10; i++) {
      messages.push({ role: i % 2 === 0 ? 'user' : 'assistant', content: `${i}: ${longContent}` })
    }

    const mockAgent = {} as AgentBase

    const result = await policy.onBeforeRequest(mockAgent, messages)

    // Should have truncated to preserve only the last few messages plus the truncation message
    expect(result.length).toBeLessThan(messages.length)

    // First message should be the truncation system message
    expect(result[0].role).toBe('system')
    expect(typeof result[0].content).toBe('string')
    expect(result[0].content).toContain('removed')

    // The rest should be the most recent messages
    for (let i = 1; i < result.length; i++) {
      const originalIndex = messages.length - result.length + i
      expect(result[i]).toEqual(messages[originalIndex])
    }
  })
})
