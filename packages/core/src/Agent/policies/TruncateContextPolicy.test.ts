// TruncateContext policy tests - generated by polka.codes

import { expect, spyOn, test } from 'bun:test'

import type { ModelMessage } from 'ai'
import { TruncateContextPolicy } from './TruncateContextPolicy'

test('TruncateContextPolicy should truncate messages when over threshold', async () => {
  // Create mock agent
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1'.repeat(500) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(500) },
      { role: 'user', content: 'User message 2' },
      { role: 'assistant', content: 'Assistant message 2' },
      { role: 'user', content: 'User message 3' },
      { role: 'assistant', content: 'Assistant message 3' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: {},
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should not truncate small message lists', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'Short user message' },
      { role: 'assistant', content: 'Short assistant message' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: {},
  }

  const setMessagesSpy = spyOn(mockAgent, 'setMessages')
  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(setMessagesSpy).not.toHaveBeenCalled()
  expect(mockAgent.messages.length).toBe(2)
})

test('TruncateContextPolicy should use maxTokens parameter when provided', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1'.repeat(100) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(100) },
      { role: 'user', content: 'User message 2' },
      { role: 'assistant', content: 'Assistant message 2' },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: { maxTokens: 500 }, // Low threshold to trigger truncation
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should not truncate system messages', async () => {
  const mockAgent = {
    messages: [
      { role: 'system', content: 'You are a helpful assistant.'.repeat(1000) },
      { role: 'user', content: 'User message 1'.repeat(500) },
      { role: 'assistant', content: 'Assistant message 1'.repeat(500) },
      { role: 'user', content: 'User message 2'.repeat(500) },
      { role: 'assistant', content: 'Assistant message 2'.repeat(500) },
      { role: 'user', content: 'User message 3'.repeat(500) },
      { role: 'assistant', content: 'Assistant message 3'.repeat(500) },
    ] as ModelMessage[],
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: { maxTokens: 4000 },
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages.some((m) => m.role === 'system')).toBe(true)
  expect(mockAgent.messages).toMatchSnapshot()
})

test('TruncateContextPolicy should preserve the first two user messages', async () => {
  const mockAgent = {
    messages: [
      { role: 'user', content: 'User message 1 (protected)'.repeat(800) }, // ~800 tokens
      { role: 'assistant', content: 'Assistant message 1 (truncatable)'.repeat(800) }, // ~800 tokens
      { role: 'user', content: 'User message 2 (protected)'.repeat(800) }, // ~800 tokens
      { role: 'assistant', content: 'Assistant message 2 (truncatable)'.repeat(800) }, // ~800 tokens
      { role: 'user', content: 'User message 3 (truncatable)'.repeat(800) }, // ~800 tokens
      { role: 'assistant', content: 'Assistant message 3 (truncatable)'.repeat(800) }, // ~800 tokens
      { role: 'user', content: 'User message 4 (last message, protected)' }, // small
    ] as ModelMessage[], // total ~4800 tokens
    setMessages: (messages: ModelMessage[]) => {
      mockAgent.messages = messages
    },
    parameters: { maxTokens: 3000 },
  }

  const policy = TruncateContextPolicy()
  await policy.onBeforeRequest(mockAgent as any)

  expect(mockAgent.messages.find((m) => typeof m.content === 'string' && m.content.includes('User message 1 (protected)'))).toBeDefined()
  expect(mockAgent.messages.find((m) => typeof m.content === 'string' && m.content.includes('User message 2 (protected)'))).toBeDefined()
  expect(
    mockAgent.messages.find((m) => typeof m.content === 'string' && m.content.includes('User message 4 (last message, protected)')),
  ).toBeDefined()
  expect(mockAgent.messages).toMatchSnapshot()
})
