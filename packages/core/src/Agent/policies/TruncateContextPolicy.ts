// TruncateContext policy - generated by polka.codes
// Truncates conversation messages when context size becomes too large to prevent token limit overflows

import type { ModelMessage } from 'ai'
import { Policies } from '../../config'
import type { AgentBase } from '../AgentBase'
import type { AgentPolicy } from '../AgentPolicy'

// Default max token threshold
const DEFAULT_MAX_TOKENS_ESTIMATE = 32000

// Get max tokens from parameters with fallback to thinkingBudgetTokens or default
function getMaxTokens(agent: AgentBase): number {
  const params = agent.parameters || {}

  // First try to get maxTokens parameter if it exists
  if (params.maxTokens && typeof params.maxTokens === 'number' && params.maxTokens > 0) {
    return params.maxTokens
  }

  // Final fallback to default
  return DEFAULT_MAX_TOKENS_ESTIMATE
}

// Simple token estimation (1 token â‰ˆ 4 characters)
function estimateTokens(text: string): number {
  return Math.ceil(text.length / 4)
}

function estimateMessageTokens(msg: ModelMessage): number {
  if (typeof msg.content === 'string') {
    return estimateTokens(msg.content)
  }
  if (Array.isArray(msg.content)) {
    let messageTokens = 0
    for (const block of msg.content) {
      if (typeof block === 'object' && 'text' in block && typeof block.text === 'string') {
        messageTokens += estimateTokens(block.text)
      }
    }
    return messageTokens
  }
  return 0
}

export const TruncateContextPolicy = (() => {
  return {
    name: Policies.TruncateContext,
    async onBeforeRequest(agent: AgentBase): Promise<void> {
      const messages = agent.messages

      // Skip if there aren't enough messages to truncate
      if (messages.length < 3) {
        return
      }

      // Calculate total token estimate
      let totalTokens = messages.reduce((acc, msg) => acc + estimateMessageTokens(msg), 0)

      // Get the max tokens threshold from parameters
      const maxTokens = getMaxTokens(agent)

      // If under threshold, no truncation needed
      if (totalTokens <= maxTokens) {
        return
      }

      // Identify protected indices
      const protectedIndices = new Set<number>()
      let userMessagesFound = 0
      messages.forEach((msg, index) => {
        if (msg.role === 'system') {
          protectedIndices.add(index)
        }
        if (msg.role === 'user') {
          if (userMessagesFound < 2) {
            protectedIndices.add(index)
          }
          userMessagesFound++
        }
      })
      // Always protect the last message
      if (messages.length > 0) {
        protectedIndices.add(messages.length - 1)
      }

      const truncatableIndices: number[] = []
      for (let i = 0; i < messages.length; i++) {
        if (!protectedIndices.has(i)) {
          truncatableIndices.push(i)
        }
      }

      const removedIndices = new Set<number>()
      const initialTotalTokens = totalTokens

      while (totalTokens > maxTokens && truncatableIndices.length > 0) {
        // Remove from the middle of the truncatable messages
        const middleIndex = Math.floor(truncatableIndices.length / 2)
        const indexToRemove = truncatableIndices.splice(middleIndex, 1)[0]

        removedIndices.add(indexToRemove)
        totalTokens -= estimateMessageTokens(messages[indexToRemove])
      }

      if (removedIndices.size === 0) {
        // Nothing was truncated, maybe all are protected.
        // This can happen if protected messages alone exceed the token limit.
        // We probably should log this.
        if (initialTotalTokens > maxTokens) {
          console.warn('Warning: Protected messages exceed token limit. Cannot truncate further.')
        }
        return
      }

      const truncatedMessages: ModelMessage[] = []
      let truncationNoticeAdded = false
      for (let i = 0; i < messages.length; i++) {
        if (removedIndices.has(i)) {
          if (!truncationNoticeAdded) {
            truncatedMessages.push({
              role: 'user',
              content: `Note: ${removedIndices.size} messages were truncated from the conversation to prevent context overflow.`,
            })
            truncationNoticeAdded = true
          }
        } else {
          truncatedMessages.push(messages[i])
        }
      }

      console.log(`Truncated context: removed ${removedIndices.size} messages.`)

      // Update the agent's messages
      agent.setMessages(truncatedMessages)
    },
  }
}) satisfies AgentPolicy
