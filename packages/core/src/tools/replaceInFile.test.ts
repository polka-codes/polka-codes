// generated by polka.codes
import { describe, expect, type Mock, mock, spyOn, test } from 'bun:test'
import type { ToolHandler } from '../tool'
import type { FilesystemProvider } from './provider'
import { handler } from './replaceInFile'
import * as replaceInFileModule from './utils/replaceInFile'

describe('replaceInFile tool', () => {
  const mockProvider: FilesystemProvider = {
    readFile: mock((_path: string): Promise<string | undefined> => Promise.resolve('')),
    writeFile: mock((_path: string, _content: string): Promise<void> => Promise.resolve()),
  }

  test('handler should return error if provider is missing methods', async () => {
    const incompleteProvider = { writeFile: mock(() => Promise.resolve()) }
    const result = await (handler as ToolHandler<any, any>)(incompleteProvider, {})
    expect(result).toEqual({
      success: false,
      message: {
        type: 'error-text',
        value: 'Not possible to replace in file.',
      },
    })
  })

  test('handler should return file not found error', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce(undefined)
    const args = { path: 'nonexistent.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result.success).toBe(false)
    if (result.success === false) {
      expect(result.message).toMatchSnapshot()
    }
  })

  test('handler should return no_diff_applied message', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce('file content')
    spyOn(replaceInFileModule, 'replaceInFile').mockReturnValueOnce({
      status: 'no_diff_applied',
      appliedCount: 0,
      totalCount: 2,
      content: 'file content',
    })
    const args = { path: 'test.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result).toMatchSnapshot()
  })

  test('handler should return some_diff_applied message', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce('file content')
    spyOn(replaceInFileModule, 'replaceInFile').mockReturnValueOnce({
      status: 'some_diff_applied',
      appliedCount: 1,
      totalCount: 2,
      content: 'new content',
    })
    const args = { path: 'test.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result.success).toBe(true)
    if (result.success === true) {
      expect(result.message).toMatchSnapshot()
    }
    expect(mockProvider.writeFile).toHaveBeenCalledWith('test.txt', 'new content')
  })

  test('handler should return all_diff_applied message', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce('file content')
    spyOn(replaceInFileModule, 'replaceInFile').mockReturnValueOnce({
      status: 'all_diff_applied',
      appliedCount: 2,
      totalCount: 2,
      content: 'new content',
    })
    const args = { path: 'test.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result.success).toBe(true)
    if (result.success === true) {
      expect(result.message).toMatchSnapshot()
    }
    expect(mockProvider.writeFile).toHaveBeenCalledWith('test.txt', 'new content')
  })
})
