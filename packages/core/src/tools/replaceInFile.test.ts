// generated by polka.codes
import { describe, expect, type Mock, mock, spyOn, test } from 'bun:test'
import { type ToolHandler, ToolResponseType } from '../tool'
import type { FilesystemProvider } from './provider'
import { handler, isAvailable } from './replaceInFile'
import * as replaceInFileModule from './utils/replaceInFile'

describe('replaceInFile tool', () => {
  const mockProvider: FilesystemProvider = {
    readFile: mock((_path: string): Promise<string | undefined> => Promise.resolve('')),
    writeFile: mock((_path: string, _content: string): Promise<void> => Promise.resolve()),
  }

  test('isAvailable should return true when provider has readFile and writeFile', () => {
    expect(isAvailable(mockProvider)).toBe(true)
  })

  test('isAvailable should return false when provider is missing readFile', () => {
    const incompleteProvider = { writeFile: mock(() => Promise.resolve()) }
    expect(isAvailable(incompleteProvider)).toBe(false)
  })

  test('isAvailable should return false when provider is missing writeFile', () => {
    const incompleteProvider = { readFile: mock(() => Promise.resolve('')) }
    expect(isAvailable(incompleteProvider)).toBe(false)
  })

  test('handler should return error if provider is missing methods', async () => {
    const incompleteProvider = { writeFile: mock(() => Promise.resolve()) }
    const result = await (handler as ToolHandler<any, any>)(incompleteProvider, {})
    expect(result).toEqual({
      type: ToolResponseType.Error,
      message: {
        type: 'error-text',
        value: 'Not possible to replace in file.',
      },
    })
  })

  test('handler should return file not found error', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce(undefined)
    const args = { path: 'nonexistent.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result.type).toBe(ToolResponseType.Error)
    if (result.type === ToolResponseType.Error) {
      expect(result.message).toMatchSnapshot()
    }
  })

  test('handler should return no_diff_applied message', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce('file content')
    spyOn(replaceInFileModule, 'replaceInFile').mockReturnValueOnce({
      status: 'no_diff_applied',
      appliedCount: 0,
      totalCount: 2,
      content: 'file content',
    })
    const args = { path: 'test.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result).toMatchSnapshot()
  })

  test('handler should return some_diff_applied message', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce('file content')
    spyOn(replaceInFileModule, 'replaceInFile').mockReturnValueOnce({
      status: 'some_diff_applied',
      appliedCount: 1,
      totalCount: 2,
      content: 'new content',
    })
    const args = { path: 'test.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result.type).toBe(ToolResponseType.Reply)
    if (result.type === ToolResponseType.Reply) {
      expect(result.message).toMatchSnapshot()
    }
    expect(mockProvider.writeFile).toHaveBeenCalledWith('test.txt', 'new content')
  })

  test('handler should return all_diff_applied message', async () => {
    ;(mockProvider.readFile as Mock<any>).mockResolvedValueOnce('file content')
    spyOn(replaceInFileModule, 'replaceInFile').mockReturnValueOnce({
      status: 'all_diff_applied',
      appliedCount: 2,
      totalCount: 2,
      content: 'new content',
    })
    const args = { path: 'test.txt', diff: '...' }
    const result = await (handler as ToolHandler<any, any>)(mockProvider, args)
    expect(result.type).toBe(ToolResponseType.Reply)
    if (result.type === ToolResponseType.Reply) {
      expect(result.message).toMatchSnapshot()
    }
    expect(mockProvider.writeFile).toHaveBeenCalledWith('test.txt', 'new content')
  })
})
