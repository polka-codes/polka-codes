// generated by polka.codes
import { z } from 'zod'
import { type FullToolInfoV2, PermissionLevel, type ToolHandler, type ToolInfoV2, ToolResponseType } from '../tool'
import type { FilesystemProvider } from './provider'
import { replaceInFile } from './utils/replaceInFile'

export const toolInfo = {
  name: 'replace_in_file',
  description:
    'Request to replace sections of content in an existing file using SEARCH/REPLACE blocks that define exact changes to specific parts of the file. This tool should be used when you need to make targeted changes to specific parts of a file.',
  parameters: z
    .object({
      path: z.string().describe('The path of the file to modify').meta({ usageValue: 'File path here' }),
      diff: z
        .string()
        .describe(
          `One or more SEARCH/REPLACE blocks following this exact format:
\`\`\`
<<<<<<< SEARCH
[exact content to find]
=======
[new content to replace with]
>>>>>>> REPLACE
\`\`\`
Critical rules:
1. SEARCH content must match the associated file section to find EXACTLY:
    * Match character-for-character including whitespace, indentation, line endings
    * Include all comments, docstrings, etc.
2. SEARCH/REPLACE blocks will ONLY replace the first match occurrence.
    * Including multiple unique SEARCH/REPLACE blocks if you need to make multiple changes.
    * Include *just* enough lines in each SEARCH section to uniquely match each set of lines that need to change.
    * When using multiple SEARCH/REPLACE blocks, list them in the order they appear in the file.
3. Keep SEARCH/REPLACE blocks concise:
    * Break large SEARCH/REPLACE blocks into a series of smaller blocks that each change a small portion of the file.
    * Include just the changing lines, and a few surrounding lines if needed for uniqueness.
    * Do not include long runs of unchanging lines in SEARCH/REPLACE blocks.
    * Each line must be complete. Never truncate lines mid-way through as this can cause matching failures.
4. Special operations:
    * To move code: Use two SEARCH/REPLACE blocks (one to delete from original + one to insert at new location)
    * To delete code: Use empty REPLACE section`,
        )
        .meta({ usageValue: 'Search and replace blocks here' }),
    })
    .meta({
      examples: [
        {
          description: 'Request to replace sections of content in a file',
          input: {
            path: 'src/main.js',
            diff: `<<<<<<< SEARCH
import React from 'react';
=======
import React, { useState } from 'react';
>>>>>>> REPLACE

<<<<<<< SEARCH
function handleSubmit() {
  saveData();
  setLoading(false);
}

=======
>>>>>>> REPLACE

<<<<<<< SEARCH
return (
  <div>
=======
function handleSubmit() {
  saveData();
  setLoading(false);
}

return (
  <div>
>>>>>>> REPLACE`,
          },
        },
        {
          description: 'Request to perform a simple, single-line replacement',
          input: {
            path: 'src/config.js',
            diff: `<<<<<<< SEARCH
const API_URL = 'https://api.example.com';
=======
const API_URL = 'https://api.staging.example.com';
>>>>>>> REPLACE`,
          },
        },
        {
          description: 'Request to add a new function to a file',
          input: {
            path: 'src/utils.js',
            diff: `<<<<<<< SEARCH
function helperA() {
  // ...
}
=======
function helperA() {
  // ...
}

function newHelper() {
  // implementation
}
>>>>>>> REPLACE`,
          },
        },
        {
          description: 'Request to delete a block of code from a file',
          input: {
            path: 'src/app.js',
            diff: `<<<<<<< SEARCH
function oldFeature() {
  // This is no longer needed
}

=======
>>>>>>> REPLACE`,
          },
        },
      ],
    }),
  permissionLevel: PermissionLevel.Write,
} as const satisfies ToolInfoV2

export const handler: ToolHandler<typeof toolInfo, FilesystemProvider> = async (provider, args) => {
  if (!provider.readFile || !provider.writeFile) {
    return {
      type: ToolResponseType.Error,
      message: 'Not possible to replace in file. Abort.',
    }
  }

  const parsed = toolInfo.parameters.safeParse(args)
  if (!parsed.success) {
    return {
      type: ToolResponseType.Invalid,
      message: `Invalid arguments for replace_in_file: ${parsed.error.message}`,
    }
  }
  const { path, diff } = parsed.data

  try {
    const fileContent = await provider.readFile(path, false)

    if (fileContent == null) {
      return {
        type: ToolResponseType.Error,
        message: `<replace_in_file_result path=\"${path}\" status=\"failed\" message=\"File not found\" />`,
      }
    }

    const result = replaceInFile(fileContent, diff)

    if (result.status === 'no_diff_applied') {
      return {
        type: ToolResponseType.Error,
        message: `<replace_in_file_result path=\"${path}\" status=\"failed\" message=\"Unable to apply changes\">
  <file_content path=\"${path}\">${fileContent}</file_content>
</replace_in_file_result>`,
      }
    }

    await provider.writeFile(path, result.content)

    if (result.status === 'some_diff_applied') {
      return {
        type: ToolResponseType.Reply,
        message: `<replace_in_file_result path=\"${path}\" status=\"some_diff_applied\" applied_count=\"${result.appliedCount}\" total_count=\"${result.totalCount}\">
  <file_content path=\"${path}\">${result.content}</file_content>
</replace_in_file_result>`,
      }
    }

    return {
      type: ToolResponseType.Reply,
      message: `<replace_in_file_result path=\"${path}\" status=\"all_diff_applied\" />`,
    }
  } catch (error) {
    return {
      type: ToolResponseType.Invalid,
      message: `Invalid arguments for replace_in_file: ${error}`,
    }
  }
}

export const isAvailable = (provider: FilesystemProvider): boolean => {
  return !!provider.readFile && !!provider.writeFile
}

export default {
  ...toolInfo,
  handler,
  isAvailable,
} satisfies FullToolInfoV2
