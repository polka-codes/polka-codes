// generated by polka.codes
import { z } from 'zod'
import type { FullToolInfo, ToolHandler, ToolInfo } from '../tool'
import type { FilesystemProvider } from './provider'
import { replaceInFile } from './utils/replaceInFile'

export const toolInfo = {
  name: 'replaceInFile',
  description: `Request to replace sections of content in an existing file using
SEARCH/REPLACE blocks.

When to use:
- Making targeted changes to specific parts of a file
- Replacing variable names, function signatures, imports
- Fixing bugs in existing code
- When you know the exact content to replace

When NOT to use:
- For creating new files: Use writeToFile instead
- For completely replacing file contents: Use writeToFile instead
- When you don't know the exact content: Read file first

SEARCH/REPLACE FORMAT:
<<<<<<< SEARCH
[exact content to find]
=======
[new content to replace with]
>>>>>>> REPLACE

Critical rules:
1. SEARCH content must match EXACTLY (character-for-character including whitespace)
2. Each block replaces only first occurrence
3. Include just enough lines for uniqueness (not too many, not too few)
4. Keep blocks concise (don't include long unchanged sections)
5. List blocks in order they appear in file
6. Use multiple blocks for multiple independent changes

Special operations:
- Move code: Two blocks (delete from original + insert at new location)
- Delete code: Empty REPLACE section

IMPORTANT CONSTRAINTS:
- SEARCH text must match file content exactly
- Each block is independent (doesn't affect other blocks)
- Cannot use for appending or inserting without SEARCH context`,
  parameters: z
    .object({
      path: z.string().describe('The path of the file to modify').meta({ usageValue: 'File path here' }),
      diff: z
        .string()
        .describe(
          `One or more SEARCH/REPLACE blocks following this exact format:
\`\`\`
<<<<<<< SEARCH
[exact content to find]
=======
[new content to replace with]
>>>>>>> REPLACE
\`\`\`
Critical rules:
1. SEARCH content must match the associated file section to find EXACTLY:
    * Match character-for-character including whitespace, indentation, line endings
    * Include all comments, docstrings, etc.
2. SEARCH/REPLACE blocks will ONLY replace the first match occurrence.
    * Including multiple unique SEARCH/REPLACE blocks if you need to make multiple changes.
    * Include *just* enough lines in each SEARCH section to uniquely match each set of lines that need to change.
    * When using multiple SEARCH/REPLACE blocks, list them in the order they appear in the file.
3. Keep SEARCH/REPLACE blocks concise:
    * Break large SEARCH/REPLACE blocks into a series of smaller blocks that each change a small portion of the file.
    * Include just the changing lines, and a few surrounding lines if needed for uniqueness.
    * Do not include long runs of unchanging lines in SEARCH/REPLACE blocks.
    * Each line must be complete. Never truncate lines mid-way through as this can cause matching failures.
4. Special operations:
    * To move code: Use two SEARCH/REPLACE blocks (one to delete from original + one to insert at new location)
    * To delete code: Empty REPLACE section`,
        )
        .meta({ usageValue: 'Search and replace blocks here' }),
    })
    .meta({
      examples: [
        {
          description: 'Request to replace sections of content in a file',
          input: {
            path: 'src/main.js',
            diff: `<<<<<<< SEARCH
import React from 'react';
=======
import React, { useState } from 'react';
>>>>>>> REPLACE

<<<<<<< SEARCH
function handleSubmit() {
  saveData();
  setLoading(false);
}

=======
>>>>>>> REPLACE

<<<<<<< SEARCH
return (
  <div>
=======
function handleSubmit() {
  saveData();
  setLoading(false);
}

return (
  <div>
>>>>>>> REPLACE`,
          },
        },
        {
          description: 'Request to perform a simple, single-line replacement',
          input: {
            path: 'src/config.js',
            diff: `<<<<<<< SEARCH
const API_URL = 'https://api.example.com';
=======
const API_URL = 'https://api.staging.example.com';
>>>>>>> REPLACE`,
          },
        },
        {
          description: 'Request to add a new function to a file',
          input: {
            path: 'src/utils.js',
            diff: `<<<<<<< SEARCH
function helperA() {
  // ...
}
=======
function helperA() {
  // ...
}

function newHelper() {
  // implementation
}
>>>>>>> REPLACE`,
          },
        },
        {
          description: 'Request to delete a block of code from a file',
          input: {
            path: 'src/app.js',
            diff: `<<<<<<< SEARCH
function oldFeature() {
  // This is no longer needed
}

=======
>>>>>>> REPLACE`,
          },
        },
      ],
    }),
} as const satisfies ToolInfo

export const handler: ToolHandler<typeof toolInfo, FilesystemProvider> = async (provider, args) => {
  if (!provider.readFile || !provider.writeFile) {
    return {
      success: false,
      message: {
        type: 'error-text',
        value: 'Not possible to replace in file.',
      },
    }
  }

  const parsed = toolInfo.parameters.safeParse(args)
  if (!parsed.success) {
    return {
      success: false,
      message: {
        type: 'error-text',
        value: `Invalid arguments for replaceInFile: ${parsed.error.message}`,
      },
    }
  }

  const { path, diff } = parsed.data

  try {
    const fileContent = await provider.readFile(path, false)

    if (fileContent == null) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: `<replace_in_file_result path="${path}" status="failed" message="File not found" />`,
        },
      }
    }

    const result = replaceInFile(fileContent, diff)

    if (result.status === 'no_diff_applied') {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: `<replace_in_file_result path="${path}" status="failed" message="Unable to apply changes">
  <file_content path="${path}">${fileContent}</file_content>
</replace_in_file_result>`,
        },
      }
    }

    await provider.writeFile(path, result.content)

    if (result.status === 'some_diff_applied') {
      return {
        success: true,
        message: {
          type: 'text',
          value: `<replace_in_file_result path="${path}" status="some_diff_applied" applied_count="${result.appliedCount}" total_count="${result.totalCount}">
  <file_content path="${path}">${result.content}</file_content>
</replace_in_file_result>`,
        },
      }
    }

    return {
      success: true,
      message: {
        type: 'text',
        value: `<replace_in_file_result path="${path}" status="all_diff_applied" />`,
      },
    }
  } catch (error) {
    return {
      success: false,
      message: {
        type: 'error-text',
        value: `Invalid arguments for replaceInFile: ${error}`,
      },
    }
  }
}

export default {
  ...toolInfo,
  handler,
} satisfies FullToolInfo
