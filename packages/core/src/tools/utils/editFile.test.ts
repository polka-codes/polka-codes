// Tests for editFile utility function
// generated by polka.codes

import { describe, expect, it } from 'bun:test'

import { END_OF_FILE, type EditOperation, START_OF_FILE, editFile } from './editFile'

describe('editFile', () => {
  const sampleContent = `line1
line2
line3
line4
line5`

  describe('basic operations', () => {
    it('should insert text after before_text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line2',
          new_text: '\ninserted line',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should insert text before after_text', async () => {
      const operations: EditOperation[] = [
        {
          after_text: 'line3',
          new_text: 'inserted line\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should replace text between before_text and after_text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line2',
          after_text: 'line4',
          new_text: '\nreplaced content\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle multiple operations in sequence', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line1',
          new_text: '\nafter line1',
        },
        {
          after_text: 'line5',
          new_text: 'before line5\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })
  })

  describe('special markers', () => {
    it('should replace entire file with START_OF_FILE and END_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          before_text: START_OF_FILE,
          after_text: END_OF_FILE,
          new_text: 'completely new content',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toBe('completely new content')
    })

    it('should insert at start of file with START_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          before_text: START_OF_FILE,
          new_text: 'new start\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should insert at end of file with END_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          after_text: END_OF_FILE,
          new_text: '\nnew end',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should replace from START_OF_FILE to specific text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: START_OF_FILE,
          after_text: 'line3',
          new_text: 'new beginning\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should replace from specific text to END_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line3',
          after_text: END_OF_FILE,
          new_text: '\nnew ending',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })
  })

  describe('line hints', () => {
    const contentWithDuplicates = `line1
duplicate
line3
duplicate
line5`

    it('should use line hint to find correct occurrence', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'duplicate',
          after_text_line_start: 4, // Second occurrence
          after_text: 'line5',
          new_text: '\nfound second duplicate\n',
        },
      ]

      const result = await editFile(contentWithDuplicates, operations)
      expect(result).toMatchSnapshot()
    })

    it('should fallback to regular search when hint fails', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'duplicate',
          before_text_line_start: 999, // Invalid hint
          new_text: '\nfound duplicate',
        },
      ]

      const result = await editFile(contentWithDuplicates, operations)
      expect(result).toMatchSnapshot()
    })

    it('should use before_text_line_start hint', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'duplicate',
          before_text_line_start: 4, // Second occurrence
          new_text: '\nafter second duplicate',
        },
      ]

      const result = await editFile(contentWithDuplicates, operations)
      expect(result).toMatchSnapshot()
    })
  })

  describe('edge cases', () => {
    it('should handle empty file', async () => {
      const operations: EditOperation[] = [
        {
          before_text: START_OF_FILE,
          new_text: 'new content',
        },
      ]

      const result = await editFile('', operations)
      expect(result).toBe('new content')
    })

    it('should handle empty new_text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line2',
          after_text: 'line4',
          new_text: '',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle whitespace in search text', async () => {
      const contentWithSpaces = `  line1
    line2
  line3`

      const operations: EditOperation[] = [
        {
          before_text: '    line2',
          new_text: '\n    inserted',
        },
      ]

      const result = await editFile(contentWithSpaces, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle newlines in search text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line2\nline3',
          new_text: '\nreplaced multiline',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle single line file', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'single',
          new_text: ' modified',
        },
      ]

      const result = await editFile('single line', operations)
      expect(result).toBe('single modified line')
    })
  })

  describe('error cases', () => {
    it('should throw error when no operations provided', async () => {
      expect(editFile(sampleContent, [])).rejects.toThrow('At least one edit operation is required')
    })

    it('should throw error when operations is null', async () => {
      expect(editFile(sampleContent, null as any)).rejects.toThrow('At least one edit operation is required')
    })

    it('should throw error when before_text not found', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'nonexistent',
          new_text: 'new text',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Could not find text: nonexistent')
    })

    it('should throw error when after_text not found', async () => {
      const operations: EditOperation[] = [
        {
          after_text: 'nonexistent',
          new_text: 'new text',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Could not find text: nonexistent')
    })

    it('should throw error when neither before_text nor after_text specified', async () => {
      const operations: EditOperation[] = [
        {
          new_text: 'new text',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Either before_text or after_text must be specified')
    })

    it('should throw error when after_text appears before before_text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line4',
          after_text: 'line2', // This appears before line4
          new_text: 'replacement',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Could not find text: line2')
    })
  })

  describe('complex scenarios', () => {
    it('should handle multiple operations with overlapping regions', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line1',
          new_text: '\nafter line1',
        },
        {
          before_text: 'line2',
          after_text: 'line3',
          new_text: '\nreplaced 2-3\n',
        },
        {
          after_text: 'line5',
          new_text: 'before line5\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle operations that create new searchable text', async () => {
      const operations: EditOperation[] = [
        {
          before_text: 'line2',
          new_text: '\nnew marker',
        },
        {
          before_text: 'new marker',
          new_text: '\nafter new marker',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle code-like content with indentation', async () => {
      const codeContent = `function test() {
  const x = 1;
  const y = 2;
  return x + y;
}`

      const operations: EditOperation[] = [
        {
          before_text: 'const y = 2;',
          new_text: '\n  const z = 3;\n  const y = 2;',
        },
      ]

      const result = await editFile(codeContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle JSON-like content', async () => {
      const jsonContent = `{
  "name": "test",
  "version": "1.0.0",
  "dependencies": {}
}`

      const operations: EditOperation[] = [
        {
          before_text: '"dependencies": {}',
          new_text: '"scripts": {\n    "test": "bun test"\n  },\n  "dependencies": {}',
        },
      ]

      const result = await editFile(jsonContent, operations)
      expect(result).toMatchSnapshot()
    })
  })
})
