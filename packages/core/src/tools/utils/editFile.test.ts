// Tests for editFile utility function
// generated by polka.codes

import { describe, expect, it } from 'bun:test'

import { END_OF_FILE, type EditOperation, START_OF_FILE, editFile } from './editFile'

describe('editFile', () => {
  const sampleContent = `line1
line2
line3
line4
line5`

  describe('basic operations', () => {
    it('should insert text after beforeText', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line2',
          newText: '\ninserted line',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should insert text before afterText', async () => {
      const operations: EditOperation[] = [
        {
          afterText: 'line3',
          newText: 'inserted line\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should replace text between beforeText and afterText', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line2',
          afterText: 'line4',
          newText: '\nreplaced content\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle multiple operations in sequence', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line1',
          newText: '\nafter line1',
        },
        {
          afterText: 'line5',
          newText: 'before line5\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })
  })

  describe('special markers', () => {
    it('should replace entire file with START_OF_FILE and END_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: START_OF_FILE,
          afterText: END_OF_FILE,
          newText: 'completely new content',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toBe('completely new content')
    })

    it('should insert at start of file with START_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: START_OF_FILE,
          newText: 'new start\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should insert at end of file with END_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          afterText: END_OF_FILE,
          newText: '\nnew end',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should replace from START_OF_FILE to specific text', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: START_OF_FILE,
          afterText: 'line3',
          newText: 'new beginning\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should replace from specific text to END_OF_FILE', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line3',
          afterText: END_OF_FILE,
          newText: '\nnew ending',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })
  })

  describe('line hints', () => {
    const contentWithDuplicates = `line1
duplicate
line3
duplicate
line5`

    it('should use line hint to find correct occurrence', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'duplicate',
          afterTextLineStart: 4, // Second occurrence
          afterText: 'line5',
          newText: '\nfound second duplicate\n',
        },
      ]

      const result = await editFile(contentWithDuplicates, operations)
      expect(result).toMatchSnapshot()
    })

    it('should fallback to regular search when hint fails', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'duplicate',
          beforeTextLineStart: 999, // Invalid hint
          newText: '\nfound duplicate',
        },
      ]

      const result = await editFile(contentWithDuplicates, operations)
      expect(result).toMatchSnapshot()
    })

    it('should use beforeTextLineStart hint', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'duplicate',
          beforeTextLineStart: 4, // Second occurrence
          newText: '\nafter second duplicate',
        },
      ]

      const result = await editFile(contentWithDuplicates, operations)
      expect(result).toMatchSnapshot()
    })
  })

  describe('edge cases', () => {
    it('should handle empty file', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: START_OF_FILE,
          newText: 'new content',
        },
      ]

      const result = await editFile('', operations)
      expect(result).toBe('new content')
    })

    it('should handle empty newText', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line2',
          afterText: 'line4',
          newText: '',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle whitespace in search text', async () => {
      const contentWithSpaces = `  line1
    line2
  line3`

      const operations: EditOperation[] = [
        {
          beforeText: '    line2',
          newText: '\n    inserted',
        },
      ]

      const result = await editFile(contentWithSpaces, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle newlines in search text', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line2\nline3',
          newText: '\nreplaced multiline',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle single line file', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'single',
          newText: ' modified',
        },
      ]

      const result = await editFile('single line', operations)
      expect(result).toBe('single modified line')
    })
  })

  describe('error cases', () => {
    it('should throw error when no operations provided', async () => {
      expect(editFile(sampleContent, [])).rejects.toThrow('At least one edit operation is required')
    })

    it('should throw error when operations is null', async () => {
      expect(editFile(sampleContent, null as any)).rejects.toThrow('At least one edit operation is required')
    })

    it('should throw error when beforeText not found', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'nonexistent',
          newText: 'new text',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Could not find text: nonexistent')
    })

    it('should throw error when afterText not found', async () => {
      const operations: EditOperation[] = [
        {
          afterText: 'nonexistent',
          newText: 'new text',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Could not find text: nonexistent')
    })

    it('should throw error when neither beforeText nor afterText specified', async () => {
      const operations: EditOperation[] = [
        {
          newText: 'new text',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Either beforeText or afterText must be specified')
    })

    it('should throw error when afterText appears before beforeText', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line4',
          afterText: 'line2', // This appears before line4
          newText: 'replacement',
        },
      ]

      expect(editFile(sampleContent, operations)).rejects.toThrow('Could not find text: line2')
    })
  })

  describe('complex scenarios', () => {
    it('should handle multiple operations with overlapping regions', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line1',
          newText: '\nafter line1',
        },
        {
          beforeText: 'line2',
          afterText: 'line3',
          newText: '\nreplaced 2-3\n',
        },
        {
          afterText: 'line5',
          newText: 'before line5\n',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle operations that create new searchable text', async () => {
      const operations: EditOperation[] = [
        {
          beforeText: 'line2',
          newText: '\nnew marker',
        },
        {
          beforeText: 'new marker',
          newText: '\nafter new marker',
        },
      ]

      const result = await editFile(sampleContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle code-like content with indentation', async () => {
      const codeContent = `function test() {
  const x = 1;
  const y = 2;
  return x + y;
}`

      const operations: EditOperation[] = [
        {
          beforeText: 'const y = 2;',
          newText: '\n  const z = 3;\n  const y = 2;',
        },
      ]

      const result = await editFile(codeContent, operations)
      expect(result).toMatchSnapshot()
    })

    it('should handle JSON-like content', async () => {
      const jsonContent = `{
  "name": "test",
  "version": "1.0.0",
  "dependencies": {}
}`

      const operations: EditOperation[] = [
        {
          beforeText: '"dependencies": {}',
          newText: '"scripts": {\n    "test": "bun test"\n  },\n  "dependencies": {}',
        },
      ]

      const result = await editFile(jsonContent, operations)
      expect(result).toMatchSnapshot()
    })
  })
})
