// Core logic for flexible file editing with search/replace operations
// generated by polka.codes

/**
 * Edit operation using search/replace pattern
 */
export interface EditOperation {
  search: string
  replace: string
}

export const START_OF_FILE = '<<<START_OF_FILE>>>'
export const END_OF_FILE = '<<<END_OF_FILE>>>'

/**
 * Apply multiple edit operations to file content using search/replace pattern.
 * @param fileContent - The original file content
 * @param operations - Array of edit operations to apply
 * @returns The modified file content
 */
export const editFile = async (fileContent: string, operations: EditOperation[]): Promise<string> => {
  if (!operations || operations.length === 0) {
    throw new Error('At least one edit operation is required')
  }

  let updatedContent = fileContent

  // Process operations in order
  for (const operation of operations) {
    updatedContent = await applyEditOperation(updatedContent, operation)
  }

  return updatedContent
}

async function applyEditOperation(fileContent: string, operation: EditOperation): Promise<string> {
  const { search, replace } = operation

  // Validate operation
  if (search === START_OF_FILE && replace === END_OF_FILE) {
    throw new Error('Cannot search for START_OF_FILE and replace with END_OF_FILE')
  }

  if (search === END_OF_FILE && replace === START_OF_FILE) {
    throw new Error('Cannot search for END_OF_FILE and replace with START_OF_FILE')
  }

  // Handle special cases for start/end of file
  if (search === START_OF_FILE) {
    // Insert at start of file
    return replace + fileContent
  }

  if (search === END_OF_FILE) {
    // Insert at end of file
    return fileContent + replace
  }

  // Handle normal search and replace
  const index = fileContent.indexOf(search)
  if (index === -1) {
    throw new Error(`Could not find text: ${search}`)
  }

  // Replace first occurrence only
  return fileContent.slice(0, index) + replace + fileContent.slice(index + search.length)
}
