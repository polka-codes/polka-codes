// Core logic for flexible file editing with before/after text anchors
// generated by polka.codes

/**
 * NOTE: Both `start_anchor` and `end_anchor` are **exclusive** markers.
 * They remain in the file; `new_text` is inserted *between* them.
 */
export interface EditOperation {
  start_anchor?: string
  end_anchor?: string
  new_text: string
  start_anchor_line_start?: number
  end_anchor_line_start?: number
}

export const START_OF_FILE = '<<<START_OF_FILE>>>'
export const END_OF_FILE = '<<<END_OF_FILE>>>'

/**
 * Apply multiple edit operations to file content using start/end text anchors (anchors are **exclusive** â€“ they stay in the file).
 * @param fileContent - The original file content
 * @param operations - Array of edit operations to apply
 * @returns The modified file content
 */
export const editFile = async (fileContent: string, operations: EditOperation[]): Promise<string> => {
  if (!operations || operations.length === 0) {
    throw new Error('At least one edit operation is required')
  }

  const originalLines = fileContent.split('\n')
  let updatedContent = fileContent

  // Process operations in order
  for (const operation of operations) {
    updatedContent = await applyEditOperation(updatedContent, operation, originalLines)
  }

  return updatedContent
}

async function applyEditOperation(fileContent: string, operation: EditOperation, originalLines: string[]): Promise<string> {
  const { start_anchor, end_anchor, new_text, start_anchor_line_start, end_anchor_line_start } = operation

  // Handle special cases for start/end of file
  if (start_anchor === START_OF_FILE && end_anchor === END_OF_FILE) {
    // Replace entire file
    return new_text
  }

  if (start_anchor === START_OF_FILE) {
    // Insert at start or replace from start to end_anchor
    if (!end_anchor) {
      return new_text + fileContent
    }
    const afterIndex = findTextWithHint(fileContent, end_anchor, end_anchor_line_start, originalLines)
    return new_text + fileContent.slice(afterIndex)
  }

  if (end_anchor === END_OF_FILE) {
    // Insert at end or replace from start_anchor to end
    if (!start_anchor) {
      return fileContent + new_text
    }
    const beforeIndex = findTextWithHint(fileContent, start_anchor, start_anchor_line_start, originalLines)
    const beforeEndIndex = beforeIndex + start_anchor.length
    return fileContent.slice(0, beforeEndIndex) + new_text
  }

  // Handle normal case with both start_anchor and end_anchor
  if (start_anchor && end_anchor) {
    const beforeIndex = findTextWithHint(fileContent, start_anchor, start_anchor_line_start, originalLines)
    const beforeEndIndex = beforeIndex + start_anchor.length
    const afterIndex = findTextWithHint(fileContent, end_anchor, end_anchor_line_start, originalLines, beforeEndIndex)

    return fileContent.slice(0, beforeEndIndex) + new_text + fileContent.slice(afterIndex)
  }

  // Handle case with only start_anchor (insert after)
  if (start_anchor) {
    const beforeIndex = findTextWithHint(fileContent, start_anchor, start_anchor_line_start, originalLines)
    const beforeEndIndex = beforeIndex + start_anchor.length
    return fileContent.slice(0, beforeEndIndex) + new_text + fileContent.slice(beforeEndIndex)
  }

  // Handle case with only end_anchor (insert before)
  if (end_anchor) {
    const afterIndex = findTextWithHint(fileContent, end_anchor, end_anchor_line_start, originalLines)
    return fileContent.slice(0, afterIndex) + new_text + fileContent.slice(afterIndex)
  }

  throw new Error('Either start_anchor or end_anchor must be specified')
}

function findTextWithHint(
  content: string,
  searchText: string,
  lineHint: number | undefined,
  originalLines: string[],
  startIndex = 0,
): number {
  // If we have a line hint, try searching around that area first
  if (lineHint && lineHint > 0 && lineHint <= originalLines.length) {
    const hintIndex = getLineStartIndex(originalLines, lineHint - 1) // Convert to 0-based
    const searchRadius = 5 // Search within 5 lines of the hint

    // Search in a window around the hint
    const windowStart = Math.max(0, hintIndex - searchRadius * 50) // Approximate chars per line
    const windowEnd = Math.min(content.length, hintIndex + searchRadius * 50)
    const windowContent = content.slice(windowStart, windowEnd)

    const relativeIndex = windowContent.indexOf(searchText)
    if (relativeIndex !== -1) {
      const absoluteIndex = windowStart + relativeIndex
      if (absoluteIndex >= startIndex) {
        return absoluteIndex
      }
    }
  }

  // Fallback to regular search from startIndex
  const index = content.indexOf(searchText, startIndex)
  if (index === -1) {
    throw new Error(`Could not find text: ${searchText}`)
  }
  return index
}

function getLineStartIndex(lines: string[], lineIndex: number): number {
  let index = 0
  for (let i = 0; i < lineIndex && i < lines.length; i++) {
    index += lines[i].length + 1 // +1 for newline character
  }
  return index
}
