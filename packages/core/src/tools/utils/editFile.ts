// Core logic for flexible file editing with before/after text anchors
// generated by polka.codes

export interface EditOperation {
  beforeText?: string
  afterText?: string
  newText: string
  beforeTextLineStart?: number
  afterTextLineStart?: number
}

const START_OF_FILE = '<<<START_OF_FILE>>>'
const END_OF_FILE = '<<<END_OF_FILE>>>'

/**
 * Apply multiple edit operations to file content using before/after text anchors
 * @param fileContent - The original file content
 * @param operations - Array of edit operations to apply
 * @returns The modified file content
 */
export const editFile = async (fileContent: string, operations: EditOperation[]): Promise<string> => {
  if (!operations || operations.length === 0) {
    throw new Error('At least one edit operation is required')
  }

  const originalLines = fileContent.split('\n')
  let updatedContent = fileContent

  // Process operations in order
  for (const operation of operations) {
    updatedContent = await applyEditOperation(updatedContent, operation, originalLines)
  }

  return updatedContent
}

async function applyEditOperation(fileContent: string, operation: EditOperation, originalLines: string[]): Promise<string> {
  const { beforeText, afterText, newText, beforeTextLineStart, afterTextLineStart } = operation

  // Handle special cases for start/end of file
  if (beforeText === START_OF_FILE && afterText === END_OF_FILE) {
    // Replace entire file
    return newText
  }

  if (beforeText === START_OF_FILE) {
    // Insert at start or replace from start to afterText
    if (!afterText) {
      return newText + fileContent
    }
    const afterIndex = findTextWithHint(fileContent, afterText, afterTextLineStart, originalLines)
    return newText + fileContent.slice(afterIndex)
  }

  if (afterText === END_OF_FILE) {
    // Insert at end or replace from beforeText to end
    if (!beforeText) {
      return fileContent + newText
    }
    const beforeIndex = findTextWithHint(fileContent, beforeText, beforeTextLineStart, originalLines)
    const beforeEndIndex = beforeIndex + beforeText.length
    return fileContent.slice(0, beforeEndIndex) + newText
  }

  // Handle normal case with both beforeText and afterText
  if (beforeText && afterText) {
    const beforeIndex = findTextWithHint(fileContent, beforeText, beforeTextLineStart, originalLines)
    const beforeEndIndex = beforeIndex + beforeText.length
    const afterIndex = findTextWithHint(fileContent, afterText, afterTextLineStart, originalLines, beforeEndIndex)

    return fileContent.slice(0, beforeEndIndex) + newText + fileContent.slice(afterIndex)
  }

  // Handle case with only beforeText (insert after)
  if (beforeText) {
    const beforeIndex = findTextWithHint(fileContent, beforeText, beforeTextLineStart, originalLines)
    const beforeEndIndex = beforeIndex + beforeText.length
    return fileContent.slice(0, beforeEndIndex) + newText + fileContent.slice(beforeEndIndex)
  }

  // Handle case with only afterText (insert before)
  if (afterText) {
    const afterIndex = findTextWithHint(fileContent, afterText, afterTextLineStart, originalLines)
    return fileContent.slice(0, afterIndex) + newText + fileContent.slice(afterIndex)
  }

  throw new Error('Either beforeText or afterText must be specified')
}

function findTextWithHint(
  content: string,
  searchText: string,
  lineHint: number | undefined,
  originalLines: string[],
  startIndex = 0,
): number {
  // If we have a line hint, try searching around that area first
  if (lineHint && lineHint > 0 && lineHint <= originalLines.length) {
    const hintIndex = getLineStartIndex(originalLines, lineHint - 1) // Convert to 0-based
    const searchRadius = 5 // Search within 5 lines of the hint

    // Search in a window around the hint
    const windowStart = Math.max(0, hintIndex - searchRadius * 50) // Approximate chars per line
    const windowEnd = Math.min(content.length, hintIndex + searchRadius * 50)
    const windowContent = content.slice(windowStart, windowEnd)

    const relativeIndex = windowContent.indexOf(searchText)
    if (relativeIndex !== -1) {
      const absoluteIndex = windowStart + relativeIndex
      if (absoluteIndex >= startIndex) {
        return absoluteIndex
      }
    }
  }

  // Fallback to regular search from startIndex
  const index = content.indexOf(searchText, startIndex)
  if (index === -1) {
    throw new Error(`Could not find text: ${searchText}`)
  }
  return index
}

function getLineStartIndex(lines: string[], lineIndex: number): number {
  let index = 0
  for (let i = 0; i < lineIndex && i < lines.length; i++) {
    index += lines[i].length + 1 // +1 for newline character
  }
  return index
}
