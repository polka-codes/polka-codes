/**
 * Tests for the updateKnowledge tool
 * Generated by polka.codes
 */
import { describe, expect, it, spyOn } from 'bun:test'
import YAML from 'yaml'
import { ToolResponseType } from '../tool'
import { MockProvider } from './provider'
import updateKnowledge from './updateKnowledge'

describe('updateKnowledge', () => {
  it('should be defined', () => {
    expect(updateKnowledge).toBeDefined()
    expect(updateKnowledge.name).toBe('update_knowledge')
  })

  it('should update knowledge file with new content', async () => {
    const provider = new MockProvider()

    const existingContent = `
description: "Test directory"
files:
  "file1.ts":
    description: "Test file 1"
rules:
  1: "Rule 1"
  2: "Rule 2"
`

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return existingContent
      }
      return ''
    })

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test basic update with path-keyed files dictionary
    const result = await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
files:
  "file2.ts":
    description: "Test file 2"
`,
    })

    expect(result.type).toBe(ToolResponseType.Reply)
    expect(writeFileSpy).toHaveBeenCalled()

    // Verify the merged content
    const lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    const writtenPath = lastCall[0]
    const writtenContent = lastCall[1]

    expect(writtenPath).toBe('test/knowledge.ai.yml')

    const parsedContent = YAML.parse(writtenContent)
    expect(parsedContent.description).toBe('Test directory')
    expect(Object.keys(parsedContent.files).length).toBe(2)
    expect(parsedContent.files['file1.ts'].description).toBe('Test file 1')
    expect(parsedContent.files['file2.ts'].description).toBe('Test file 2')
    expect(parsedContent.rules).toEqual({ '1': 'Rule 1', '2': 'Rule 2' })
  })

  it('should handle dictionary operations with directives', async () => {
    const provider = new MockProvider()

    // Mock existing knowledge file
    const existingContent = `
description: "Test directory"
rules:
  1: "Rule 1"
  2: "Rule 2"
  3: "Rule 3"
`

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return existingContent
      }
      return ''
    })

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test $merge directive
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
rules:
  $merge:
    - "Rule 4"
`,
    })

    // Verify the merged content
    let lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    let writtenContent = lastCall[1]
    let parsedContent = YAML.parse(writtenContent)

    expect(Object.keys(parsedContent.rules).length).toBe(4)
    expect(parsedContent.rules).toEqual({ '1': 'Rule 1', '2': 'Rule 2', '3': 'Rule 3', '4': 'Rule 4' })

    // Test $remove directive
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return YAML.stringify(parsedContent)
      }
      return ''
    })

    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
rules:
  $remove:
    - "2"
`,
    })

    // Verify the content after removal
    lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    writtenContent = lastCall[1]
    parsedContent = YAML.parse(writtenContent)

    expect(Object.keys(parsedContent.rules).length).toBe(3)
    expect(parsedContent.rules).toEqual({ '1': 'Rule 1', '3': 'Rule 3', '4': 'Rule 4' })
    // Note: The gap in numbering (missing '2') is intentional and acceptable

    // Test $replace directive
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return YAML.stringify(parsedContent)
      }
      return ''
    })

    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
rules:
  $replace:
    - "New Rule A"
    - "New Rule B"
`,
    })

    // Verify the content after replacement
    lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    writtenContent = lastCall[1]
    parsedContent = YAML.parse(writtenContent)

    expect(Object.keys(parsedContent.rules).length).toBe(2)
    expect(parsedContent.rules).toEqual({ '1': 'New Rule A', '2': 'New Rule B' })
  })

  it('should handle nested updates', async () => {
    const provider = new MockProvider()

    // Mock existing knowledge file with nested structure and path-keyed files
    const existingContent = `
description: "Test directory"
files:
  "file1.ts":
    description: "Test file 1"
    api:
      functions:
        1:
          name: "func1"
          description: "Function 1"
          params:
            1:
              name: "param1"
              type: "string"
`

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return existingContent
      }
      return ''
    })

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test nested updates
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
files:
  "file1.ts":
    api:
      functions:
        1:
          description: "Updated function description"
          params:
            1:
              type: "number"
`,
    })

    // Verify the updated content
    const lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    const writtenContent = lastCall[1]
    const parsedContent = YAML.parse(writtenContent)

    expect(parsedContent.files['file1.ts'].api.functions['1'].description).toBe('Updated function description')
    expect(parsedContent.files['file1.ts'].api.functions['1'].params['1'].type).toBe('number')
  })

  it('should create a new knowledge file if it does not exist', async () => {
    const provider = new MockProvider()

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async () => '')

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test creating a new file with path-keyed files dictionary
    await updateKnowledge.handler(provider, {
      path: 'new-dir',
      knowledge: `
description: "New directory"
files:
  "newFile.ts":
    description: "New file"
rules:
  1: "New rule"
`,
    })

    // Verify the new file was created
    const lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    const writtenPath = lastCall[0]
    const writtenContent = lastCall[1]

    expect(writtenPath).toBe('new-dir/knowledge.ai.yml')

    const parsedContent = YAML.parse(writtenContent)
    expect(parsedContent.description).toBe('New directory')
    expect(Object.keys(parsedContent.files).length).toBe(1)
    expect(parsedContent.files['newFile.ts'].description).toBe('New file')
    expect(parsedContent.rules).toEqual({ '1': 'New rule' })
  })

  it('should handle errors gracefully', async () => {
    const provider = new MockProvider()

    // Test with invalid YAML
    const result = await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
description: "Invalid YAML
  - This is not valid YAML
`,
    })

    expect(result.type).toBe(ToolResponseType.Error)
    if (result.type === ToolResponseType.Error) {
      expect(result.message).toContain('Invalid YAML content')
    }
  })

  it('should convert arrays to numbered dictionaries', async () => {
    const provider = new MockProvider()

    // Mock existing knowledge file
    const existingContent = `
description: "Test directory"
rules:
  1: "Rule 1"
  2: "Rule 2"
`

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return existingContent
      }
      return ''
    })

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test with array input that should be converted to numbered dictionary
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
patterns:
  - "Pattern 1"
  - "Pattern 2"
  - "Pattern 3"
`,
    })

    // Verify the content was converted properly
    const lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    const writtenContent = lastCall[1]
    const parsedContent = YAML.parse(writtenContent)

    expect(parsedContent.patterns).toBeDefined()
    expect(typeof parsedContent.patterns).toBe('object')
    expect(Array.isArray(parsedContent.patterns)).toBe(false)
    expect(parsedContent.patterns).toEqual({
      '1': 'Pattern 1',
      '2': 'Pattern 2',
      '3': 'Pattern 3',
    })
  })

  it('should handle null values in updates', async () => {
    const provider = new MockProvider()

    // Mock existing knowledge file
    const existingContent = `
description: "Test directory"
files:
  "file1.ts":
    description: "Test file 1"
    api:
      functions:
        1:
          name: "func1"
          description: "Function 1"
          deprecated: true
`

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return existingContent
      }
      return ''
    })

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test with null value to remove a property
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
files:
  "file1.ts":
    api:
      functions:
        1:
          deprecated: null
`,
    })

    // Verify the property was removed
    const lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    const writtenContent = lastCall[1]
    const parsedContent = YAML.parse(writtenContent)

    expect(parsedContent.files['file1.ts'].api.functions['1'].name).toBe('func1')
    expect(parsedContent.files['file1.ts'].api.functions['1'].description).toBe('Function 1')
    expect(parsedContent.files['file1.ts'].api.functions['1'].deprecated).toBe(null)
  })

  it('should handle concurrent updates to the same file', async () => {
    const provider = new MockProvider()

    // Mock existing knowledge file
    let currentContent = `
description: "Test directory"
files:
  "file1.ts":
    description: "Test file 1"
  "file2.ts":
    description: "Test file 2"
`

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async (path) => {
      if (path === 'test/knowledge.ai.yml') {
        return currentContent
      }
      return ''
    })

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async (path, content) => {
      if (path === 'test/knowledge.ai.yml') {
        currentContent = content
      }
    })

    // First update
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
files:
  "file3.ts":
    description: "Test file 3"
`,
    })

    // Second update (simulating concurrent update)
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
files:
  "file4.ts":
    description: "Test file 4"
`,
    })

    // Verify both updates were applied
    const parsedContent = YAML.parse(currentContent)
    expect(Object.keys(parsedContent.files).length).toBe(4)
    expect(parsedContent.files['file1.ts'].description).toBe('Test file 1')
    expect(parsedContent.files['file2.ts'].description).toBe('Test file 2')
    expect(parsedContent.files['file3.ts'].description).toBe('Test file 3')
    expect(parsedContent.files['file4.ts'].description).toBe('Test file 4')
  })

  it('should validate YAML structure compliance', async () => {
    const provider = new MockProvider()

    const readFileSpy = spyOn(provider, 'readFile')
    readFileSpy.mockImplementation(async () => '')

    const writeFileSpy = spyOn(provider, 'writeFile')
    writeFileSpy.mockImplementation(async () => {})

    // Test with files as an array instead of a dictionary
    await updateKnowledge.handler(provider, {
      path: 'test',
      knowledge: `
description: "Test directory"
files:
  - path: "file1.ts"
    description: "This should be converted to a dictionary"
`,
    })

    // Verify the structure was corrected
    const lastCall = writeFileSpy.mock.calls[writeFileSpy.mock.calls.length - 1]
    const writtenContent = lastCall[1]
    const parsedContent = YAML.parse(writtenContent)

    // The array should have been converted to a numbered dictionary
    expect(Array.isArray(parsedContent.files)).toBe(false)
    expect(typeof parsedContent.files).toBe('object')
    expect(parsedContent.files['1'].path).toBe('file1.ts')
    expect(parsedContent.files['1'].description).toBe('This should be converted to a dictionary')
  })
})
