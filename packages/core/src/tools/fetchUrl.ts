// generated by polka.codes
import { type FullToolInfo, PermissionLevel, type ToolHandler, type ToolInfo, ToolResponseType } from '../tool'
import type { WebProvider } from './provider'
import { getStringArray } from './utils'

export const toolInfo = {
  name: 'fetch_url',
  description: 'Fetches content from one or more URLs.',
  parameters: [
    {
      name: 'url',
      description:
        'The URL(s) to fetch content from. Can be a single URL or a comma-separated list of URLs. Note: The content will be converted to Markdown format',
      required: true,
    },
  ],
  examples: [
    {
      description: 'Fetch content from a single URL',
      parameters: [
        {
          name: 'url',
          value: 'https://example.com',
        },
      ],
    },
    {
      description: 'Fetch content from multiple URLs',
      parameters: [
        {
          name: 'url',
          value: 'https://example.com,https://another-example.com',
        },
      ],
    },
  ],
  permissionLevel: PermissionLevel.Read,
} as const satisfies ToolInfo

export const handler: ToolHandler<typeof toolInfo, WebProvider> = async (provider, args) => {
  if (!provider.fetchUrl) {
    return {
      type: ToolResponseType.Error,
      message: 'Not possible to fetch url. Abort.',
    }
  }

  const urls = getStringArray(args, 'url')

  if (urls.length === 0) {
    return {
      type: ToolResponseType.Error,
      message: 'No URLs provided. Please provide at least one URL to fetch.',
    }
  }

  const results: Promise<string>[] = []
  for (const url of urls) {
    try {
      const content = provider.fetchUrl(url).then((res) => `<fetch_url_content url="${url}">${res}</fetch_url_content>`)
      results.push(content)
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      results.push(Promise.resolve(`<fetch_url_error url="${url}">${errorMessage}</fetch_url_error>`))
    }
  }

  const resolvedResults = await Promise.all(results)

  return {
    type: ToolResponseType.Reply,
    message: resolvedResults.join('\n'),
  }
}

export const isAvailable = (provider: WebProvider): boolean => {
  return typeof provider.fetchUrl === 'function'
}

export default {
  ...toolInfo,
  handler,
  isAvailable,
} satisfies FullToolInfo
