// generated by polka.codes
import { type FullToolInfo, PermissionLevel, type ToolHandler, type ToolInfo, ToolResponseType } from '../tool'
import type { WebProvider } from './provider'
import { getStringArray } from './utils'

export const toolInfo = {
  name: 'fetch_url',
  description:
    'Fetch the content located at one or more HTTP(S) URLs and return it in Markdown format. This works for standard web pages as well as raw files (e.g. README.md, source code) hosted on platforms like GitHub.',
  parameters: [
    {
      name: 'url',
      description: 'One or more URLs to fetch, separated by commas if multiple.',
      required: true,
    },
  ],
  examples: [
    {
      description: 'Fetch a single webpage',
      parameters: [
        {
          name: 'url',
          value: 'https://example.com',
        },
      ],
    },
    {
      description: 'Fetch multiple webpages',
      parameters: [
        {
          name: 'url',
          value: 'https://example.com,https://developer.mozilla.org/en-US/docs/Web/HTTP',
        },
      ],
    },
    {
      description: 'Fetch a raw file from GitHub',
      parameters: [
        {
          name: 'url',
          value: 'https://raw.githubusercontent.com/user/repo/main/README.md',
        },
      ],
    },
  ],
  permissionLevel: PermissionLevel.Read,
} as const satisfies ToolInfo

export const handler: ToolHandler<typeof toolInfo, WebProvider> = async (provider, args) => {
  if (!provider.fetchUrl) {
    return {
      type: ToolResponseType.Error,
      message: 'Not possible to fetch url. Abort.',
    }
  }

  const urls = getStringArray(args, 'url')

  if (urls.length === 0) {
    return {
      type: ToolResponseType.Error,
      message: 'No URLs provided. Please provide at least one URL to fetch.',
    }
  }

  const results: Promise<string>[] = []
  for (const url of urls) {
    try {
      const content = provider.fetchUrl(url).then((res) => `<fetch_url_content url="${url}">${res}</fetch_url_content>`)
      results.push(content)
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      results.push(Promise.resolve(`<fetch_url_error url="${url}">${errorMessage}</fetch_url_error>`))
    }
  }

  const resolvedResults = await Promise.all(results)

  return {
    type: ToolResponseType.Reply,
    message: resolvedResults.join('\n'),
  }
}

export const isAvailable = (provider: WebProvider): boolean => {
  return typeof provider.fetchUrl === 'function'
}

export default {
  ...toolInfo,
  handler,
  isAvailable,
} satisfies FullToolInfo
