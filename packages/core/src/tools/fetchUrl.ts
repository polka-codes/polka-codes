// generated by polka.codes
import { z } from 'zod'
import { type AgentToolInfo, type FullAgentToolInfo, type ToolHandler, ToolResponseType } from '../tool'
import type { WebProvider } from './provider'

export const toolInfo = {
  name: 'fetchUrl',
  description:
    'Fetch the content located at one or more HTTP(S) URLs and return it in Markdown format. This works for standard web pages as well as raw files (e.g. README.md, source code) hosted on platforms like GitHub.',
  parameters: z
    .object({
      url: z
        .preprocess((val) => {
          if (!val) return []
          const values = Array.isArray(val) ? val : [val]
          return values.flatMap((i) => (typeof i === 'string' ? i.split(',') : [])).filter((s) => s.length > 0)
        }, z.array(z.string()))
        .describe('One or more URLs to fetch, separated by commas if multiple.')
        .meta({ usageValue: 'url' }),
    })
    .meta({
      examples: [
        {
          description: 'Fetch a single webpage',
          input: {
            url: 'https://example.com',
          },
        },
        {
          description: 'Fetch multiple webpages',
          input: {
            url: 'https://example.com,https://developer.mozilla.org/en-US/docs/Web/HTTP',
          },
        },
        {
          description: 'Fetch a raw file from GitHub',
          input: {
            url: 'https://raw.githubusercontent.com/user/repo/main/README.md',
          },
        },
      ],
    }),
} as const satisfies AgentToolInfo

export const handler: ToolHandler<typeof toolInfo, WebProvider> = async (provider, args) => {
  if (!provider.fetchUrl) {
    return {
      type: ToolResponseType.Error,
      message: {
        type: 'error-text',
        value: 'Not possible to fetch url.',
      },
    }
  }

  const { url: urls } = toolInfo.parameters.parse(args)

  if (urls.length === 0) {
    return {
      type: ToolResponseType.Error,
      message: {
        type: 'error-text',
        value: 'No URLs provided. Please provide at least one URL to fetch.',
      },
    }
  }

  const results: Promise<string>[] = []
  for (const url of urls) {
    try {
      const content = provider.fetchUrl(url).then((res) => `<fetch_url_content url="${url}">${res}</fetch_url_content>`)
      results.push(content)
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      results.push(Promise.resolve(`<fetch_url_error url="${url}">${errorMessage}</fetch_url_error>`))
    }
  }

  const resolvedResults = await Promise.all(results)

  return {
    type: ToolResponseType.Reply,
    message: {
      type: 'text',
      value: resolvedResults.join('\n'),
    },
  }
}

export default {
  ...toolInfo,
  handler,
} satisfies FullAgentToolInfo
