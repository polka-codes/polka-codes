// generated by polka.codes
import { z } from 'zod'
import { type FullToolInfoV2, PermissionLevel, type ToolHandler, type ToolInfoV2, ToolResponseType } from '../tool'
import type { WebProvider } from './provider'

export const toolInfo = {
  name: 'fetch_url',
  description:
    'Fetch the content located at one or more HTTP(S) URLs and return it in Markdown format. This works for standard web pages as well as raw files (e.g. README.md, source code) hosted on platforms like GitHub.',
  parameters: z
    .object({
      url: z
        .preprocess((val) => {
          if (!val) return []
          const values = Array.isArray(val) ? val : [val]
          return values.flatMap((i) => (typeof i === 'string' ? i.split(',') : [])).filter((s) => s.length > 0)
        }, z.array(z.string()))
        .describe('One or more URLs to fetch, separated by commas if multiple.')
        .meta({ usageValue: 'url' }),
    })
    .meta({
      examples: [
        {
          description: 'Fetch a single webpage',
          input: {
            url: 'https://example.com',
          },
        },
        {
          description: 'Fetch multiple webpages',
          input: {
            url: 'https://example.com,https://developer.mozilla.org/en-US/docs/Web/HTTP',
          },
        },
        {
          description: 'Fetch a raw file from GitHub',
          input: {
            url: 'https://raw.githubusercontent.com/user/repo/main/README.md',
          },
        },
      ],
    }),
  permissionLevel: PermissionLevel.Read,
} as const satisfies ToolInfoV2

export const handler: ToolHandler<typeof toolInfo, WebProvider> = async (provider, args) => {
  if (!provider.fetchUrl) {
    return {
      type: ToolResponseType.Error,
      message: 'Not possible to fetch url. Abort.',
    }
  }

  const { url: urls } = toolInfo.parameters.parse(args)

  if (urls.length === 0) {
    return {
      type: ToolResponseType.Error,
      message: 'No URLs provided. Please provide at least one URL to fetch.',
    }
  }

  const results: Promise<string>[] = []
  for (const url of urls) {
    try {
      const content = provider.fetchUrl(url).then((res) => `<fetch_url_content url="${url}">${res}</fetch_url_content>`)
      results.push(content)
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      results.push(Promise.resolve(`<fetch_url_error url="${url}">${errorMessage}</fetch_url_error>`))
    }
  }

  const resolvedResults = await Promise.all(results)

  return {
    type: ToolResponseType.Reply,
    message: resolvedResults.join('\n'),
  }
}

export const isAvailable = (provider: WebProvider): boolean => {
  return typeof provider.fetchUrl === 'function'
}

export default {
  ...toolInfo,
  handler,
  isAvailable,
} satisfies FullToolInfoV2
