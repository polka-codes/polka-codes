// Generated by polka.codes
// Tests for the renameFile tool

import { describe, expect, it, spyOn } from 'bun:test'
import { MockProvider } from './provider'
import renameFile from './renameFile'

describe('renameFile', () => {
  it('should rename file successfully', async () => {
    const mockProvider = new MockProvider()
    spyOn(mockProvider, 'renameFile').mockResolvedValue()

    const result = await renameFile.handler(mockProvider, {
      source_path: 'old.txt',
      target_path: 'new.txt',
    })

    // Verify successful rename
    expect(result).toEqual({
      success: true,
      message: {
        type: 'text',
        value: '<rename_file_path>new.txt</rename_file_path><status>Success</status>',
      },
    })
    expect(mockProvider.renameFile).toHaveBeenCalledWith('old.txt', 'new.txt')
  })

  it('should handle rename errors', async () => {
    const mockProvider = new MockProvider()
    spyOn(mockProvider, 'renameFile').mockRejectedValue(new Error('Rename error'))

    const result = renameFile.handler(mockProvider, {
      source_path: 'error.txt',
      target_path: 'new.txt',
    })

    // Verify error is propagated
    await expect(result).rejects.toThrow('Rename error')
    expect(mockProvider.renameFile).toHaveBeenCalledWith('error.txt', 'new.txt')
  })

  it('should handle unavailable provider', async () => {
    const mockProvider = new MockProvider()
    // @ts-expect-error
    mockProvider.renameFile = undefined

    const result = await renameFile.handler(mockProvider, {
      source_path: 'test.txt',
      target_path: 'new.txt',
    })

    // Verify unavailable provider returns error message
    expect(result).toEqual({
      success: false,
      message: {
        type: 'error-text',
        value: 'Not possible to rename file.',
      },
    })
  })
})
