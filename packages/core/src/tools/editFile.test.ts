// Tests for editFile tool
// generated by polka.codes

import { describe, expect, it } from 'bun:test'
import { handler, isAvailable, toolInfo } from './editFile'
import type { FilesystemProvider } from './provider'

describe('editFile tool', () => {
  describe('toolInfo', () => {
    it('should have correct tool definition', () => {
      expect(toolInfo).toMatchSnapshot()
    })
  })

  describe('isAvailable', () => {
    it('should return true when provider has readFile and writeFile', () => {
      const provider: FilesystemProvider = {
        readFile: async () => 'content',
        writeFile: async () => {},
      }
      expect(isAvailable(provider)).toBe(true)
    })

    it('should return false when provider lacks readFile', () => {
      const provider: FilesystemProvider = {
        writeFile: async () => {},
      }
      expect(isAvailable(provider)).toBe(false)
    })

    it('should return false when provider lacks writeFile', () => {
      const provider: FilesystemProvider = {
        readFile: async () => 'content',
      }
      expect(isAvailable(provider)).toBe(false)
    })
  })

  describe('handler', () => {
    const createProvider = (fileContent: string | undefined = 'test content'): FilesystemProvider => ({
      readFile: async () => fileContent,
      writeFile: async () => {},
    })

    it('should return error when provider lacks capabilities', async () => {
      const provider: FilesystemProvider = {}
      const args = { path: 'test.txt', operations: [{ newText: 'new' }] }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
    })

    it('should return error when file not found', async () => {
      const provider = createProvider()
      const args = { path: 'missing.txt', operations: [{ newText: 'new' }] }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
    })

    it('should return error when no operations provided', async () => {
      const provider = createProvider('content')
      const args = { path: 'test.txt', operations: [] }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
    })

    it('should handle single operation successfully', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'Hello world',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.txt',
        operations: {
          beforeText: 'Hello',
          afterText: 'world',
          newText: ' beautiful ',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('Hello beautiful world')
    })

    it('should handle multiple operations successfully', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'function test() {\n  return 42;\n}',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.ts',
        operations: [
          {
            beforeText: 'function test() {',
            afterText: '\n  return 42;',
            newText: '\n  console.log("debug");',
          },
          {
            beforeText: 'return 42;',
            afterText: '\n}',
            newText: '\n\n',
          },
        ],
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('function test() {\n  console.log("debug");\n  return 42;\n\n\n}')
    })

    it('should handle start of file marker', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'export const value = 42;',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.ts',
        operations: {
          beforeText: '<<<START_OF_FILE>>>',
          afterText: 'export',
          newText: '// Header comment\n',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('// Header comment\nexport const value = 42;')
    })

    it('should handle end of file marker', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'export const value = 42;',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.ts',
        operations: {
          beforeText: 'value = 42;',
          afterText: '<<<END_OF_FILE>>>',
          newText: '\n// Footer comment',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('export const value = 42;\n// Footer comment')
    })

    it('should handle entire file replacement', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'old content',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.txt',
        operations: {
          beforeText: '<<<START_OF_FILE>>>',
          afterText: '<<<END_OF_FILE>>>',
          newText: 'completely new content',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('completely new content')
    })

    it('should return error when text not found', async () => {
      const provider = createProvider('Hello world')
      const args = {
        path: 'test.txt',
        operations: {
          beforeText: 'missing',
          afterText: 'text',
          newText: 'replacement',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
    })

    it('should handle insert after beforeText only', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'Hello world',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.txt',
        operations: {
          beforeText: 'Hello',
          newText: ' beautiful',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('Hello beautiful world')
    })

    it('should handle insert before afterText only', async () => {
      let writtenContent = ''
      const provider: FilesystemProvider = {
        readFile: async () => 'Hello world',
        writeFile: async (path, content) => {
          writtenContent = content
        },
      }
      const args = {
        path: 'test.txt',
        operations: {
          afterText: 'world',
          newText: 'beautiful ',
        },
      }

      const result = await handler(provider, args)

      expect(result).toMatchSnapshot()
      expect(writtenContent).toBe('Hello beautiful world')
    })
  })
})
