/**
 * Tool for updating knowledge.ai.yml files with smart merging capabilities
 * Generated by polka.codes
 */
import { join } from 'node:path'
import YAML from 'yaml'
import { type FullToolInfo, PermissionLevel, type ToolHandler, type ToolInfo, ToolResponseType } from '../tool'
import type { FilesystemProvider } from './provider'
import { getString } from './utils'

export const toolInfo = {
  name: 'update_knowledge',
  description:
    'Update knowledge in a knowledge.ai.yml file with smart merging capabilities. This tool lets you add, update, or remove information using path-based updates and special directives.',
  parameters: [
    {
      name: 'path',
      description: 'Directory containing (or where to create) the knowledge.ai.yml file',
      required: true,
      usageValue: 'Directory path here',
    },
    {
      name: 'knowledge',
      description: 'YAML content to merge into the knowledge file',
      required: true,
      usageValue: 'YAML content with knowledge to update',
    },
  ],
  examples: [
    {
      description: 'Add a new file entry',
      parameters: [
        { name: 'path', value: 'src/utils' },
        {
          name: 'knowledge',
          value: `files:
  "newFile.ts":
    description: "A new utility file"
    api:
      functions:
        1:
          name: "processData"
          params:
            1: { name: "data", type: "object" }
          returns: "object"`,
        },
      ],
    },
    {
      description: 'Update an existing file description',
      parameters: [
        { name: 'path', value: 'src/utils' },
        {
          name: 'knowledge',
          value: `files:
  "existingFile.ts":
    description: "Updated description for the file"`,
        },
      ],
    },
    {
      description: 'Add a new rule',
      parameters: [
        { name: 'path', value: 'src' },
        {
          name: 'knowledge',
          value: `rules:
    10: "New rule to follow"`,
        },
      ],
    },
    {
      description: 'Remove a rule',
      parameters: [
        { name: 'path', value: 'src' },
        {
          name: 'knowledge',
          value: `rules:
    5: null`,
        },
      ],
    },
    {
      description: 'Update nested properties using dot notation',
      parameters: [
        { name: 'path', value: 'src/components' },
        {
          name: 'knowledge',
          value: `files.Button.tsx.api.functions.1.description: "Updated function description"`,
        },
      ],
    },
  ],
  permissionLevel: PermissionLevel.Write,
} as const satisfies ToolInfo

/**
 * Find the next available numeric key in a dictionary
 */
function getNextKey(obj: Record<string, any>): number {
  if (!obj || typeof obj !== 'object') return 1

  const numericKeys = Object.keys(obj)
    .filter((key) => !Number.isNaN(Number(key)))
    .map((key) => Number(key))

  if (numericKeys.length === 0) return 1

  return Math.max(...numericKeys) + 1
}

/**
 * Convert an array to a numbered dictionary
 */
function arrayToNumberedDict(arr: any[]): Record<string, any> {
  const result: Record<string, any> = {}
  arr.forEach((item, index) => {
    result[(index + 1).toString()] = item
  })
  return result
}

/**
 * Deep merge two objects with special handling for numbered dictionaries and directives
 */
function deepMerge(target: any, source: any): any {
  // Handle special directives for numbered dictionaries
  if (source && typeof source === 'object') {
    // Convert arrays to numbered dictionaries
    if (Array.isArray(target)) {
      target = arrayToNumberedDict(target)
    }

    if (Array.isArray(source)) {
      source = arrayToNumberedDict(source)
    }

    // Handle $merge directive for dictionaries
    if (typeof target === 'object' && !Array.isArray(target) && '$merge' in source) {
      const result = { ...target }
      const itemsToMerge = Array.isArray(source.$merge) ? source.$merge : [source.$merge]

      for (const item of itemsToMerge) {
        // For objects with 'path' property, find by path
        if (typeof item === 'object' && item !== null && 'path' in item) {
          let found = false

          // Try to find existing item with same path
          for (const key in result) {
            if (typeof result[key] === 'object' && result[key] !== null && 'path' in result[key] && result[key].path === item.path) {
              result[key] = deepMerge(result[key], item)
              found = true
              break
            }
          }

          // If not found, add as new item with next available key
          if (!found) {
            const nextKey = getNextKey(result).toString()
            result[nextKey] = item
          }
        } else {
          // For primitive values, add with next available key
          const nextKey = getNextKey(result).toString()
          result[nextKey] = item
        }
      }

      return result
    }

    // Handle $remove directive for dictionaries
    if (typeof target === 'object' && !Array.isArray(target) && '$remove' in source) {
      const result = { ...target }
      const itemsToRemove = Array.isArray(source.$remove) ? source.$remove : [source.$remove]

      for (const item of itemsToRemove) {
        if (typeof item === 'string' && !Number.isNaN(Number(item))) {
          // If it's a numeric key, remove directly
          delete result[item]
        } else if (typeof item === 'object' && item !== null && 'path' in item) {
          // If it has a path property, find and remove by path
          for (const key in result) {
            if (typeof result[key] === 'object' && result[key] !== null && 'path' in result[key] && result[key].path === item.path) {
              delete result[key]
              break
            }
          }
        } else {
          // For primitive values, find and remove by value
          for (const key in result) {
            if (result[key] === item) {
              delete result[key]
              break
            }
          }
        }
      }

      return result
    }

    // Handle $replace directive for dictionaries
    if (typeof target === 'object' && !Array.isArray(target) && '$replace' in source) {
      const replacements = Array.isArray(source.$replace) ? source.$replace : [source.$replace]
      return arrayToNumberedDict(replacements)
    }
  }

  // Base case: if source is not an object or is null
  if (!source || typeof source !== 'object') {
    return source
  }

  // Base case: if target is not mergeable
  if (!target || typeof target !== 'object') {
    if (Array.isArray(source)) {
      return arrayToNumberedDict(source)
    }
    return { ...source }
  }

  // Handle regular objects (including numbered dictionaries)
  const output = { ...target }

  for (const key in source) {
    // Skip directive keys
    if (key.startsWith('$')) continue

    // Recursively merge nested objects
    output[key] = deepMerge(target[key], source[key])
  }

  return output
}

export const handler: ToolHandler<typeof toolInfo, FilesystemProvider> = async (provider, args) => {
  if (!provider.readFile || !provider.writeFile) {
    return {
      type: ToolResponseType.Error,
      message: 'File operations not available. Cannot update knowledge file.',
    }
  }

  const dirPath = getString(args, 'path')
  const knowledgeContent = getString(args, 'knowledge')

  // Determine the file path
  const filePath = join(dirPath, 'knowledge.ai.yml')

  try {
    // Parse the new knowledge content
    let newKnowledge: any
    try {
      newKnowledge = YAML.parse(knowledgeContent)
    } catch (error) {
      return {
        type: ToolResponseType.Error,
        message: `Invalid YAML content: ${(error as Error).message}`,
      }
    }

    // Extract dot notation updates
    const dotNotationUpdates: Record<string, any> = {}
    const regularUpdates: Record<string, any> = {}

    for (const key in newKnowledge) {
      if (key.includes('.')) {
        dotNotationUpdates[key] = newKnowledge[key]
      } else {
        regularUpdates[key] = newKnowledge[key]
      }
    }

    // Read existing knowledge file if it exists
    const existingContent = await provider.readFile(filePath)
    let existingKnowledge: any = {}

    if (existingContent) {
      try {
        existingKnowledge = YAML.parse(existingContent)
      } catch (error) {
        return {
          type: ToolResponseType.Error,
          message: `Error parsing existing knowledge file: ${(error as Error).message}`,
        }
      }
    }

    // Apply updates
    let updatedKnowledge = existingKnowledge

    // First apply regular updates
    updatedKnowledge = deepMerge(updatedKnowledge, regularUpdates)

    // Then apply dot notation updates
    if (Object.keys(dotNotationUpdates).length > 0) {
      // Convert dot notation paths to nested objects first
      const nestedUpdates: Record<string, any> = {}

      for (const path in dotNotationUpdates) {
        const parts = path.split('.')
        let current = nestedUpdates

        // Build the nested structure
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i]
          if (!(part in current)) {
            current[part] = {}
          }
          current = current[part]
        }

        // Set the value at the leaf
        current[parts[parts.length - 1]] = dotNotationUpdates[path]
      }

      // Merge the nested updates
      updatedKnowledge = deepMerge(updatedKnowledge, nestedUpdates)
    }

    // Write the updated knowledge back to the file
    const updatedContent = YAML.stringify(updatedKnowledge)
    await provider.writeFile(filePath, updatedContent)

    return {
      type: ToolResponseType.Reply,
      message: `<update_knowledge_path>${filePath}</update_knowledge_path><status>Success</status>`,
    }
  } catch (error) {
    return {
      type: ToolResponseType.Error,
      message: `Error updating knowledge file: ${(error as Error).message}`,
    }
  }
}

export const isAvailable = (provider: FilesystemProvider): boolean => {
  return !!provider.readFile && !!provider.writeFile
}

export default {
  ...toolInfo,
  handler,
  isAvailable,
} satisfies FullToolInfo
