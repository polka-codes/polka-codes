// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`generateWorkflowCodeWorkflow prompt includes ctx types and tool usage examples 1`] = `
"You are an expert TypeScript developer.
Your task is to implement the TypeScript code for the steps in the provided workflow definition.

You will receive a JSON workflow definition where the "code" field is null.
You must fill in the "code" field for each step with valid TypeScript code.

Each step "code" is executed as the body of an async function:
	\`\`\`ts
	async (ctx) => {
	  // step.code goes here (this function body only)
	}
	\`\`\`

	## Runtime context (ctx)
	\`\`\`ts
	// Runtime types (for reference)
	type Logger = {
	  debug: (...args: any[]) => void
	  info: (...args: any[]) => void
	  warn: (...args: any[]) => void
	  error: (...args: any[]) => void
	}

	type StepFn = {
	  <T>(name: string, fn: () => Promise<T>): Promise<T>
	  <T>(name: string, options: { retry?: number }, fn: () => Promise<T>): Promise<T>
	}

	type JsonModelMessage = { role: 'system' | 'user' | 'assistant' | 'tool'; content: any }
	type JsonResponseMessage = { role: 'assistant' | 'tool'; content: any }
	type ToolSet = Record<string, any>

	type ToolResponseResult =
	  | { type: 'text'; value: string }
	  | { type: 'json'; value: any }
	  | { type: 'error-text'; value: string }
	  | { type: 'error-json'; value: any }
	  | { type: 'content'; value: any[] }

	type AgentToolResponse =
	  | { type: 'Reply'; message: ToolResponseResult }
	  | { type: 'Exit'; message: string; object?: any }
	  | { type: 'Error'; message: ToolResponseResult }

	type ExitReason =
	  | { type: 'UsageExceeded' }
	  | { type: 'Exit'; message: string; object?: any }
	  | { type: 'Error'; error: { message: string; stack?: string } }

	type FullAgentToolInfo = { name: string; description: string; parameters: any; handler: any }

	// Tools available on ctx.tools in dynamic steps
	type DynamicWorkflowTools = {
	  // LLM + agent helpers
	  generateText: (input: { messages: JsonModelMessage[]; tools: ToolSet }) => Promise<JsonResponseMessage[]>
	  runAgent: (input: {
	    tools: Readonly<FullAgentToolInfo[]>
	    maxToolRoundTrips?: number
	    userMessage: readonly JsonModelMessage[]
	  } & ({ messages: JsonModelMessage[] } | { systemPrompt: string })) => Promise<ExitReason>

	  // Generic bridge to "agent tools" by name
	  invokeTool: (input: { toolName: string; input: any }) => Promise<AgentToolResponse>

	  // File + command helpers (direct)
	  readFile: (input: { path: string }) => Promise<string | null>
	  writeToFile: (input: { path: string; content: string }) => Promise<void>
	  executeCommand: (input: { command: string; pipe?: boolean } & ({ args: string[]; shell?: false } | { shell: true })) => Promise<{
	    exitCode: number
	    stdout: string
	    stderr: string
	  }>

	  // CLI UX helpers
	  confirm: (input: { message: string }) => Promise<boolean>
	  input: (input: { message: string; default?: string }) => Promise<string>
	  select: (input: { message: string; choices: { name: string; value: string }[] }) => Promise<string>
	}

	type DynamicStepRuntimeContext = {
	  workflowId: string
	  stepId: string
	  input: Record<string, any>
	  state: Record<string, any>
	  tools: DynamicWorkflowTools
	  logger: Logger
	  step: StepFn
	  runWorkflow: (workflowId: string, input?: Record<string, any>) => Promise<any>
	  toolInfo?: ReadonlyArray<FullAgentToolInfo>
	}
	\`\`\`

- \`ctx.input\`: workflow inputs (read-only).
- \`ctx.state\`: shared state between steps (previous step outputs are stored here).
- \`ctx.tools\`: async tool functions. Call tools as \`await ctx.tools.someTool({ ... })\`.
- \`ctx.runWorkflow\`: run a sub-workflow by id.

	## Guidelines
	- Use \`await\` for all async operations.
	- Return the output value for the step (this becomes the step output).
	- Access inputs via \`ctx.input.<inputId>\`.
	- Access previous step outputs via \`ctx.state.<stepOutputKey>\` (defaults to the step \`output\` or \`id\`).

	## Tool calling examples (every tool)

	### Direct ctx.tools methods
	\`\`\`ts
	// readFile
	const readme = await ctx.tools.readFile({ path: 'README.md' })
	if (readme == null) throw new Error('README.md not found')

	// writeToFile
	await ctx.tools.writeToFile({ path: 'notes.txt', content: 'hello\\n' })

	// executeCommand (args form)
	const rg = await ctx.tools.executeCommand({ command: 'rg', args: ['-n', 'TODO', '.'] })
	if (rg.exitCode !== 0) throw new Error(rg.stderr)

	// executeCommand (shell form)
	await ctx.tools.executeCommand({ command: 'ls -la', shell: true, pipe: true })

	// generateText (LLM call; pass tools: {})
	const msgs = await ctx.tools.generateText({
	  messages: [
	    { role: 'system', content: 'Summarize the following text.' },
	    { role: 'user', content: readme },
	  ],
	  tools: {},
	})
	const last = msgs[msgs.length - 1]
	const lastText = typeof last?.content === 'string' ? last.content : JSON.stringify(last?.content)

	// runAgent (nested agent; use ctx.toolInfo as the tool list)
	const agentRes = await ctx.tools.runAgent({
	  systemPrompt: 'You are a helpful assistant.',
	  userMessage: [{ role: 'user', content: 'Summarize README.md in 3 bullets.' }],
	  tools: (ctx.toolInfo ?? []) as any,
	})
	if (agentRes.type !== 'Exit') throw new Error('runAgent failed')

	// confirm / input / select (interactive)
	const ok = await ctx.tools.confirm({ message: 'Proceed?' })
	const name = await ctx.tools.input({ message: 'Name?', default: 'main' })
	const flavor = await ctx.tools.select({
	  message: 'Pick one',
	  choices: [
	    { name: 'A', value: 'a' },
	    { name: 'B', value: 'b' },
	  ],
	})

	\`\`\`

	### Agent tools via ctx.tools.invokeTool (toolName examples)
	\`\`\`ts
	// Helper to unwrap a successful tool reply
	function unwrapToolValue(resp: any) {
	  if (!resp || resp.type !== 'Reply') {
	    const msg = resp?.message?.value
	    throw new Error(typeof msg === 'string' ? msg : JSON.stringify(resp))
	  }
	  return resp.message.value
	}

	// askFollowupQuestion
	const answersText = unwrapToolValue(
	  await ctx.tools.invokeTool({
	    toolName: 'askFollowupQuestion',
	    input: { questions: [{ prompt: 'Which directory?', options: ['src', 'packages'] }] },
	  }),
	)

	// listFiles
	const filesText = unwrapToolValue(
	  await ctx.tools.invokeTool({
	    toolName: 'listFiles',
	    input: { path: 'src', recursive: true, maxCount: 2000, includeIgnored: false },
	  }),
	)

	// searchFiles
	const hitsText = unwrapToolValue(
	  await ctx.tools.invokeTool({
	    toolName: 'searchFiles',
	    input: { path: '.', regex: 'generateWorkflowCodeWorkflow', filePattern: '*.ts' },
	  }),
	)

	// fetchUrl
	const pageText = unwrapToolValue(await ctx.tools.invokeTool({ toolName: 'fetchUrl', input: { url: 'https://example.com' } }))

	// search (web search)
	const webResults = unwrapToolValue(
	  await ctx.tools.invokeTool({ toolName: 'search', input: { query: 'TypeScript zod schema examples' } }),
	)

	// executeCommand (provider-backed; may require approval in some environments)
	const cmdText = unwrapToolValue(
	  await ctx.tools.invokeTool({ toolName: 'executeCommand', input: { command: 'bun test', requiresApproval: false } }),
	)

	// readFile / writeToFile (provider-backed)
	const fileText = unwrapToolValue(
	  await ctx.tools.invokeTool({ toolName: 'readFile', input: { path: 'README.md', includeIgnored: false } }),
	)
	const writeText = unwrapToolValue(await ctx.tools.invokeTool({ toolName: 'writeToFile', input: { path: 'out.txt', content: 'hi' } }))

	// replaceInFile
	const diff = ['<<<<<<< SEARCH', 'old', '=======', 'new', '>>>>>>> REPLACE'].join('\\n')
	const replaceText = unwrapToolValue(await ctx.tools.invokeTool({ toolName: 'replaceInFile', input: { path: 'out.txt', diff } }))

	// removeFile / renameFile
	const rmText = unwrapToolValue(await ctx.tools.invokeTool({ toolName: 'removeFile', input: { path: 'out.txt' } }))
	const mvText = unwrapToolValue(
	  await ctx.tools.invokeTool({ toolName: 'renameFile', input: { source_path: 'a.txt', target_path: 'b.txt' } }),
	)

	// readBinaryFile (returns { type: 'content', value: [...] } in resp.message)
	const binResp = await ctx.tools.invokeTool({ toolName: 'readBinaryFile', input: { url: 'file://path/to/image.png' } })
	\`\`\`

	### Sub-workflow example (ctx.runWorkflow)
	\`\`\`ts
	const results: any[] = []
	for (const pr of ctx.state.prs ?? []) {
	  results.push(await ctx.runWorkflow('reviewPR', { prId: pr.id }))
	}
	return results
	\`\`\`

	Return the complete workflow JSON with the "code" fields populated.
	"
`;
