// generated by polka.codes

import { describe, expect, test } from 'bun:test'
import { dslStepSpecHandler, type DslStepSpec } from './dsl'
import { combineHandlers, customStepSpecHandler } from './steps'
import type { CustomStepSpec, StepRunResult, WorkflowContext } from './types'

describe('dsl workflow handler', () => {
  const context: WorkflowContext = { provider: {}, parameters: {} }
  const rootHandler = combineHandlers(dslStepSpecHandler, customStepSpecHandler)
  const createRunnable = (step: DslStepSpec) => rootHandler(step, (subStep, rh) => rootHandler(subStep, rh))

  test('should execute steps sequentially', async () => {
    const firstStep: CustomStepSpec = {
      id: 'first',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: (input.value as number) + 1 },
      }),
    }

    const secondStep: CustomStepSpec = {
      id: 'second',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: (input.value as number) * 2 },
      }),
    }

    const step: DslStepSpec = {
      id: 'dsl',
      type: 'dsl',
      script: `
call first
call second
return current
`,
      steps: [firstStep, secondStep],
    }

    const runnable = createRunnable(step)
    const result = await runnable.run({ value: 2, $: {} }, context)
    expect(result).toEqual({ type: 'success', output: { value: 6 } })
  })

  test('should support branching logic', async () => {
    const decide: CustomStepSpec = {
      id: 'decide',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: input.value, shouldDouble: (input.value as number) > 1 },
      }),
    }
    const double: CustomStepSpec = {
      id: 'double',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: (input.value as number) * 2 },
      }),
    }
    const increment: CustomStepSpec = {
      id: 'increment',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: (input.value as number) + 1 },
      }),
    }

    const step: DslStepSpec = {
      id: 'branch',
      type: 'dsl',
      script: `
call decide
if current.shouldDouble:
  call double
else:
  call increment
return current
`,
      steps: [decide, double, increment],
    }

    const runnable = createRunnable(step)
    const trueResult = await runnable.run({ value: 2, $: {} }, context)
    expect(trueResult).toEqual({ type: 'success', output: { value: 4 } })

    const falseResult = await runnable.run({ value: 1, $: {} }, context)
    expect(falseResult).toEqual({ type: 'success', output: { value: 2 } })
  })

  test('should support loops and assignments', async () => {
    const increment: CustomStepSpec = {
      id: 'increment',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: (input.value as number) + 1 },
      }),
    }

    const step: DslStepSpec = {
      id: 'loop',
      type: 'dsl',
      script: `
assign vars.count = 0
while vars.count < 3:
  call increment
  assign vars.count = vars.count + 1
return current
`,
      steps: [increment],
    }

    const runnable = createRunnable(step)
    const result = await runnable.run({ value: 1, $: {} }, context)
    expect(result).toEqual({ type: 'success', output: { value: 4 } })
  })

  test('should expose previous outputs in expressions', async () => {
    const first: CustomStepSpec = {
      id: 'first',
      type: 'custom',
      run: async () => ({ type: 'success', output: { value: 3 } }),
    }
    const second: CustomStepSpec = {
      id: 'second',
      type: 'custom',
      run: async (input: Record<string, any>) => ({
        type: 'success',
        output: { value: (input.value as number) + 1 },
      }),
    }

    const step: DslStepSpec = {
      id: 'outputs',
      type: 'dsl',
      script: `
call first
call second
assign current.total = outputs.first.value + outputs.second.value
return current
`,
      steps: [first, second],
    }

    const runnable = createRunnable(step)
    const result = await runnable.run({ value: 2, $: {} }, context)
    expect(result).toEqual({ type: 'success', output: { value: 4, total: 7 } })
  })

  test('should pause and resume when an inner step pauses', async () => {
    const pausing: CustomStepSpec = {
      id: 'pausing',
      type: 'custom',
      run: async (_input: Record<string, any>, _ctx: WorkflowContext, state?: any): Promise<StepRunResult<any>> => {
        if (!state) {
          return { type: 'paused', state: { resume: true } }
        }
        return { type: 'success', output: { value: 42 } }
      },
    }

    const step: DslStepSpec = {
      id: 'pause-root',
      type: 'dsl',
      script: `
call pausing
return current
`,
      steps: [pausing],
    }

    const runnable = createRunnable(step)
    const paused = await runnable.run({ value: 1, $: {} }, context)
    expect(paused.type).toBe('paused')
    const state = (paused as any).state
    expect(state.__dslState).toBe(true)

    const resumed = await runnable.run({ value: 1, $: {} }, context, state)
    expect(resumed).toEqual({ type: 'success', output: { value: 42 } })
  })
})

