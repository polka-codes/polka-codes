// generated by polka.codes
import { describe, expect, spyOn, test } from 'bun:test'
import { z } from 'zod'
import { type CommandStepSpec, commandStepSpecHandler } from './command'
import type { WorkflowContext } from './types'

describe('commandStepSpecHandler', () => {
  const rootHandler = () => ({}) as any
  const emptySchema = z.object({}).passthrough()
  const baseStep: Pick<CommandStepSpec, 'inputSchema' | 'outputSchema'> = {
    inputSchema: emptySchema as any,
    outputSchema: emptySchema as any,
  }

  test('should execute a simple command', async () => {
    const step: CommandStepSpec = {
      ...baseStep,
      id: 'test',
      type: 'command',
      command: ['echo', 'hello'],
    }
    const context: WorkflowContext = {
      provider: {
        executeCommand: async () => ({ stdout: 'hello', stderr: '', exitCode: 0 }),
      },
      parameters: {},
    }
    const executeCommandSpy = spyOn(context.provider, 'executeCommand')
    const handler = commandStepSpecHandler.handler(step, rootHandler)
    const result = await handler.run({ $: {} }, context)

    expect(executeCommandSpy).toHaveBeenCalledWith(`echo hello`, false)
    expect(result).toEqual({ type: 'success', output: {} })
  })

  test('should resolve templated arguments', async () => {
    const step: CommandStepSpec = {
      ...baseStep,
      id: 'test',
      type: 'command',
      command: ['echo', { type: 'template', template: '<%= message %>' }],
    }
    const context: WorkflowContext = {
      provider: {
        executeCommand: async () => ({ stdout: 'hello world', stderr: '', exitCode: 0 }),
      },
      parameters: {},
    }
    const executeCommandSpy = spyOn(context.provider, 'executeCommand')
    const handler = commandStepSpecHandler.handler(step, rootHandler)
    await handler.run({ message: 'hello world', $: {} }, context)
    expect(executeCommandSpy).toHaveBeenCalledWith(`echo "hello world"`, false)
  })

  test('should return specified outputs', async () => {
    const step: CommandStepSpec = {
      ...baseStep,
      id: 'test',
      type: 'command',
      command: ['echo', 'hello'],
      outputs: ['stdout', 'exitCode'],
    }
    const context: WorkflowContext = {
      provider: {
        executeCommand: async () => ({ stdout: 'hello', stderr: '', exitCode: 0 }),
      },
      parameters: {},
    }
    const handler = commandStepSpecHandler.handler(step, rootHandler)
    const result = await handler.run({ $: {} }, context)
    expect(result).toEqual({
      type: 'success',
      output: { stdout: 'hello', exitCode: 0 },
    })
  })

  test('should handle errors from executeCommand', async () => {
    const step: CommandStepSpec = {
      ...baseStep,
      id: 'test',
      type: 'command',
      command: ['echo', 'hello'],
    }
    const error = new Error('command failed')
    const context: WorkflowContext = {
      provider: {
        executeCommand: async () => {
          throw error
        },
      },
      parameters: {},
    }
    const handler = commandStepSpecHandler.handler(step, rootHandler)
    const result = await handler.run({ $: {} }, context)
    expect(result).toEqual({ type: 'error', error })
  })

  test('should handle missing executeCommand in provider', async () => {
    const step: CommandStepSpec = {
      ...baseStep,
      id: 'test',
      type: 'command',
      command: ['echo', 'hello'],
    }
    const context: WorkflowContext = {
      provider: {},
      parameters: {},
    }
    const handler = commandStepSpecHandler.handler(step, rootHandler)
    const result = await handler.run({ $: {} }, context)
    expect(result.type).toBe('error')
    expect((result as any).error).toBeInstanceOf(Error)
    expect((result as any).error.message).toBe('executeCommand is not available in the provider')
  })
})
