// generated by polka.codes
import { describe, expect, spyOn, test } from 'bun:test'
import { z } from 'zod'
import { combineHandlers, customStepSpecHandler, sequentialStepSpecHandler } from './steps'
import type { CustomStepSpec, SequentialStepSpec, StepSpecHandlerFn, WorkflowContext, WorkflowSpec } from './types'
import { resume, run } from './workflow'

describe('workflow', () => {
  const mockContext: WorkflowContext = { provider: {}, parameters: {} }
  const mockWorkflow: WorkflowSpec<any, any, CustomStepSpec> = {
    name: 'test-workflow',
    description: 'A test workflow',
    step: {
      id: 'root',
      type: 'custom',
      inputSchema: z.object({}),
      outputSchema: z.object({}),
      run: async () => ({ type: 'success', output: {} }),
    },
  }

  describe('run', () => {
    test('should call the root step handler and return success', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({ result: z.string() }),
        run: async () => ({ type: 'success' as const, output: { result: 'SUCCESS' } }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const runSpy = spyOn(rootStep, 'run')

      const result = await run(mockWorkflow, mockContext, handler, { value: 'test' })

      expect(runSpy).toHaveBeenCalledWith({ value: 'test', $: {} }, mockContext, undefined)
      expect(result).toEqual({ type: 'success', output: { result: 'SUCCESS' } })
    })

    test('should handle error results', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({}),
        run: async () => ({ type: 'error' as const, error: 'FAILURE' }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await run(mockWorkflow, mockContext, handler, { value: 'test' })
      expect(result.type).toBe('error')
    })

    test('should handle paused results', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({}),
        run: async () => ({ type: 'paused' as const, state: 'PAUSED_STATE' }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await run(mockWorkflow, mockContext, handler, { value: 'test' })
      expect(result).toEqual({ type: 'paused', state: 'PAUSED_STATE' })
    })
  })

  describe('resume', () => {
    test('should call the root step handler with resumed state', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({ result: z.string() }),
        run: async () => ({ type: 'success' as const, output: { result: 'SUCCESS' } }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const runSpy = spyOn(rootStep, 'run')

      await resume(mockWorkflow, mockContext, handler, 'RESUMED_STATE', { value: 'new-test' })

      expect(runSpy).toHaveBeenCalledWith({ value: 'new-test', $: {} }, mockContext, 'RESUMED_STATE')
    })

    test('should return success on resume', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (resumedState) {
            return { type: 'success' as const, output: { result: 'RESUMED_SUCCESS' } }
          }
          return { type: 'paused' as const, state: 'PAUSED' }
        },
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await resume(mockWorkflow, mockContext, handler, 'PAUSED', {})
      expect(result).toEqual({ type: 'success', output: { result: 'RESUMED_SUCCESS' } })
    })

    test('should return error on resume', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (resumedState) {
            return { type: 'error' as const, error: 'RESUMED_FAILURE' }
          }
          return { type: 'paused' as const, state: 'PAUSED' }
        },
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await resume(mockWorkflow, mockContext, handler, 'PAUSED', {})
      expect(result).toEqual({ type: 'error', error: 'RESUMED_FAILURE' })
    })

    test('should return paused on resume', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (resumedState === 'PAUSED_1') {
            return { type: 'paused' as const, state: 'PAUSED_2' }
          }
          return { type: 'paused' as const, state: 'PAUSED_1' }
        },
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await resume(mockWorkflow, mockContext, handler, 'PAUSED_1', {})
      expect(result).toEqual({ type: 'paused', state: 'PAUSED_2' })
    })
  })

  describe('sequential workflow', () => {
    const handler = combineHandlers(sequentialStepSpecHandler, customStepSpecHandler)

    test('a step should be able to access the output of a previous step', async () => {
      const workflow: WorkflowSpec = {
        name: 'test-sequential',
        step: {
          id: 'seq',
          type: 'sequential',
          inputSchema: z.object({}),
          outputSchema: z.object({ final: z.string() }),
          steps: [
            {
              id: 'step1',
              type: 'custom',
              inputSchema: z.object({}),
              outputSchema: z.object({ message: z.string() }),
              run: async () => ({ type: 'success', output: { message: 'hello' } }),
            } as CustomStepSpec,
            {
              id: 'step2',
              type: 'custom',
              inputSchema: z.object({ message: z.string() }),
              outputSchema: z.object({ final: z.string() }),
              run: async (input: any) => ({ type: 'success', output: { final: `${input.message} world` } }),
            } as CustomStepSpec,
          ],
        } as any,
      }
      const result = await run(workflow, mockContext, handler, {})
      expect(result).toEqual({ type: 'success', output: { final: 'hello world' } })
    })

    test('a step should be able to access the output of a previous step using $. syntax', async () => {
      const workflow: WorkflowSpec<any, any, SequentialStepSpec<any, any, CustomStepSpec>> = {
        name: 'test-sequential-ref',
        step: {
          id: 'seq',
          type: 'sequential',
          inputSchema: z.object({}),
          outputSchema: z.object({ final: z.string() }),
          steps: [
            {
              id: 'step1',
              type: 'custom',
              outputSchema: z.object({ message: z.string() }),
              run: async () => ({ type: 'success', output: { message: 'hello' } }),
            },
            {
              id: 'step2_input_builder',
              type: 'custom',
              outputSchema: z.object({ fromStep1: z.string() }),
              run: async (input) => ({ type: 'success', output: { fromStep1: input.$.step1.message } }),
            },
            {
              id: 'step2',
              type: 'custom',
              inputSchema: z.object({ fromStep1: z.string() }),
              outputSchema: z.object({ final: z.string() }),
              run: async (input) => ({ type: 'success', output: { final: `${input.fromStep1} world` } }),
            },
          ],
        },
      }
      const result = await run(workflow, mockContext, handler, {})
      expect(result).toEqual({ type: 'success', output: { final: 'hello world' } })
    })
  })
})
