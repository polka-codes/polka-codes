// generated by polka.codes
import { describe, expect, spyOn, test } from 'bun:test'
import { z } from 'zod'
import { combineHandlers, customStepSpecHandler, sequentialStepSpecHandler, workflowStepSpecHandler } from './steps'
import type { CustomStepSpec, SequentialStepSpec, StepSpecHandlerFn, WorkflowContext, WorkflowSpec, WorkflowStepSpec } from './types'
import { resume, run } from './workflow'

describe('workflow', () => {
  const mockContext: WorkflowContext = { provider: {}, parameters: {} }
  const mockWorkflow: WorkflowSpec<any, any> = {
    name: 'test-workflow',
    description: 'A test workflow',
    step: {
      id: 'root',
      type: 'custom',
      inputSchema: z.object({}),
      outputSchema: z.object({}),
      run: async () => ({ type: 'success', output: {} }),
    } as CustomStepSpec,
  }

  describe('run', () => {
    test('should call the root step handler and return success', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({ result: z.string() }),
        run: async () => ({ type: 'success' as const, output: { result: 'SUCCESS' } }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const runSpy = spyOn(rootStep, 'run')

      const result = await run(mockWorkflow, mockContext, handler, { value: 'test' })

      expect(runSpy).toHaveBeenCalledWith({ value: 'test', $: {} }, mockContext, undefined)
      expect(result).toEqual({ type: 'success', output: { result: 'SUCCESS' } })
    })

    test('should handle error results', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({}),
        run: async () => ({ type: 'error' as const, error: 'FAILURE' }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await run(mockWorkflow, mockContext, handler, { value: 'test' })
      expect(result.type).toBe('error')
    })

    test('should handle paused results', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({}),
        run: async () => ({ type: 'paused' as const, state: 'PAUSED_STATE' }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await run(mockWorkflow, mockContext, handler, { value: 'test' })
      expect(result).toEqual({ type: 'paused', state: 'PAUSED_STATE' })
    })
  })

  describe('resume', () => {
    test('should call the root step handler with resumed state', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        inputSchema: z.object({ value: z.string() }),
        outputSchema: z.object({ result: z.string() }),
        run: async () => ({ type: 'success' as const, output: { result: 'SUCCESS' } }),
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const runSpy = spyOn(rootStep, 'run')

      await resume(mockWorkflow, mockContext, handler, 'RESUMED_STATE', { value: 'new-test' })

      expect(runSpy).toHaveBeenCalledWith({ value: 'new-test', $: {} }, mockContext, 'RESUMED_STATE')
    })

    test('should return success on resume', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (resumedState) {
            return { type: 'success' as const, output: { result: 'RESUMED_SUCCESS' } }
          }
          return { type: 'paused' as const, state: 'PAUSED' }
        },
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await resume(mockWorkflow, mockContext, handler, 'PAUSED', {})
      expect(result).toEqual({ type: 'success', output: { result: 'RESUMED_SUCCESS' } })
    })

    test('should return error on resume', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (resumedState) {
            return { type: 'error' as const, error: 'RESUMED_FAILURE' }
          }
          return { type: 'paused' as const, state: 'PAUSED' }
        },
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await resume(mockWorkflow, mockContext, handler, 'PAUSED', {})
      expect(result).toEqual({ type: 'error', error: 'RESUMED_FAILURE' })
    })

    test('should return paused on resume', async () => {
      const rootStep = {
        id: 'root',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (resumedState === 'PAUSED_1') {
            return { type: 'paused' as const, state: 'PAUSED_2' }
          }
          return { type: 'paused' as const, state: 'PAUSED_1' }
        },
      }
      const handler: StepSpecHandlerFn<any, any> = () => rootStep
      const result = await resume(mockWorkflow, mockContext, handler, 'PAUSED_1', {})
      expect(result).toEqual({ type: 'paused', state: 'PAUSED_2' })
    })
  })

  describe('sequential workflow', () => {
    const handler = combineHandlers(sequentialStepSpecHandler, customStepSpecHandler)

    test('a step should be able to access the output of a previous step', async () => {
      const workflow: WorkflowSpec<any, any> = {
        name: 'test-sequential',
        step: {
          id: 'seq',
          type: 'sequential',
          inputSchema: z.object({}),
          outputSchema: z.object({ final: z.string() }),
          steps: [
            {
              id: 'step1',
              type: 'custom',
              inputSchema: z.object({}),
              outputSchema: z.object({ message: z.string() }),
              run: async () => ({ type: 'success', output: { message: 'hello' } }),
            },
            {
              id: 'step2',
              type: 'custom',
              inputSchema: z.object({ message: z.string() }),
              outputSchema: z.object({ final: z.string() }),
              run: async (input: { message: string }) => ({ type: 'success', output: { final: `${input.message} world` } }),
            },
          ],
        } as SequentialStepSpec<any, any, CustomStepSpec>,
      }
      const result = await run(workflow, mockContext, handler, {})
      expect(result).toEqual({ type: 'success', output: { final: 'hello world' } })
    })

    test('a step should be able to access the output of a previous step using $. syntax', async () => {
      const workflow: WorkflowSpec<any, any> = {
        name: 'test-sequential-ref',
        step: {
          id: 'seq',
          type: 'sequential',
          inputSchema: z.object({}),
          outputSchema: z.object({ final: z.string() }),
          steps: [
            {
              id: 'step1',
              type: 'custom',
              outputSchema: z.object({ message: z.string() }),
              run: async () => ({ type: 'success', output: { message: 'hello' } }),
            },
            {
              id: 'step2_input_builder',
              type: 'custom',
              outputSchema: z.object({ fromStep1: z.string() }),
              run: async (input: { $: { step1: { message: string } } }) => ({
                type: 'success',
                output: { fromStep1: input.$.step1.message },
              }),
            },
            {
              id: 'step2',
              type: 'custom',
              inputSchema: z.object({ fromStep1: z.string() }),
              outputSchema: z.object({ final: z.string() }),
              run: async (input: { fromStep1: string }) => ({ type: 'success', output: { final: `${input.fromStep1} world` } }),
            },
          ],
        } as SequentialStepSpec<any, any, CustomStepSpec>,
      }
      const result = await run(workflow, mockContext, handler, {})
      expect(result).toEqual({ type: 'success', output: { final: 'hello world' } })
    })
  })

  describe('nested workflows', () => {
    const handler = combineHandlers(sequentialStepSpecHandler, customStepSpecHandler, workflowStepSpecHandler)

    test('runs a nested workflow step', async () => {
      const childWorkflow: WorkflowSpec<{ childValue: number }, { doubled: number }> = {
        name: 'child',
        step: {
          id: 'child-step',
          type: 'custom',
          run: async (input: { childValue: number }) => ({
            type: 'success' as const,
            output: { doubled: input.childValue * 2 },
          }),
        } as CustomStepSpec<{ childValue: number }, { doubled: number }>,
      }

      let observedWorkflowInput: number | undefined
      const workflow: WorkflowSpec<{ value: number }, { total: number }> = {
        name: 'parent',
        step: {
          id: 'child-runner',
          type: 'workflow',
          workflow: childWorkflow,
          mapInput: (input: { value: number }) => ({ childValue: input.value }),
          mapOutput: ({
            workflowInput,
            workflowOutput,
          }: {
            workflowInput: { childValue: number }
            workflowOutput: { doubled: number }
          }) => {
            observedWorkflowInput = workflowInput.childValue
            return { total: workflowOutput.doubled }
          },
        } as WorkflowStepSpec<{ value: number }, { childValue: number }, { doubled: number }, { total: number }>,
      }

      const context: WorkflowContext = { provider: {}, parameters: { nested: true } }
      const result = await run(workflow, context, handler, { value: 4 })

      expect(result).toEqual({ type: 'success', output: { total: 8 } })
      expect(observedWorkflowInput).toBe(4)
    })

    test('pauses and resumes a nested workflow while keeping context', async () => {
      const childContexts: WorkflowContext[] = []
      const childWorkflow: WorkflowSpec<{ childValue: number }, { doubled: number }> = {
        name: 'child',
        step: {
          id: 'child-step',
          type: 'custom',
          run: async (input: { childValue: number }, ctx, resumedState?: any) => {
            childContexts.push(ctx)
            if (!resumedState) {
              return { type: 'paused' as const, state: { attempt: input.childValue } }
            }
            return { type: 'success' as const, output: { doubled: input.childValue * 2 } }
          },
        } as CustomStepSpec<{ childValue: number }, { doubled: number }>,
      }

      let observedWorkflowInput: number | undefined
      const workflow: WorkflowSpec<{ value: number }, { total: number }> = {
        name: 'parent',
        step: {
          id: 'child-runner',
          type: 'workflow',
          workflow: childWorkflow,
          mapInput: (input: { value: number }) => ({ childValue: input.value }),
          mapOutput: ({
            workflowInput,
            workflowOutput,
          }: {
            workflowInput: { childValue: number }
            workflowOutput: { doubled: number }
          }) => {
            observedWorkflowInput = workflowInput.childValue
            return { total: workflowOutput.doubled }
          },
        } as WorkflowStepSpec<{ value: number }, { childValue: number }, { doubled: number }, { total: number }>,
      }

      const context: WorkflowContext = { provider: {}, parameters: { nested: true } }
      const first = await run(workflow, context, handler, { value: 2 })
      expect(first.type).toBe('paused')
      const pausedState = (first as any).state
      expect(pausedState.workflowState).toEqual({ attempt: 2 })

      const resumed = await resume(workflow, context, handler, pausedState, { value: 5 })
      expect(resumed).toEqual({ type: 'success', output: { total: 10 } })
      expect(observedWorkflowInput).toBe(5)
      expect(childContexts).toHaveLength(2)
      expect(childContexts[0]).toBe(context)
      expect(childContexts[1]).toBe(context)
    })
  })
})
