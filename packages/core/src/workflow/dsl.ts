// generated by polka.codes

import type { BaseStepSpec, Json, StepRunResult, StepSpecHandler, StepSpecRaw, WorkflowContext } from './types'
import { runStep } from './runStep'

type ExpressionFn = (
  input: Record<string, Json>,
  current: Record<string, Json>,
  outputs: Record<string, Record<string, Json>>,
  vars: Record<string, Json>,
  context: WorkflowContext,
) => any

type AssignStatement = {
  type: 'assign'
  target: string[]
  evaluate: ExpressionFn
}

type CallStatement = {
  type: 'call'
  stepId: string
}

type IfStatement = {
  type: 'if'
  evaluate: ExpressionFn
  thenBranch: Statement[]
  elseBranch?: Statement[]
}

type WhileStatement = {
  type: 'while'
  evaluate: ExpressionFn
  body: Statement[]
}

type ReturnStatement = {
  type: 'return'
  evaluate?: ExpressionFn
}

type Statement = AssignStatement | CallStatement | IfStatement | WhileStatement | ReturnStatement

type RuntimeFrame =
  | { type: 'block'; statements: Statement[]; index: number }
  | { type: 'loop'; statements: Statement[]; index: number; evaluate: ExpressionFn }

type CallState = { stepId: string; state: any }

export type DslRuntimeState = {
  __dslState: true
  statements: Statement[]
  frames: RuntimeFrame[]
  current: Record<string, Json>
  initialInput: Record<string, Json>
  parentOutputs: Record<string, Record<string, Json>>
  outputs: Record<string, Record<string, Json>>
  vars: Record<string, Json>
  callState?: CallState
}

const ensureRecord = (value: any, errorMessage: string): Record<string, Json> => {
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    throw new Error(errorMessage)
  }
  return value as Record<string, Json>
}

const ensureJson = (value: any): Json => {
  if (
    value === null ||
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  ) {
    return value as Json
  }

  if (Array.isArray(value)) {
    return value.map((item) => ensureJson(item)) as Json
  }

  if (typeof value === 'object') {
    const result: Record<string, Json> = {}
    for (const [key, entry] of Object.entries(value)) {
      result[key] = ensureJson(entry)
    }
    return result
  }

  throw new Error('DSL expression must evaluate to a JSON-compatible value')
}

const cloneJson = <T extends Record<string, Json>>(value: T): T => {
  if (typeof structuredClone === 'function') {
    return structuredClone(value)
  }
  return JSON.parse(JSON.stringify(value))
}

const cloneOutputs = (outputs: Record<string, Record<string, Json>>): Record<string, Record<string, Json>> => {
  const result: Record<string, Record<string, Json>> = {}
  for (const [key, value] of Object.entries(outputs)) {
    result[key] = cloneJson(value)
  }
  return result
}

const compileExpression = (expression: string, line: number): ExpressionFn => {
  try {
    // eslint-disable-next-line no-new-func
    const fn = new Function(
      'input',
      'current',
      'outputs',
      'vars',
      'context',
      `return (${expression});`,
    ) as ExpressionFn
    return fn
  } catch (error) {
    throw new Error(`Failed to compile DSL expression on line ${line}: ${(error as Error).message}`)
  }
}

type ParseFrame = {
  indent: number
  statements: Statement[]
  pending?: { type: 'then' | 'else' | 'body'; statement: IfStatement | WhileStatement }
}

const INDENT_SIZE = 2

const parseTarget = (rawTarget: string, line: number): string[] => {
  const parts = rawTarget.split('.').map((part) => part.trim()).filter(Boolean)
  if (parts.length === 0) {
    throw new Error(`Invalid assignment target on line ${line}`)
  }
  const [root] = parts
  if (root !== 'current' && root !== 'vars') {
    throw new Error(`Assignments must target either "current" or "vars" on line ${line}`)
  }
  return parts
}

const parseDsl = (script: string): Statement[] => {
  const lines = script.split(/\r?\n/)
  const root: Statement[] = []
  const stack: ParseFrame[] = [{ indent: 0, statements: root }]

  const closePendingFrames = (targetIndent: number) => {
    while (stack.length > 1 && targetIndent < stack[stack.length - 1].indent) {
      const frame = stack.pop()
      if (frame?.pending) {
        throw new Error('Expected an indented block for previous statement')
      }
    }
  }

  lines.forEach((rawLine, index) => {
    const lineNumber = index + 1
    if (!rawLine.trim()) {
      return
    }

    const indent = rawLine.length - rawLine.trimStart().length
    if (indent % INDENT_SIZE !== 0) {
      throw new Error(`Invalid indentation on line ${lineNumber}`)
    }

    closePendingFrames(indent)

    const frame = stack[stack.length - 1]

    if (indent > frame.indent) {
      if (!frame.pending) {
        throw new Error(`Unexpected indentation on line ${lineNumber}`)
      }
      const { statement, type } = frame.pending
      let statements: Statement[]
      if (statement.type === 'if') {
        if (type === 'then') {
          statements = statement.thenBranch
        } else {
          statement.elseBranch = []
          statements = statement.elseBranch
        }
      } else {
        statements = statement.body
      }
      stack.push({ indent, statements })
      frame.pending = undefined
    } else if (frame.pending) {
      throw new Error(`Expected an indented block on line ${lineNumber}`)
    }

    const activeFrame = stack[stack.length - 1]
    const trimmed = rawLine.trim()

    const assignMatch = trimmed.match(/^assign\s+([^=]+)=\s*(.+)$/)
    if (assignMatch) {
      const [, targetRaw, expressionRaw] = assignMatch
      activeFrame.statements.push({
        type: 'assign',
        target: parseTarget(targetRaw.trim(), lineNumber),
        evaluate: compileExpression(expressionRaw.trim(), lineNumber),
      })
      return
    }

    const callMatch = trimmed.match(/^call\s+([A-Za-z0-9_-]+)$/)
    if (callMatch) {
      const [, stepId] = callMatch
      activeFrame.statements.push({ type: 'call', stepId })
      return
    }

    const ifMatch = trimmed.match(/^if\s+(.+):$/)
    if (ifMatch) {
      const [, expression] = ifMatch
      const statement: IfStatement = {
        type: 'if',
        evaluate: compileExpression(expression.trim(), lineNumber),
        thenBranch: [],
      }
      activeFrame.statements.push(statement)
      activeFrame.pending = { type: 'then', statement }
      return
    }

    if (trimmed === 'else:') {
      const previous = activeFrame.statements[activeFrame.statements.length - 1]
      if (!previous || previous.type !== 'if' || previous.elseBranch) {
        throw new Error(`Unexpected else without matching if on line ${lineNumber}`)
      }
      activeFrame.pending = { type: 'else', statement: previous }
      return
    }

    const whileMatch = trimmed.match(/^while\s+(.+):$/)
    if (whileMatch) {
      const [, expression] = whileMatch
      const statement: WhileStatement = {
        type: 'while',
        evaluate: compileExpression(expression.trim(), lineNumber),
        body: [],
      }
      activeFrame.statements.push(statement)
      activeFrame.pending = { type: 'body', statement }
      return
    }

    const returnMatch = trimmed.match(/^return(?:\s+(.+))?$/)
    if (returnMatch) {
      const [, expression] = returnMatch
      activeFrame.statements.push({
        type: 'return',
        evaluate: expression ? compileExpression(expression.trim(), lineNumber) : undefined,
      })
      return
    }

    throw new Error(`Unrecognized DSL statement on line ${lineNumber}: ${trimmed}`)
  })

  closePendingFrames(0)
  if (stack.some((frame) => frame.pending)) {
    throw new Error('Unexpected end of DSL script; missing block body')
  }

  return root
}

const mergeOutputs = (
  parent: Record<string, Record<string, Json>>,
  local: Record<string, Record<string, Json>>,
): Record<string, Record<string, Json>> => {
  if (!parent || Object.keys(parent).length === 0) {
    return { ...local }
  }
  return { ...parent, ...local }
}

const assignValue = (runtime: DslRuntimeState, target: string[], value: Json) => {
  const [root, ...rest] = target
  if (root === 'current') {
    if (rest.length === 0) {
      runtime.current = ensureRecord(value, 'Assigned value to current must be an object')
      return
    }
    let cursor: Record<string, Json> = runtime.current
    for (let index = 0; index < rest.length - 1; index++) {
      const key = rest[index]
      const next = cursor[key]
      if (!next || typeof next !== 'object' || Array.isArray(next)) {
        cursor[key] = {} as Json
      }
      cursor = cursor[key] as Record<string, Json>
    }
    cursor[rest[rest.length - 1]] = value
    return
  }

  if (rest.length === 0) {
    runtime.vars = ensureRecord(value, 'Assigned value to vars must be an object')
    return
  }
  let cursor: Record<string, Json> = runtime.vars
  for (let index = 0; index < rest.length - 1; index++) {
    const key = rest[index]
    const next = cursor[key]
    if (!next || typeof next !== 'object' || Array.isArray(next)) {
      cursor[key] = {} as Json
    }
    cursor = cursor[key] as Record<string, Json>
  }
  cursor[rest[rest.length - 1]] = value
}

const createInitialState = (
  statements: Statement[],
  input: Record<string, Json>,
  parentOutputs: Record<string, Record<string, Json>>,
  initialVars?: Record<string, Json>,
): DslRuntimeState => {
  const inputClone = cloneJson(input)
  return {
    __dslState: true,
    statements,
    frames: [{ type: 'block', statements, index: 0 }],
    current: inputClone,
    initialInput: cloneJson(input),
    parentOutputs: cloneOutputs(parentOutputs),
    outputs: {},
    vars: initialVars ? cloneJson(initialVars) : {},
  }
}

const evaluateExpression = (
  fn: ExpressionFn,
  runtime: DslRuntimeState,
  context: WorkflowContext,
): Json => {
  try {
    const outputs = mergeOutputs(runtime.parentOutputs, runtime.outputs)
    return ensureJson(fn(runtime.initialInput, runtime.current, outputs, runtime.vars, context))
  } catch (error) {
    throw new Error((error as Error).message)
  }
}

const executeStatements = async (
  runtime: DslRuntimeState,
  steps: Record<string, StepSpecRaw>,
  context: WorkflowContext,
): Promise<StepRunResult<Record<string, Json>>> => {
  while (runtime.frames.length > 0) {
    const frame = runtime.frames[runtime.frames.length - 1]

    if (frame.index >= frame.statements.length) {
      if (frame.type === 'loop') {
        const shouldContinue = Boolean(evaluateExpression(frame.evaluate, runtime, context))
        if (shouldContinue) {
          frame.index = 0
          continue
        }
      }
      runtime.frames.pop()
      continue
    }

    const statement = frame.statements[frame.index]

    switch (statement.type) {
      case 'assign': {
        const value = evaluateExpression(statement.evaluate, runtime, context)
        assignValue(runtime, statement.target, value)
        frame.index += 1
        break
      }
      case 'call': {
        const step = steps[statement.stepId]
        if (!step) {
          throw new Error(`Unknown step "${statement.stepId}" in DSL script`)
        }
        const resumedState = runtime.callState?.stepId === step.id ? runtime.callState.state : undefined
        const combinedOutputs = mergeOutputs(runtime.parentOutputs, runtime.outputs)
        const result = await runStep(step, runtime.current, context, resumedState, combinedOutputs)
        if (result.type === 'paused') {
          runtime.callState = { stepId: step.id, state: result.state }
          return { type: 'paused', state: runtime }
        }
        if (result.type === 'error') {
          runtime.callState = undefined
          return result
        }
        runtime.callState = undefined
        runtime.outputs[step.id] = cloneJson(result.output)
        runtime.current = cloneJson(result.output)
        frame.index += 1
        break
      }
      case 'if': {
        const condition = Boolean(evaluateExpression(statement.evaluate, runtime, context))
        frame.index += 1
        if (condition && statement.thenBranch.length > 0) {
          runtime.frames.push({ type: 'block', statements: statement.thenBranch, index: 0 })
        } else if (!condition && statement.elseBranch && statement.elseBranch.length > 0) {
          runtime.frames.push({ type: 'block', statements: statement.elseBranch, index: 0 })
        }
        break
      }
      case 'while': {
        const shouldRun = Boolean(evaluateExpression(statement.evaluate, runtime, context))
        frame.index += 1
        if (shouldRun) {
          runtime.frames.push({ type: 'loop', statements: statement.body, index: 0, evaluate: statement.evaluate })
        }
        break
      }
      case 'return': {
        const output = statement.evaluate
          ? ensureRecord(
              evaluateExpression(statement.evaluate, runtime, context),
              'Return expression must evaluate to an object',
            )
          : runtime.current
        return { type: 'success', output }
      }
    }
  }

  return { type: 'success', output: runtime.current }
}

export interface DslStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'dsl'
  script: string
  steps: BaseStepSpec[]
  variables?: Record<string, Json>
}

export const dslStepSpecHandler: StepSpecHandler = {
  type: 'dsl',
  handler(step, rootHandler) {
    const statements = parseDsl(step.script)
    const runnableSteps = step.steps.reduce<Record<string, StepSpecRaw>>((acc, spec) => {
      const runnable = rootHandler(spec, rootHandler)
      acc[runnable.id] = runnable
      return acc
    }, {})

    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: DslRuntimeState,
      ): Promise<StepRunResult<Record<string, Json>>> {
        const parentOutputs = (input.$ as Record<string, Record<string, Json>> | undefined) ?? {}
        const runtime =
          resumedState && resumedState.__dslState
            ? {
                ...resumedState,
                parentOutputs: cloneOutputs(parentOutputs),
                initialInput: cloneJson(input),
              }
            : createInitialState(statements, input, parentOutputs, step.variables)

        const result = await executeStatements(runtime, runnableSteps, context)
        if (result.type === 'paused') {
          return { type: 'paused', state: runtime }
        }
        return result
      },
    }
  },
}

