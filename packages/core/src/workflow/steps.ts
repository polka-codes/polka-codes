// generated by polka.codes

import type {
  BaseStepSpec,
  BranchStepSpec,
  CustomStepSpec,
  Json,
  LoopStepSpec,
  ParallelStepSpec,
  SequentialStepSpec,
  StepRunResult,
  StepRunResultSuccess,
  StepSpecHandler,
  StepSpecHandlerFn,
  StepSpecRaw,
  WorkflowContext,
} from './types'

export const combineHandlers = <THandlers extends StepSpecHandler[]>(...handlers: THandlers) => {
  const allHandlers = {} as Record<string, StepSpecHandler>
  for (const handler of handlers) {
    if (allHandlers[handler.type]) {
      throw new Error(`Handler with type ${handler.type} already exists`)
    }
    allHandlers[handler.type] = handler
  }

  return (step: BaseStepSpec, rootHandler: StepSpecHandlerFn<any, any>) => {
    const handler = allHandlers[step.type]
    if (!handler) {
      throw new Error(`No handler found for step type: ${step.type}`)
    }
    return handler.handler(step, rootHandler)
  }
}

import { runStep } from './runStep'

export const sequentialStepSpecHandler: StepSpecHandler = {
  type: 'sequential',
  handler(step: SequentialStepSpec, rootHandler) {
    const steps = step.steps.map((subStep) => rootHandler(subStep, rootHandler))
    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: { stepIndex: number; stepState: any; allOutputs: Record<string, Record<string, Json>> },
      ): Promise<StepRunResult<Record<string, Json>>> {
        let currentInput: Record<string, Json> = input
        const allOutputs: Record<string, Record<string, Json>> = resumedState ? resumedState.allOutputs : {}
        const startStepIndex = resumedState ? resumedState.stepIndex : 0

        for (let i = startStepIndex; i < steps.length; i++) {
          const subStep = steps[i]
          const stateToPass = i === startStepIndex && resumedState ? resumedState.stepState : undefined
          const result = await runStep(subStep, currentInput, context, stateToPass, allOutputs)

          switch (result.type) {
            case 'paused':
              return {
                type: 'paused',
                state: { stepIndex: i, stepState: result.state, allOutputs },
              }
            case 'error':
              return result // Propagate error
            case 'success':
              if (subStep.id) {
                allOutputs[subStep.id] = result.output
              }
              currentInput = result.output
              break
          }
        }
        return { type: 'success', output: currentInput }
      },
    }
  },
}

export const parallelStepSpecHandler: StepSpecHandler = {
  type: 'parallel',
  handler(step: ParallelStepSpec, rootHandler) {
    const innerStep = rootHandler(step.step, rootHandler)
    return {
      ...step,
      async run(
        input,
        context,
        resumedState?: (StepRunResult<Record<string, Json>> | undefined)[],
      ): Promise<StepRunResult<Record<string, Json>>> {
        const items = (input.items as Record<string, Json>[]) ?? []
        const promises = items.map((innerInput, index) => {
          const previousResult = resumedState?.[index]
          if (previousResult) {
            if (previousResult.type === 'paused') {
              return runStep(innerStep, innerInput, context, previousResult.state, input.$)
            }
            return previousResult
          }
          return runStep(innerStep, innerInput, context, undefined, input.$)
        })
        const results = await Promise.all(promises)

        const errors = results.filter((r) => r.type === 'error')
        if (errors.length > 0) {
          return {
            type: 'error',
            error: new Error(`Multiple errors: ${errors.map((e) => e.error).join(', ')}`),
          }
        }

        const isPaused = results.some((r) => r.type === 'paused')
        if (isPaused) {
          return { type: 'paused', state: results }
        }

        const outputs = (results as StepRunResultSuccess<Record<string, Json>>[]).map((r) => r.output)
        return { type: 'success', output: { results: outputs } }
      },
    }
  },
}

export const loopStepSpecHandler: StepSpecHandler = {
  type: 'loop',
  handler(step: LoopStepSpec, rootHandler) {
    const innerStep = rootHandler(step.step, rootHandler)

    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: {
          iteration: number
          stepState?: any
          results: Record<string, Json>[]
          accumulator?: Record<string, Json>
        },
      ): Promise<StepRunResult<Record<string, Json>>> {
        const allOutputs = (input.$ as Record<string, Record<string, Json>> | undefined) ?? {}
        const initialInput = { ...input }
        delete (initialInput as any).$

        const results: Record<string, Json>[] = resumedState ? [...resumedState.results] : []
        let iteration = resumedState?.iteration ?? results.length
        let accumulator: Record<string, Json> | undefined = resumedState?.accumulator

        if (step.accumulator && accumulator === undefined) {
          const initialAccumulator = step.accumulator.initial
          accumulator = typeof initialAccumulator === 'function' ? initialAccumulator() : initialAccumulator
        }

        const hasPredicates = Boolean(step.while || step.until)
        const effectiveMaxIterations = step.maxIterations ?? (hasPredicates ? undefined : 1)

        const createState = () => ({
          iteration,
          input: initialInput,
          results,
          last: results[results.length - 1],
          accumulator,
        })

        const completeSuccess = () => {
          const output: Record<string, Json> = { results }
          if (results.length > 0) {
            output.last = results[results.length - 1]
          }
          if (accumulator !== undefined && step.accumulator) {
            output.accumulator = accumulator
          }
          return { type: 'success', output } as StepRunResult<Record<string, Json>>
        }

        const shouldContinue = async () => {
          const state = createState()
          if (step.until) {
            const shouldStop = await step.until(state as any, context)
            if (shouldStop) {
              return false
            }
          }
          if (step.while) {
            return Boolean(await step.while(state as any, context))
          }
          return true
        }

        let pendingResumeState = resumedState

        while (true) {
          if (!hasPredicates && effectiveMaxIterations !== undefined && iteration >= effectiveMaxIterations) {
            return completeSuccess()
          }

          if (hasPredicates) {
            const canContinue = await shouldContinue()
            if (!canContinue) {
              return completeSuccess()
            }
            if (step.maxIterations !== undefined && iteration >= step.maxIterations) {
              return {
                type: 'error',
                error: new Error(`Loop exceeded max iterations: ${step.maxIterations}`),
              }
            }
          }

          const stateBeforeRun = createState()
          const iterationInput = step.mapInput ? await step.mapInput(stateBeforeRun as any, context) : (stateBeforeRun.last ?? initialInput)

          const resumeStateForInner =
            pendingResumeState && pendingResumeState.iteration === iteration ? pendingResumeState.stepState : undefined

          const result = await runStep(innerStep, iterationInput, context, resumeStateForInner, allOutputs)

          if (result.type === 'paused') {
            return {
              type: 'paused',
              state: {
                iteration,
                stepState: result.state,
                results,
                accumulator,
              },
            }
          }

          if (result.type === 'error') {
            return result
          }

          results[iteration] = result.output

          if (step.accumulator) {
            const updated = await step.accumulator.update(
              {
                ...stateBeforeRun,
                results,
                last: result.output,
                accumulator: accumulator as Record<string, Json>,
                result: result.output,
              } as any,
              context,
            )
            accumulator = updated
          }

          iteration += 1
          pendingResumeState = undefined
        }
      },
    }
  },
}

export const branchStepSpecHandler: StepSpecHandler = {
  type: 'branch',
  handler(step: BranchStepSpec, rootHandler) {
    const branches = step.branches.map((branch) => ({
      ...branch,
      step: rootHandler(branch.step, rootHandler),
    }))
    const otherwise = step.otherwise ? rootHandler(step.otherwise, rootHandler) : undefined

    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: { branchIndex: number; stepState?: any },
      ): Promise<StepRunResult<Record<string, Json>>> {
        const allOutputs = (input.$ as Record<string, Record<string, Json>> | undefined) ?? {}

        let branchIndex = resumedState?.branchIndex
        let stepToRun: StepSpecRaw | undefined

        if (branchIndex === undefined) {
          for (let i = 0; i < branches.length; i++) {
            const shouldRun = await branches[i].when(input as Record<string, Json> & { $: Record<string, Record<string, Json>> }, context)
            if (shouldRun) {
              branchIndex = i
              break
            }
          }

          if (branchIndex === undefined && otherwise) {
            branchIndex = branches.length
          }
        }

        if (branchIndex !== undefined) {
          if (branchIndex < branches.length) {
            stepToRun = branches[branchIndex].step
          } else if (branchIndex === branches.length && otherwise) {
            stepToRun = otherwise
          }
        }

        if (!stepToRun) {
          return {
            type: 'error',
            error: new Error('No branch predicate matched and no otherwise branch provided'),
          }
        }

        const result = await runStep(
          stepToRun,
          input,
          context,
          branchIndex === resumedState?.branchIndex ? resumedState?.stepState : undefined,
          allOutputs,
        )

        if (result.type === 'paused') {
          return { type: 'paused', state: { branchIndex, stepState: result.state } }
        }

        return result
      },
    }
  },
}

export const customStepSpecHandler: StepSpecHandler = {
  type: 'custom',
  handler(step: CustomStepSpec) {
    return {
      ...step,
      async run(input, context, resumedState) {
        return step.run(input, context, resumedState)
      },
    }
  },
}

export function step<TInput extends Record<string, Json>, TOutput extends Record<string, Json>>(
  id: string,
  run: CustomStepSpec<TInput, TOutput>['run'],
): CustomStepSpec<TInput, TOutput> {
  return { id, type: 'custom', run: run }
}
