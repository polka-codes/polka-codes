// generated by polka.codes

import type {
  BaseStepSpec,
  CustomStepSpec,
  Json,
  ParallelStepSpec,
  SequentialStepSpec,
  StepRunResult,
  StepRunResultSuccess,
  StepSpecHandler,
  StepSpecHandlerFn,
  WorkflowContext,
} from './types'

export const combineHandlers = <THandlers extends StepSpecHandler[]>(...handlers: THandlers) => {
  const allHandlers = {} as Record<string, StepSpecHandler>
  for (const handler of handlers) {
    if (allHandlers[handler.type]) {
      throw new Error(`Handler with type ${handler.type} already exists`)
    }
    allHandlers[handler.type] = handler
  }

  return (step: BaseStepSpec, rootHandler: StepSpecHandlerFn<any, any>) => {
    const handler = allHandlers[step.type]
    if (!handler) {
      throw new Error(`No handler found for step type: ${step.type}`)
    }
    return handler.handler(step, rootHandler)
  }
}

import { runStep } from './runStep'

export const sequentialStepSpecHandler: StepSpecHandler = {
  type: 'sequential',
  handler(step: SequentialStepSpec, rootHandler) {
    const steps = step.steps.map((subStep) => rootHandler(subStep, rootHandler))
    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: { stepIndex: number; stepState: any; allOutputs: Record<string, Record<string, Json>> },
      ): Promise<StepRunResult<Record<string, Json>>> {
        let currentInput: Record<string, Json> = input
        const allOutputs: Record<string, Record<string, Json>> = resumedState ? resumedState.allOutputs : {}
        const startStepIndex = resumedState ? resumedState.stepIndex : 0

        for (let i = startStepIndex; i < steps.length; i++) {
          const subStep = steps[i]
          const stateToPass = i === startStepIndex && resumedState ? resumedState.stepState : undefined
          const result = await runStep(subStep, currentInput, context, stateToPass, allOutputs)

          switch (result.type) {
            case 'paused':
              return {
                type: 'paused',
                state: { stepIndex: i, stepState: result.state, allOutputs },
              }
            case 'error':
              return result // Propagate error
            case 'success':
              if (subStep.id) {
                allOutputs[subStep.id] = result.output
              }
              currentInput = result.output
              break
          }
        }
        return { type: 'success', output: currentInput }
      },
    }
  },
}

export const parallelStepSpecHandler: StepSpecHandler = {
  type: 'parallel',
  handler(step: ParallelStepSpec, rootHandler) {
    const innerStep = rootHandler(step.step, rootHandler)
    return {
      ...step,
      async run(
        input,
        context,
        resumedState?: (StepRunResult<Record<string, Json>> | undefined)[],
      ): Promise<StepRunResult<Record<string, Json>>> {
        const items = (input.items as Record<string, Json>[]) ?? []
        const promises = items.map((innerInput, index) => {
          const previousResult = resumedState?.[index]
          if (previousResult) {
            if (previousResult.type === 'paused') {
              return runStep(innerStep, innerInput, context, previousResult.state, input.$)
            }
            return previousResult
          }
          return runStep(innerStep, innerInput, context, undefined, input.$)
        })
        const results = await Promise.all(promises)

        const errors = results.filter((r) => r.type === 'error')
        if (errors.length > 0) {
          return {
            type: 'error',
            error: new Error(`Multiple errors: ${errors.map((e) => e.error).join(', ')}`),
          }
        }

        const isPaused = results.some((r) => r.type === 'paused')
        if (isPaused) {
          return { type: 'paused', state: results }
        }

        const outputs = (results as StepRunResultSuccess<Record<string, Json>>[]).map((r) => r.output)
        return { type: 'success', output: { results: outputs } }
      },
    }
  },
}

export const customStepSpecHandler: StepSpecHandler = {
  type: 'custom',
  handler(step: CustomStepSpec) {
    return {
      ...step,
      async run(input, context, resumedState) {
        return step.run(input, context, resumedState)
      },
    }
  },
}

export function step<TInput extends Record<string, Json>, TOutput extends Record<string, Json>>(
  id: string,
  run: CustomStepSpec<TInput, TOutput>['run'],
): CustomStepSpec<TInput, TOutput> {
  return { id, type: 'custom', run: run }
}
