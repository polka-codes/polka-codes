// generated by polka.codes
import type { BaseStepSpec, Json, StepRunResult, StepSpecHandler, TemplatedString, WorkflowContext } from './types'
import { resolveTemplatedString } from './utils'

type CommandOutput = {
  stdout?: string
  stderr?: string
  exitCode?: number
}

export interface CommandStepSpec extends BaseStepSpec<Record<string, string>, CommandOutput> {
  type: 'command'
  command: (string | TemplatedString)[]
  outputs?: ('stdout' | 'stderr' | 'exitCode')[]
}

export const commandStepSpecHandler: StepSpecHandler = {
  type: 'command',
  handler(step: CommandStepSpec) {
    return {
      ...step,
      async run(input: Record<string, Json>, context: WorkflowContext): Promise<StepRunResult<CommandOutput>> {
        try {
          if (!context.provider.executeCommand) {
            throw new Error('executeCommand is not available in the provider')
          }

          const command = step.command.map((arg) => resolveTemplatedString(arg, input))

          // TODO: update executeCommand to accept array of args
          const commandString = command
            .map((arg) => {
              if (/[^A-Za-z0-9_/:=-]/.test(arg)) {
                return `"${arg.replace(/"/g, '\\"')}"`
              }
              return arg
            })
            .join(' ')

          const result = await context.provider.executeCommand(commandString, false)

          const output: { [key: string]: any } = {}
          if (step.outputs?.includes('stdout')) {
            output.stdout = result.stdout
          }
          if (step.outputs?.includes('stderr')) {
            output.stderr = result.stderr
          }
          if (step.outputs?.includes('exitCode')) {
            output.exitCode = result.exitCode
          }

          return { type: 'success', output }
        } catch (e) {
          return { type: 'error', error: e instanceof Error ? e : new Error(String(e)) }
        }
      },
    }
  },
}
