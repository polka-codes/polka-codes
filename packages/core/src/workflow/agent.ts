// generated by polka.codes

import type { LanguageModelV2 } from '@ai-sdk/provider'
import type { ModelMessage, UserContent } from 'ai'
import type { z } from 'zod'
import {
  AgentBase,
  type AgentNameType,
  type AgentPolicy,
  AnalyzerAgent,
  ArchitectAgent,
  CodeFixerAgent,
  CoderAgent,
  type ExitReason,
  type SharedAgentOptions,
} from '../Agent'
import type { ToolFormat } from '../config'
import { type FullToolInfoV2, type ToolResponse, type ToolResponseInterrupted, ToolResponseType } from '../tool'
import { UsageMeter } from '../UsageMeter'
import type { BaseStepSpec, Json, StepRunResult, StepSpecHandler, TemplatedString, WorkflowContext } from './types'
import { resolveTemplatedString } from './utils'

export type AgentStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> = BaseStepSpec<TInput, TOutput> & {
  type: 'agent'
  messages: (UserContent | TemplatedString)[]
  outputSchema: z.ZodType
  provider?: string
  model?: string
  budget?: number
  maxMessages?: number
  modelParameters?: Record<string, any>
  toolFormat?: ToolFormat
} & (
    | {
        agent: AgentNameType
        tools?: FullToolInfoV2[]
      }
    | {
        systemPrompt: string | TemplatedString
        tools: FullToolInfoV2[]
      }
  )

const agentRegistry: Record<string, new (options: SharedAgentOptions) => AgentBase> = {
  analyzer: AnalyzerAgent,
  architect: ArchitectAgent,
  coder: CoderAgent,
  codefixer: CodeFixerAgent,
}

class WorkflowAgent extends AgentBase {
  protected onBeforeInvokeTool(_name: string, _args: Record<string, string>): Promise<ToolResponse | undefined> {
    return Promise.resolve(undefined)
  }
}

export type AgentContextParameters = {
  budget?: number
  maxMessages?: number
  toolFormat?: ToolFormat
  os?: string
  policies?: AgentPolicy[]
  modelParameters?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
}

type ResumeState = {
  messages: ModelMessage[]
  usage: {
    input: number
    output: number
    cachedRead: number
    cost: number
    calls: number
  }
}

export const makeAgentStepSpecHandler = (
  getModelFn: (step: AgentStepSpec, context: WorkflowContext) => Promise<LanguageModelV2>,
): StepSpecHandler => ({
  type: 'agent',
  handler(step: AgentStepSpec) {
    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: ResumeState,
      ): Promise<StepRunResult<Record<string, Json>>> {
        try {
          const model = await getModelFn(step, context)

          const parameters: AgentContextParameters = context.parameters ?? {}

          const budget = step.budget ?? parameters?.budget
          const maxMessages = step.maxMessages ?? parameters?.maxMessages
          const usageMeter = new UsageMeter({}, { maxMessages, maxCost: budget })
          const toolFormat = step.toolFormat ?? parameters.toolFormat ?? 'native'
          const policies = parameters.policies ?? []
          const modelParameters = { ...(parameters.modelParameters ?? {}), ...(step.modelParameters ?? {}) }

          if (resumedState?.usage) {
            usageMeter.setUsage(resumedState.usage)
          }

          const getAgent = () => {
            if ('agent' in step) {
              const agentName = step.agent
              const AgentClass = agentRegistry[agentName]
              if (!AgentClass) {
                throw new Error(`Unknown agent: ${agentName}`)
              }

              const agentOptions: SharedAgentOptions = {
                ai: model,
                os: parameters.os ?? 'linux',
                provider: context.provider,
                interactive: false,
                toolFormat,
                additionalTools: step.tools,
                policies,
                usageMeter,
                parameters: modelParameters,
                scripts: parameters.scripts,
              }

              return new AgentClass(agentOptions)
            } else {
              const systemPrompt = resolveTemplatedString(step.systemPrompt, input)
              return new WorkflowAgent('agent', model, {
                systemPrompt,
                tools: step.tools,
                toolNamePrefix: toolFormat === 'native' ? '' : 'tool_',
                provider: context.provider,
                interactive: false,
                agents: [],
                scripts: parameters.scripts,
                callback: undefined,
                policies,
                toolFormat,
                parameters: modelParameters,
                usageMeter,
              })
            }
          }

          const agent = getAgent()

          if (resumedState?.messages) {
            agent.setMessages(resumedState.messages)
          }

          const userContentArray: UserContent[] = step.messages.map((message) => {
            if (typeof message === 'string' || Array.isArray(message)) {
              return message
            }
            return resolveTemplatedString(message, input)
          })

          const combinedContentParts: Exclude<UserContent, string> = []
          for (const content of userContentArray) {
            if (typeof content === 'string') {
              combinedContentParts.push({ type: 'text', text: content })
            } else {
              combinedContentParts.push(...content)
            }
          }

          const exitReason = await agent.start(combinedContentParts)

          const handleExitReason = (reason: ExitReason): StepRunResult<Record<string, Json>> => {
            switch (reason.type) {
              case 'Pause':
                return { type: 'paused', state: { messages: agent.messages } }
              case 'UsageExceeded':
                return { type: 'error', error: new Error('Usage limit exceeded') }
              case ToolResponseType.Exit:
              case ToolResponseType.HandOver:
              case ToolResponseType.Delegate:
                return { type: 'success', output: reason }
              case 'Aborted':
              case 'WaitForUserInput':
                return { type: 'error', error: new Error(`Agent exited for reason: ${reason.type}`) }
              case ToolResponseType.Interrupted:
                return { type: 'error', error: new Error(JSON.stringify((reason as ToolResponseInterrupted).message)) }
              default:
                // This should be unreachable if all cases are handled.
                return {
                  type: 'error',
                  error: new Error(`Agent exited for an unhandled reason: ${JSON.stringify(reason)}`),
                }
            }
          }

          return handleExitReason(exitReason)
        } catch (e) {
          return { type: 'error', error: e instanceof Error ? e : new Error(String(e)) }
        }
      },
    }
  },
})
