// generated by polka.codes

import type { LanguageModelV2 } from '@ai-sdk/provider'
import type { ModelMessage, UserContent } from 'ai'
import type { z } from 'zod'
import { toJSONSchema } from 'zod/v4'
import {
  AgentBase,
  type AgentNameType,
  type AgentPolicy,
  AnalyzerAgent,
  ArchitectAgent,
  CodeFixerAgent,
  CoderAgent,
  type ExitReason,
  type SharedAgentOptions,
} from '../Agent'
import type { ToolFormat } from '../config'
import { type FullToolInfoV2, type ToolResponse, type ToolResponseInterrupted, ToolResponseType } from '../tool'
import { UsageMeter } from '../UsageMeter'
import type { BaseStepSpec, Json, ParseOutputResult, StepRunResult, StepSpecHandler, TemplatedString, WorkflowContext } from './types'
import { resolveTemplatedString } from './utils'

export type AgentStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> = BaseStepSpec<TInput, TOutput> & {
  type: 'agent'
  messages: (UserContent | TemplatedString<TInput>)[]
  outputSchema?: z.ZodType<TOutput>
  parseOutput?: (raw: string) => ParseOutputResult<TOutput>
  provider?: string
  model?: string
  modelParameters?: Record<string, any>
  toolFormat?: ToolFormat
  agent?: AgentNameType
  tools?: FullToolInfoV2[]
  systemPrompt?: string | TemplatedString<TInput>
}

const agentRegistry: Record<string, new (options: SharedAgentOptions) => AgentBase> = {
  analyzer: AnalyzerAgent,
  architect: ArchitectAgent,
  coder: CoderAgent,
  codefixer: CodeFixerAgent,
}

class WorkflowAgent extends AgentBase {
  protected onBeforeInvokeTool(_name: string, _args: Record<string, string>): Promise<ToolResponse | undefined> {
    return Promise.resolve(undefined)
  }
}

export type AgentContextParameters = {
  toolFormat?: ToolFormat
  os?: string
  policies?: AgentPolicy[]
  modelParameters?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter?: UsageMeter
}

type ResumeState = {
  messages?: ModelMessage[]
  usage?: {
    input: number
    output: number
    cachedRead: number
    cost: number
    messageCount: number
  }
}

export const makeAgentStepSpecHandler = (
  getModelFn: (step: AgentStepSpec, context: WorkflowContext) => Promise<LanguageModelV2>,
): StepSpecHandler => ({
  type: 'agent',
  handler(step: AgentStepSpec) {
    return {
      ...step,
      async run(
        input: Record<string, Json>,
        context: WorkflowContext,
        resumedState?: ResumeState,
      ): Promise<StepRunResult<Record<string, Json>>> {
        const logger = context.logger ?? console
        if (context.verbose && context.verbose >= 1) {
          logger.log(`[agent-step] Running agent step '${step.id}' with input:`, input)
        }
        try {
          const model = await getModelFn(step, context)

          const parameters: AgentContextParameters = context.parameters ?? {}

          const usageMeter = parameters?.usageMeter ?? new UsageMeter()
          const toolFormat = step.toolFormat ?? parameters.toolFormat ?? 'native'
          const policies = parameters.policies ?? []
          const modelParameters = { ...(parameters.modelParameters ?? {}), ...(step.modelParameters ?? {}) }

          if (resumedState?.usage) {
            usageMeter.setUsage(resumedState.usage)
          }

          const getAgent = () => {
            if (step.agent) {
              const agentName = step.agent
              const AgentClass = agentRegistry[agentName]
              if (!AgentClass) {
                throw new Error(`Unknown agent: ${agentName}`)
              }

              if (context.verbose && context.verbose >= 1) {
                logger.log(`[agent-step] Using agent: ${agentName}`)
              }

              return new AgentClass({
                ai: model,
                os: parameters.os ?? 'linux',
                provider: context.provider,
                toolFormat,
                additionalTools: step.tools,
                policies,
                usageMeter,
                parameters: modelParameters,
                scripts: parameters.scripts,
                callback: context.agentCallback,
                requireToolUse: false,
                retryCount: parameters.retryCount,
                requestTimeoutSeconds: parameters.requestTimeoutSeconds,
              })
            } else {
              if (!step.systemPrompt) {
                throw new Error('No system prompt specified for the agent step.')
              }
              if (context.verbose && context.verbose >= 1) {
                logger.log(`[agent-step] Using generic WorkflowAgent`)
              }
              const systemPrompt = resolveTemplatedString(step.systemPrompt, input)
              return new WorkflowAgent('agent', model, {
                systemPrompt,
                tools: step.tools ?? [],
                toolNamePrefix: toolFormat === 'native' ? '' : 'tool_',
                provider: context.provider,
                agents: [],
                scripts: parameters.scripts,
                callback: undefined,
                policies,
                toolFormat,
                parameters: modelParameters,
                usageMeter,
                requireToolUse: false,
                retryCount: parameters.retryCount,
                requestTimeoutSeconds: parameters.requestTimeoutSeconds,
              })
            }
          }

          const agent = getAgent()

          if (resumedState?.messages) {
            agent.setMessages(resumedState.messages)
          }

          const userContentArray: UserContent[] = step.messages.map((message) => {
            if (typeof message === 'string' || Array.isArray(message)) {
              return message
            }
            return resolveTemplatedString(message, input)
          })

          const combinedContentParts: Exclude<UserContent, string> = []
          for (const content of userContentArray) {
            if (typeof content === 'string') {
              combinedContentParts.push({ type: 'text', text: content })
            } else {
              combinedContentParts.push(...content)
            }
          }

          if (context.verbose && context.verbose >= 1) {
            logger.log(`[agent-step] Starting agent with content:`, JSON.stringify(combinedContentParts, null, 2))
          }

          const exitReason = await agent.start(combinedContentParts)

          if (context.verbose && context.verbose >= 1) {
            logger.log(`[agent-step] Agent exited with reason:`, exitReason)
          }

          const handleExitReason = async (reason: ExitReason): Promise<StepRunResult<Record<string, Json>>> => {
            switch (reason.type) {
              case 'Pause':
                return {
                  type: 'paused',
                  state: {
                    messages: agent.messages,
                    usage: usageMeter.usage,
                  },
                }
              case 'UsageExceeded':
                return { type: 'error', error: new Error('Usage limit exceeded') }
              case ToolResponseType.Exit: {
                const raw = reason.message
                if (step.parseOutput) {
                  const result = step.parseOutput(raw)
                  if (result.success) {
                    if (step.outputSchema) {
                      const validationResult = step.outputSchema.safeParse(result.data)
                      if (validationResult.success) {
                        return { type: 'success', output: validationResult.data }
                      }
                      let errorMessage = `Output validation failed: ${validationResult.error.toString()}`
                      if (step.outputSchema) {
                        errorMessage += `\n\nExpected JSON schema:\n${JSON.stringify(toJSONSchema(step.outputSchema), null, 2)}`
                      }
                      const newReason = await agent.continueTask(errorMessage)
                      return handleExitReason(newReason)
                    }
                    return { type: 'success', output: result.data as any }
                  }
                  let errorMessage = result.error ?? 'Invalid format.'
                  if (step.outputSchema) {
                    errorMessage += `\n\nExpected JSON schema:\n${JSON.stringify(toJSONSchema(step.outputSchema), null, 2)}`
                  }
                  const newReason = await agent.continueTask(errorMessage)
                  return handleExitReason(newReason)
                } else if (step.outputSchema) {
                  try {
                    const output = JSON.parse(raw)
                    const validationResult = step.outputSchema.safeParse(output)
                    if (validationResult.success) {
                      return { type: 'success', output: validationResult.data }
                    }
                    let errorMessage = `Output validation failed: ${validationResult.error.toString()}`
                    errorMessage += `\n\nExpected JSON schema:\n${JSON.stringify(toJSONSchema(step.outputSchema), null, 2)}`
                    const newReason = await agent.continueTask(errorMessage)
                    return handleExitReason(newReason)
                  } catch (e) {
                    const error = e instanceof Error ? e : new Error(String(e))
                    let errorMessage = `Failed to parse agent output as JSON: ${error.message}`
                    errorMessage += `\n\nExpected JSON schema:\n${JSON.stringify(toJSONSchema(step.outputSchema), null, 2)}`
                    const newReason = await agent.continueTask(errorMessage)
                    return handleExitReason(newReason)
                  }
                }
                return { type: 'success', output: reason }
              }
              case ToolResponseType.HandOver:
              case ToolResponseType.Delegate:
                return { type: 'success', output: reason }
              case 'Aborted':
              case 'WaitForUserInput':
                return { type: 'error', error: new Error(`Agent exited for reason: ${reason.type}`) }
              case ToolResponseType.Interrupted:
                return { type: 'error', error: new Error(JSON.stringify((reason as ToolResponseInterrupted).message)) }
              default:
                // This should be unreachable if all cases are handled.
                return {
                  type: 'error',
                  error: new Error(`Agent exited for an unhandled reason: ${JSON.stringify(reason)}`),
                }
            }
          }

          return await handleExitReason(exitReason)
        } catch (e) {
          return { type: 'error', error: e instanceof Error ? e : new Error(String(e)) }
        }
      },
    }
  },
})
