// generated by polka.codes
import type { z } from 'zod'
import type { ToolProvider } from '../tools'

export type Json = boolean | number | string | Json[] | { [k: string]: Json }

export type TemplatedString<T = { [k: string]: Json }> =
  | {
      type: 'template'
      template: string
    }
  | {
      type: 'function'
      fn: (input: T) => string
    }

export type BaseStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> = {
  id: string
  type: string
  inputSchema?: z.ZodType<TInput>
  outputSchema?: z.ZodType<TOutput>
}

export type WorkflowContext = {
  provider: ToolProvider
  parameters: Record<string, any>
}

export type StepSpecRaw = {
  id: string
  type: string
  inputSchema?: z.ZodType<any>
  outputSchema?: z.ZodType<any>
  run: (
    input: Record<string, Json>,
    context: WorkflowContext,
    resumedState?: any,
    allOutputs?: Record<string, Record<string, Json>>,
  ) => Promise<StepRunResult<Record<string, Json>>>
}

export interface SequentialStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
  TStepSpec extends BaseStepSpec = BaseStepSpec,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'sequential'
  steps: TStepSpec[]
}

export interface ParallelStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<Record<string, Json>, Record<string, Json>> {
  type: 'parallel'
  step: BaseStepSpec<TInput, TOutput>
}

export interface CustomStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'custom'
  run: (input: TInput, context: WorkflowContext, resumedState?: any) => Promise<StepRunResult<TOutput>>
}

export type StepRunResultSuccess<T extends Record<string, Json>> = {
  type: 'success'
  output: T
}

export type StepRunResultPaused = {
  type: 'paused'
  state: any
}

export type StepRunResultError = {
  type: 'error'
  error: any
}

export type StepRunResult<T extends Record<string, Json>> = StepRunResultSuccess<T> | StepRunResultPaused | StepRunResultError

export interface WorkflowSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
  TStepSpec extends BaseStepSpec<TInput, TOutput> = BaseStepSpec<TInput, TOutput>,
> {
  name: string
  description?: string
  step: TStepSpec
}

export interface WorkflowSpecRaw {
  name: string
  description?: string
  step: StepSpecRaw
}

export type StepSpecHandlerFn<TStepSpec extends BaseStepSpec, TRootStepSpec extends BaseStepSpec> = (
  step: TStepSpec,
  rootHandler: StepSpecHandlerFn<TRootStepSpec, TRootStepSpec>,
) => StepSpecRaw

export type StepSpecHandler = {
  type: string
  handler: StepSpecHandlerFn<any, any>
}

export type WorkflowRunResultSuccess<T extends Record<string, Json>> = {
  type: 'success'
  output: T
}

export type WorkflowRunResultError = {
  type: 'error'
  error: any
}

export type WorkflowRunResultPaused = {
  type: 'paused'
  state: any
}

export type WorkflowRunResult<T extends Record<string, Json>> =
  | WorkflowRunResultSuccess<T>
  | WorkflowRunResultError
  | WorkflowRunResultPaused
