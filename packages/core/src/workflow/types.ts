// generated by polka.codes
import type { z } from 'zod'
import type { TaskEventCallback } from '../Agent'
import type { ToolProvider } from '../tools'

export type Json = boolean | number | string | Json[] | { [k: string]: Json }

export type TemplatedString<T = { [k: string]: Json }> =
  | {
      type: 'template'
      template: string
    }
  | {
      type: 'function'
      fn: (input: T) => string
    }

export type BaseStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> = {
  id: string
  type: string
  inputSchema?: z.ZodType<TInput>
  outputSchema?: z.ZodType<TOutput>
}

export type WorkflowContext = {
  provider: ToolProvider
  parameters: Record<string, any>
  verbose?: number
  agentCallback?: TaskEventCallback
  logger?: Console
}

type InputType = {
  $: Record<string, Record<string, Json>>
  [key: string]: Json
}

export type StepSpecRaw = {
  id: string
  type: string
  inputSchema?: z.ZodType<any>
  outputSchema?: z.ZodType<any>
  run: (input: InputType, context: WorkflowContext, resumedState?: any) => Promise<StepRunResult<Record<string, Json>>>
}

export interface SequentialStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
  TStepSpec extends BaseStepSpec = BaseStepSpec,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'sequential'
  steps: TStepSpec[]
}

export interface ParallelStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<Record<string, Json>, Record<string, Json>> {
  type: 'parallel'
  step: BaseStepSpec<TInput, TOutput>
}

export type LoopStepState<
  TInput extends Record<string, Json> = Record<string, Json>,
  TIterationOutput extends Record<string, Json> = Record<string, Json>,
  TAccumulator extends Record<string, Json> = Record<string, Json>,
> = {
  iteration: number
  input: TInput
  results: TIterationOutput[]
  last?: TIterationOutput
  accumulator?: TAccumulator
}

export interface LoopAccumulatorSpec<
  TInput extends Record<string, Json>,
  TIterationOutput extends Record<string, Json>,
  TAccumulator extends Record<string, Json>,
> {
  initial: TAccumulator | (() => TAccumulator)
  update: (
    state: LoopStepState<TInput, TIterationOutput, TAccumulator> & { result: TIterationOutput },
    context: WorkflowContext,
  ) => TAccumulator | Promise<TAccumulator>
}

export type LoopStepOutput<
  TIterationOutput extends Record<string, Json> = Record<string, Json>,
  TAccumulator extends Record<string, Json> = Record<string, Json>,
> = {
  results: TIterationOutput[]
  last?: TIterationOutput
  accumulator?: TAccumulator
}

export interface LoopStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TIterationInput extends Record<string, Json> = TInput,
  TIterationOutput extends Record<string, Json> = Record<string, Json>,
  TAccumulator extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<TInput, LoopStepOutput<TIterationOutput, TAccumulator>> {
  type: 'loop'
  step: BaseStepSpec<TIterationInput, TIterationOutput>
  while?: (state: LoopStepState<TInput, TIterationOutput, TAccumulator>, context: WorkflowContext) => boolean | Promise<boolean>
  until?: (state: LoopStepState<TInput, TIterationOutput, TAccumulator>, context: WorkflowContext) => boolean | Promise<boolean>
  maxIterations?: number
  mapInput?: (
    state: LoopStepState<TInput, TIterationOutput, TAccumulator>,
    context: WorkflowContext,
  ) => TIterationInput | Promise<TIterationInput>
  accumulator?: LoopAccumulatorSpec<TInput, TIterationOutput, TAccumulator>
}

export interface WorkflowStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TWorkflowInput extends Record<string, Json> = TInput,
  TWorkflowOutput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = TWorkflowOutput,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'workflow'
  workflow: WorkflowSpec<TWorkflowInput, TWorkflowOutput>
  mapInput?: (
    input: TInput & { $: Record<string, Record<string, Json>> },
    context: WorkflowContext,
  ) => TWorkflowInput | Promise<TWorkflowInput>
  mapOutput?: (
    params: {
      input: TInput & { $: Record<string, Record<string, Json>> }
      workflowInput: TWorkflowInput
      workflowOutput: TWorkflowOutput
    },
    context: WorkflowContext,
  ) => TOutput | Promise<TOutput>
}

export interface BranchStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'branch'
  branches: {
    id: string
    when: (input: TInput & { $: Record<string, Record<string, Json>> }, context: WorkflowContext) => boolean | Promise<boolean>
    step: BaseStepSpec<TInput, TOutput>
  }[]
  otherwise?: BaseStepSpec<TInput, TOutput>
}

export interface CustomStepSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> extends BaseStepSpec<TInput, TOutput> {
  type: 'custom'
  run: (
    input: TInput & { $: Record<string, Record<string, Json>> },
    context: WorkflowContext,
    resumedState?: any,
  ) => Promise<StepRunResult<TOutput>>
}

export type StepRunResultSuccess<T extends Record<string, Json>> = {
  type: 'success'
  output: T
}

export type StepRunResultPaused = {
  type: 'paused'
  state: any
}

export type StepRunResultError = {
  type: 'error'
  error: any
}

export type StepRunResult<T extends Record<string, Json>> = StepRunResultSuccess<T> | StepRunResultPaused | StepRunResultError

export interface WorkflowSpec<
  TInput extends Record<string, Json> = Record<string, Json>,
  TOutput extends Record<string, Json> = Record<string, Json>,
> {
  name: string
  description?: string
  step: BaseStepSpec<TInput, TOutput>
}

export interface WorkflowSpecRaw {
  name: string
  description?: string
  step: StepSpecRaw
}

export type StepSpecHandlerFn<TStepSpec extends BaseStepSpec, TRootStepSpec extends BaseStepSpec> = (
  step: TStepSpec,
  rootHandler: StepSpecHandlerFn<TRootStepSpec, TRootStepSpec>,
) => StepSpecRaw

export type StepSpecHandler = {
  type: string
  handler: StepSpecHandlerFn<any, any>
}

export type WorkflowRunResultSuccess<T extends Record<string, Json>> = {
  type: 'success'
  output: T
}

export type WorkflowRunResultError = {
  type: 'error'
  error: any
}

export type WorkflowRunResultPaused = {
  type: 'paused'
  state: any
}

export type WorkflowRunResult<T extends Record<string, Json>> =
  | WorkflowRunResultSuccess<T>
  | WorkflowRunResultError
  | WorkflowRunResultPaused

export type ParseOutputResult<T> = { success: true; data: T } | { success: false; error?: string }
