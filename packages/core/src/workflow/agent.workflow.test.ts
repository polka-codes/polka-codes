// generated by polka.codes

import { expect, spyOn, test } from 'bun:test'
import type { ModelMessage, UserModelMessage } from 'ai'
import { z } from 'zod'
import type { FullToolInfo, ToolResponse } from '../'
import { type AgentToolRegistry, agentWorkflow } from './agent.workflow'
import { type JsonResponseMessage, toJsonModelMessage } from './json-ai-types'
import { createContext, type WorkflowTools } from './workflow'

const createMockTool = (name: string, description: string, handler: (args: any) => Promise<ToolResponse>): FullToolInfo => ({
  name,
  description,
  parameters: z.object({
    path: z.string().describe('The path to list files from'),
  }),
  handler: (_: any, args: any) => handler(args),
})

const listFilesTool = createMockTool('listFiles', 'List files in a directory', async ({ path }: { path: string }) => {
  if (path === './src') {
    return {
      success: true,
      message: {
        type: 'json',
        value: ['index.ts', 'agent.workflow.ts'],
      },
    }
  }
  return {
    success: true,
    message: { type: 'json', value: [] },
  }
})

test('should run agent workflow with a tool call and reply', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'listFiles',
          input: { path: './src' },
        },
      ],
    },
    {
      role: 'assistant',
      content: 'The files are index.ts and agent.workflow.ts',
    },
  ]

  const initialMessages: UserModelMessage[] = [{ role: 'user', content: 'What are the files in the src directory?' }]

  const allTools = [listFilesTool]
  const spied = { fn: (_: any) => {} }
  const taskEventSpy = spyOn(spied, 'fn')

  const tools: WorkflowTools<AgentToolRegistry> = {
    generateText: async () => {
      const response = mockResponses.shift()
      return [response!] as JsonResponseMessage[]
    },
    invokeTool: async (input) => {
      const { toolName, input: toolInput } = input
      const toolInfo = allTools.find((t) => t.name === toolName)
      if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
      return toolInfo.handler({} as any, toolInput)
    },
    taskEvent: async (input) => {
      taskEventSpy(input)
    },
  }

  const result = await agentWorkflow(
    {
      userMessage: initialMessages.map(toJsonModelMessage) as any,
      tools: allTools,
      systemPrompt: 'You are a helpful assistant.',
    },
    createContext(tools),
  )

  expect(result).toMatchObject({
    type: 'Exit',
    message: 'The files are index.ts and agent.workflow.ts',
  })
})

test('should fail if maxToolRoundTrips is exceeded', async () => {
  const mockResponses: ModelMessage[] = Array(12).fill({
    role: 'assistant',
    content: [
      {
        type: 'tool-call',
        toolCallId: 'tool-call-1',
        toolName: 'listFiles',
        input: { path: './src' },
      },
    ],
  })

  const allTools = [listFilesTool]

  const tools: WorkflowTools<AgentToolRegistry> = {
    generateText: async () => {
      const response = mockResponses.shift()
      return [response!] as JsonResponseMessage[]
    },
    invokeTool: async (input) => {
      const { toolName, input: toolInput } = input
      const toolInfo = allTools.find((t) => t.name === toolName)
      if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
      return toolInfo.handler({} as any, toolInput)
    },
    taskEvent: async () => {},
  }

  const result = await agentWorkflow(
    {
      userMessage: [toJsonModelMessage({ role: 'user', content: 'List files.' })] as any,
      tools: allTools,
      systemPrompt: 'You are a helpful assistant.',
      maxToolRoundTrips: 10,
    },
    createContext(tools),
  )

  expect(result.type).toBe('UsageExceeded')
  expect(result.messages).toBeDefined()
  expect(result.messages.length).toBeGreaterThan(0)
})

test('should handle mixed valid and invalid tool calls by returning results for both', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'call-1',
          toolName: 'listFiles',
          input: { path: './src' },
        },
        {
          type: 'tool-call',
          toolCallId: 'call-2',
          toolName: 'invalidTool',
          input: { some: 'param' },
        },
      ],
    },
    {
      role: 'assistant',
      content: 'Result received.',
    },
  ]

  const allTools = [listFilesTool]

  // We need to capture the tool results sent back to the model
  let capturedToolResults: any[] = []

  const tools: WorkflowTools<AgentToolRegistry> = {
    generateText: async ({ messages }) => {
      // Check if the last message is a tool result message and capture it
      const lastMsg = messages[messages.length - 1]
      if (lastMsg.role === 'tool') {
        capturedToolResults = lastMsg.content as any[]
      }

      const response = mockResponses.shift()
      if (!response) {
        // Return a dummy response to stop the loop if we run out of mocks
        return [{ role: 'assistant', content: 'Done' }] as JsonResponseMessage[]
      }
      return [response] as JsonResponseMessage[]
    },
    invokeTool: async (input) => {
      const { toolName, input: toolInput } = input
      const toolInfo = allTools.find((t) => t.name === toolName)
      if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
      return toolInfo.handler({} as any, toolInput)
    },
    taskEvent: async () => {},
  }

  await agentWorkflow(
    {
      userMessage: [toJsonModelMessage({ role: 'user', content: 'Do things.' })] as any,
      tools: allTools,
      systemPrompt: 'You are a helpful assistant.',
    },
    createContext(tools),
  )

  expect(capturedToolResults).toMatchSnapshot()
})
