// generated by polka.codes
import { describe, expect, test } from 'bun:test'
import { z } from 'zod'
import { branchStepSpecHandler, combineHandlers, customStepSpecHandler, parallelStepSpecHandler, sequentialStepSpecHandler } from './steps'
import type { CustomStepSpec, Json, StepSpecHandler, WorkflowContext } from './types'

describe('steps', () => {
  const mockContext: WorkflowContext = { provider: {}, parameters: {} }
  const emptySchema = z.object({}).passthrough() as z.ZodType<Record<string, Json>>

  describe('combineHandlers', () => {
    test('should combine handlers and call the correct one', () => {
      const handler1: StepSpecHandler = {
        type: 'test1',
        handler: (step) => ({
          ...step,
          inputSchema: emptySchema,
          outputSchema: emptySchema,
          run: async () => ({ type: 'success', output: { value: 'test1' } }),
        }),
      }
      const handler2: StepSpecHandler = {
        type: 'test2',
        handler: (step) => ({
          ...step,
          inputSchema: emptySchema,
          outputSchema: emptySchema,
          run: async () => ({ type: 'success', output: { value: 'test2' } }),
        }),
      }
      const combined = combineHandlers(handler1, handler2)
      const rootHandler = (step: any, rh: any) => combined(step, rh)

      const step1 = { id: 'test1', type: 'test1', inputSchema: emptySchema, outputSchema: emptySchema } as any
      const runnable1 = combined(step1, rootHandler)
      expect(runnable1.run({ $: {} }, mockContext)).resolves.toEqual({ type: 'success', output: { value: 'test1' } })

      const step2 = { id: 'test2', type: 'test2', inputSchema: emptySchema, outputSchema: emptySchema } as any
      const runnable2 = combined(step2, rootHandler)
      expect(runnable2.run({ $: {} }, mockContext)).resolves.toEqual({ type: 'success', output: { value: 'test2' } })
    })

    test('should throw on duplicate handler types', () => {
      const handler1: StepSpecHandler = { type: 'test', handler: () => ({}) as any }
      const handler2: StepSpecHandler = { type: 'test', handler: () => ({}) as any }
      expect(() => combineHandlers(handler1, handler2)).toThrow('Handler with type test already exists')
    })

    test('should throw on unknown handler type', () => {
      const combined = combineHandlers()
      const rootHandler = (step: any, rh: any) => combined(step, rh)
      expect(() => combined({ id: 'unknown', type: 'unknown', inputSchema: emptySchema, outputSchema: emptySchema }, rootHandler)).toThrow(
        'No handler found for step type: unknown',
      )
    })
  })

  describe('sequentialStepSpecHandler', () => {
    test('should run steps in sequence and pass output', async () => {
      const step1 = {
        id: 'step1',
        run: async (input: any) => ({ type: 'success', output: { ...input, step1: true } }),
      }
      const step2 = {
        id: 'step2',
        run: async (input: any) => ({ type: 'success', output: { ...input, step2: true } }),
      }
      const rootHandler = (step: any) => (step.id === 'step1' ? step1 : step2)
      const handler = sequentialStepSpecHandler.handler({ id: 'seq', type: 'sequential', steps: [step1, step2] }, rootHandler as any)

      const result = await handler.run({ initial: true, $: {} }, mockContext)
      expect(result.type).toBe('success')
      if (result.type === 'success') {
        expect(result.output.initial).toBe(true)
        expect(result.output.step1).toBe(true)
        expect(result.output.step2).toBe(true)
        expect(result.output.$).toBeDefined()
      }
    })

    test('should pause and resume with new input', async () => {
      const step1 = {
        id: 'step1',
        run: async (input: { value: number }) => ({ type: 'success' as const, output: { value: input.value * 2 } }),
      }
      const step2 = {
        id: 'step2',
        run: async (input: { value: number }, _ctx: any, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused' as const, state: { a: 1 } }
          }
          return { type: 'success' as const, output: { value: input.value + 1 } }
        },
      }
      const rootHandler = (step: any) => (step.id === 'step1' ? step1 : step2)
      const handler = sequentialStepSpecHandler.handler(
        { id: 'seq', type: 'sequential', steps: [step1 as any, step2 as any] },
        rootHandler as any,
      )

      // Run and pause
      const pausedResult = await handler.run({ value: 10, $: {} }, mockContext)
      expect(pausedResult.type).toBe('paused')

      const pausedState = (pausedResult as any).state

      // Resume with new input
      const resumedResult = await handler.run({ value: 100, $: {} }, mockContext, pausedState)
      expect(resumedResult).toEqual({ type: 'success', output: { value: 101 } })
    })

    test('a step input can reference output from a previous step', async () => {
      const rootHandler = combineHandlers(customStepSpecHandler)

      const step1: CustomStepSpec = {
        id: 'step1',
        type: 'custom',
        run: async () => ({ type: 'success', output: { message: 'from step1' } }),
      }
      const step2: CustomStepSpec = {
        id: 'step2',
        type: 'custom',
        run: async (input: any) => ({ type: 'success', output: { ref: input.$.step1.message } }),
      }
      const step3: CustomStepSpec = {
        id: 'step3',
        type: 'custom',
        run: async (input: any) => ({ type: 'success', output: { value: input.ref } }),
      }

      const handler = sequentialStepSpecHandler.handler(
        {
          id: 'seq',
          type: 'sequential',
          steps: [step1, step2, step3],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ $: {} }, mockContext)
      expect(result).toEqual({ type: 'success', output: { value: 'from step1' } })
    })

    test('should resume with allOutputs', async () => {
      const step1: CustomStepSpec = {
        id: 'step1',
        type: 'custom',
        run: async () => ({ type: 'success', output: { message: 'from step1' } }),
      }
      const step2: CustomStepSpec = {
        id: 'step2',
        type: 'custom',
        run: async (input: any, _ctx: any, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused', state: { a: 1 } }
          }
          return { type: 'success', output: { ref: input.$.step1.message } }
        },
      }
      const step3: CustomStepSpec = {
        id: 'step3',
        type: 'custom',
        run: async (input) => ({ type: 'success', output: { value: input.ref } }),
      }

      const rootHandler = combineHandlers(customStepSpecHandler)
      const handler = sequentialStepSpecHandler.handler(
        {
          id: 'seq',
          type: 'sequential',
          steps: [step1, step2, step3],
        },
        (step, rh) => rootHandler(step, rh),
      )

      // Run and pause at step2
      const pausedResult = await handler.run({ $: {} }, mockContext)
      expect(pausedResult.type).toBe('paused')
      const pausedState = (pausedResult as any).state
      expect(pausedState.allOutputs.step1).toEqual({ message: 'from step1' })

      // Resume
      const resumedResult = await handler.run({ $: {} }, mockContext, pausedState)
      expect(resumedResult).toEqual({ type: 'success', output: { value: 'from step1' } })
    })
  })

  describe('parallelStepSpecHandler', () => {
    test('should run steps in parallel', async () => {
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>) => ({
          type: 'success',
          output: { result: (input as { value: number }).value * 2 },
        }),
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const result = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext)
      expect(result).toEqual({ type: 'success', output: { results: [{ result: 2 }, { result: 4 }, { result: 6 }] } })
    })

    test('should return an error if one of the steps fails', async () => {
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>) => {
          if ((input as { value: number }).value === 2) {
            return { type: 'error', error: 'Step failed' }
          }
          return {
            type: 'success',
            output: { result: (input as { value: number }).value * 2 },
          }
        },
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const result = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext)
      expect(result.type).toBe('error')
      expect((result as any).error).toBeInstanceOf(Error)
      expect((result as any).error.message).toBe('Multiple errors: Step failed')
    })

    test('should pause and resume', async () => {
      let runCount = 0
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>, _ctx, resumedState) => {
          runCount++
          if ((input as { value: number }).value === 2 && !resumedState) {
            return { type: 'paused', state: { a: 1 } }
          }
          return {
            type: 'success',
            output: { result: (input as { value: number }).value * 2 },
          }
        },
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const pausedResult = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext)
      expect(pausedResult.type).toBe('paused')
      expect(runCount).toBe(3)

      const pausedState = (pausedResult as any).state
      expect(pausedState).toEqual([
        { type: 'success', output: { result: 2 } },
        { type: 'paused', state: { a: 1 } },
        { type: 'success', output: { result: 6 } },
      ])

      runCount = 0
      const resumedResult = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext, pausedState)
      expect(resumedResult).toEqual({
        type: 'success',
        output: { results: [{ result: 2 }, { result: 4 }, { result: 6 }] },
      })
      // Only the paused step should run again
      expect(runCount).toBe(1)
    })
  })

  describe('branchStepSpecHandler', () => {
    test('selects the correct branch based on predicate', async () => {
      const branchOne: CustomStepSpec = {
        id: 'branchOne',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'one' } }),
      }
      const branchTwo: CustomStepSpec = {
        id: 'branchTwo',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'two' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: (input: any) => input.$.previous?.value === 'match',
              step: branchOne,
            },
            {
              id: 'second',
              when: () => true,
              step: branchTwo,
            },
          ],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ flag: 'ignored', $: { previous: { value: 'match' } } }, mockContext)
      expect(result).toEqual({ type: 'success', output: { chosen: 'one' } })
    })

    test('uses otherwise branch when no predicate matches', async () => {
      const branchOne: CustomStepSpec = {
        id: 'branchOne',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'one' } }),
      }
      const otherwiseStep: CustomStepSpec = {
        id: 'otherwise',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'otherwise' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: () => false,
              step: branchOne,
            },
          ],
          otherwise: otherwiseStep,
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ $: {} }, mockContext)
      expect(result).toEqual({ type: 'success', output: { chosen: 'otherwise' } })
    })

    test('resumes the previously selected branch', async () => {
      const branchOne: CustomStepSpec = {
        id: 'branchOne',
        type: 'custom',
        run: async (input: Record<string, Json>, _context, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused' as const, state: { paused: true } }
          }
          return { type: 'success' as const, output: { resumedWith: input.flag } }
        },
      }
      const branchTwo: CustomStepSpec = {
        id: 'branchTwo',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'two' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: (input: any) => input.flag === 'one',
              step: branchOne,
            },
            {
              id: 'second',
              when: () => true,
              step: branchTwo,
            },
          ],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const paused = await handler.run({ flag: 'one', $: {} }, mockContext)
      expect(paused.type).toBe('paused')
      const pausedState = (paused as any).state
      expect(pausedState).toEqual({ branchIndex: 0, stepState: { paused: true } })

      const resumed = await handler.run({ flag: 'changed', $: {} }, mockContext, pausedState)
      expect(resumed).toEqual({ type: 'success', output: { resumedWith: 'changed' } })
    })
  })

  describe('customStepSpecHandler', () => {
    test('should call the custom run function', async () => {
      const customStep: CustomStepSpec = {
        id: 'custom',
        type: 'custom',
        inputSchema: emptySchema,
        outputSchema: emptySchema,
        run: async (input, context) => {
          return { type: 'success', output: { ...input, custom: true, contextReceived: !!context } }
        },
      }
      const handler = customStepSpecHandler.handler(customStep, () => ({}) as any)
      const result = await handler.run({ initial: true, $: {} }, mockContext)
      expect(result).toEqual({
        type: 'success',
        output: { $: {}, initial: true, custom: true, contextReceived: true },
      })
    })
  })
})
