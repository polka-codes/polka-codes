// generated by polka.codes
import { describe, expect, test } from 'bun:test'
import { z } from 'zod'
import { combineHandlers, customStepSpecHandler, parallelStepSpecHandler, sequentialStepSpecHandler } from './steps'
import type { CustomStepSpec, Json, StepSpecHandler, WorkflowContext } from './types'

describe('steps', () => {
  const mockContext: WorkflowContext = { provider: {}, parameters: {} }
  const emptySchema = z.object({}).passthrough() as z.ZodType<Record<string, Json>>

  describe('combineHandlers', () => {
    test('should combine handlers and call the correct one', () => {
      const handler1: StepSpecHandler = {
        type: 'test1',
        handler: (step) => ({
          ...step,
          inputSchema: emptySchema,
          outputSchema: emptySchema,
          run: async () => ({ type: 'success', output: { value: 'test1' } }),
        }),
      }
      const handler2: StepSpecHandler = {
        type: 'test2',
        handler: (step) => ({
          ...step,
          inputSchema: emptySchema,
          outputSchema: emptySchema,
          run: async () => ({ type: 'success', output: { value: 'test2' } }),
        }),
      }
      const combined = combineHandlers(handler1, handler2)
      const rootHandler = (step: any, rh: any) => combined(step, rh)

      const step1 = { id: 'test1', type: 'test1', inputSchema: emptySchema, outputSchema: emptySchema } as any
      const runnable1 = combined(step1, rootHandler)
      expect(runnable1.run({}, mockContext)).resolves.toEqual({ type: 'success', output: { value: 'test1' } })

      const step2 = { id: 'test2', type: 'test2', inputSchema: emptySchema, outputSchema: emptySchema } as any
      const runnable2 = combined(step2, rootHandler)
      expect(runnable2.run({}, mockContext)).resolves.toEqual({ type: 'success', output: { value: 'test2' } })
    })

    test('should throw on duplicate handler types', () => {
      const handler1: StepSpecHandler = { type: 'test', handler: () => ({}) as any }
      const handler2: StepSpecHandler = { type: 'test', handler: () => ({}) as any }
      expect(() => combineHandlers(handler1, handler2)).toThrow('Handler with type test already exists')
    })

    test('should throw on unknown handler type', () => {
      const combined = combineHandlers()
      const rootHandler = (step: any, rh: any) => combined(step, rh)
      expect(() => combined({ id: 'unknown', type: 'unknown', inputSchema: emptySchema, outputSchema: emptySchema }, rootHandler)).toThrow(
        'No handler found for step type: unknown',
      )
    })
  })

  describe('sequentialStepSpecHandler', () => {
    const baseStep = {
      inputSchema: emptySchema,
      outputSchema: emptySchema,
    }
    test('should run steps in sequence and pass output', async () => {
      const step1 = {
        ...baseStep,
        id: 'step1',
        run: async (input: any) => ({ type: 'success', output: { ...input, step1: true } }),
      }
      const step2 = {
        ...baseStep,
        id: 'step2',
        run: async (input: any) => ({ type: 'success', output: { ...input, step2: true } }),
      }
      const rootHandler = (step: any) => (step.id === 'step1' ? step1 : step2)
      const handler = sequentialStepSpecHandler.handler(
        { ...baseStep, id: 'seq', type: 'sequential', steps: [step1 as any, step2 as any] },
        rootHandler as any,
      )

      const result = await handler.run({ initial: true }, mockContext)
      expect(result).toEqual({ type: 'success', output: { initial: true, step1: true, step2: true } })
    })

    test('should pause and resume with new input', async () => {
      const step1 = {
        ...baseStep,
        id: 'step1',
        run: async (input: { value: number }) => ({ type: 'success' as const, output: { value: input.value * 2 } }),
      }
      const step2 = {
        ...baseStep,
        id: 'step2',
        run: async (input: { value: number }, _ctx: any, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused' as const, state: { a: 1 } }
          }
          return { type: 'success' as const, output: { value: input.value + 1 } }
        },
      }
      const rootHandler = (step: any) => (step.id === 'step1' ? step1 : step2)
      const handler = sequentialStepSpecHandler.handler(
        { ...baseStep, id: 'seq', type: 'sequential', steps: [step1 as any, step2 as any] },
        rootHandler as any,
      )

      // Run and pause
      const pausedResult = await handler.run({ value: 10 }, mockContext)
      expect(pausedResult.type).toBe('paused')

      const pausedState = (pausedResult as any).state

      // Resume with new input
      const resumedResult = await handler.run({ value: 100 }, mockContext, pausedState)
      expect(resumedResult).toEqual({ type: 'success', output: { value: 101 } })
    })

    test('a step input can reference output from a previous step', async () => {
      const rootHandler = combineHandlers(customStepSpecHandler)

      const step1: CustomStepSpec = {
        ...baseStep,
        id: 'step1',
        type: 'custom',
        run: async () => ({ type: 'success', output: { message: 'from step1' } }),
      }
      const step2: CustomStepSpec = {
        ...baseStep,
        id: 'step2',
        type: 'custom',
        run: async () => ({ type: 'success', output: { ref: '$.step1.message' } }),
      }
      const step3: CustomStepSpec = {
        ...baseStep,
        id: 'step3',
        type: 'custom',
        run: async (input: any) => ({ type: 'success', output: { value: input.ref } }),
      }

      const handler = sequentialStepSpecHandler.handler(
        {
          ...baseStep,
          id: 'seq',
          type: 'sequential',
          steps: [step1, step2, step3],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({}, mockContext)
      expect(result).toEqual({ type: 'success', output: { value: 'from step1' } })
    })

    test('should resume with allOutputs', async () => {
      const step1: CustomStepSpec = {
        ...baseStep,
        id: 'step1',
        type: 'custom',
        run: async () => ({ type: 'success', output: { message: 'from step1' } }),
      }
      const step2: CustomStepSpec = {
        ...baseStep,
        id: 'step2',
        type: 'custom',
        run: async (_input: any, _ctx: any, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused', state: { a: 1 } }
          }
          return { type: 'success', output: { ref: '$.step1.message' } }
        },
      }
      const step3: CustomStepSpec = {
        ...baseStep,
        id: 'step3',
        type: 'custom',
        run: async (input: any) => ({ type: 'success', output: { value: input.ref } }),
      }

      const rootHandler = combineHandlers(customStepSpecHandler)
      const handler = sequentialStepSpecHandler.handler(
        {
          ...baseStep,
          id: 'seq',
          type: 'sequential',
          steps: [step1, step2, step3],
        },
        (step, rh) => rootHandler(step, rh),
      )

      // Run and pause at step2
      const pausedResult = await handler.run({}, mockContext)
      expect(pausedResult.type).toBe('paused')
      const pausedState = (pausedResult as any).state
      expect(pausedState.allOutputs.step1).toEqual({ message: 'from step1' })

      // Resume
      const resumedResult = await handler.run({}, mockContext, pausedState)
      expect(resumedResult).toEqual({ type: 'success', output: { value: 'from step1' } })
    })
  })

  describe('parallelStepSpecHandler', () => {
    test('should run steps in parallel', async () => {
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>) => ({
          type: 'success',
          output: { result: (input as { value: number }).value * 2 },
        }),
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const result = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }] }, mockContext)
      expect(result).toEqual({ type: 'success', output: { results: [{ result: 2 }, { result: 4 }, { result: 6 }] } })
    })

    // More tests for parallel steps (error, pause) would go here
  })

  describe('customStepSpecHandler', () => {
    test('should call the custom run function', async () => {
      const customStep: CustomStepSpec = {
        id: 'custom',
        type: 'custom',
        inputSchema: emptySchema,
        outputSchema: emptySchema,
        run: async (input, context) => {
          return { type: 'success', output: { ...input, custom: true, contextReceived: !!context } }
        },
      }
      const handler = customStepSpecHandler.handler(customStep, () => ({}) as any)
      const result = await handler.run({ initial: true }, mockContext)
      expect(result).toEqual({
        type: 'success',
        output: { initial: true, custom: true, contextReceived: true },
      })
    })
  })
})
