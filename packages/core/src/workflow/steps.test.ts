// generated by polka.codes
import { describe, expect, test } from 'bun:test'
import { z } from 'zod'
import {
  branchStepSpecHandler,
  combineHandlers,
  customStepSpecHandler,
  loopStepSpecHandler,
  parallelStepSpecHandler,
  sequentialStepSpecHandler,
  workflowStepSpecHandler,
} from './steps'
import type { CustomStepSpec, Json, LoopStepSpec, StepRunResult, StepSpecHandler, WorkflowContext, WorkflowSpec } from './types'

describe('steps', () => {
  const mockContext: WorkflowContext = { provider: {}, parameters: {} }
  const emptySchema = z.object({}).passthrough() as z.ZodType<Record<string, Json>>

  describe('combineHandlers', () => {
    test('should combine handlers and call the correct one', () => {
      const handler1: StepSpecHandler = {
        type: 'test1',
        handler: (step) => ({
          ...step,
          inputSchema: emptySchema,
          outputSchema: emptySchema,
          run: async () => ({ type: 'success', output: { value: 'test1' } }),
        }),
      }
      const handler2: StepSpecHandler = {
        type: 'test2',
        handler: (step) => ({
          ...step,
          inputSchema: emptySchema,
          outputSchema: emptySchema,
          run: async () => ({ type: 'success', output: { value: 'test2' } }),
        }),
      }
      const combined = combineHandlers(handler1, handler2)
      const rootHandler = (step: any, rh: any) => combined(step, rh)

      const step1 = { id: 'test1', type: 'test1', inputSchema: emptySchema, outputSchema: emptySchema } as any
      const runnable1 = combined(step1, rootHandler)
      expect(runnable1.run({ $: {} }, mockContext)).resolves.toEqual({ type: 'success', output: { value: 'test1' } })

      const step2 = { id: 'test2', type: 'test2', inputSchema: emptySchema, outputSchema: emptySchema } as any
      const runnable2 = combined(step2, rootHandler)
      expect(runnable2.run({ $: {} }, mockContext)).resolves.toEqual({ type: 'success', output: { value: 'test2' } })
    })

    test('should throw on duplicate handler types', () => {
      const handler1: StepSpecHandler = { type: 'test', handler: () => ({}) as any }
      const handler2: StepSpecHandler = { type: 'test', handler: () => ({}) as any }
      expect(() => combineHandlers(handler1, handler2)).toThrow('Handler with type test already exists')
    })

    test('should throw on unknown handler type', () => {
      const combined = combineHandlers()
      const rootHandler = (step: any, rh: any) => combined(step, rh)
      expect(() => combined({ id: 'unknown', type: 'unknown', inputSchema: emptySchema, outputSchema: emptySchema }, rootHandler)).toThrow(
        'No handler found for step type: unknown',
      )
    })
  })

  describe('sequentialStepSpecHandler', () => {
    test('should run steps in sequence and pass output', async () => {
      const step1 = {
        id: 'step1',
        run: async (input: any) => ({ type: 'success', output: { ...input, step1: true } }),
      }
      const step2 = {
        id: 'step2',
        run: async (input: any) => ({ type: 'success', output: { ...input, step2: true } }),
      }
      const rootHandler = (step: any) => (step.id === 'step1' ? step1 : step2)
      const handler = sequentialStepSpecHandler.handler({ id: 'seq', type: 'sequential', steps: [step1, step2] }, rootHandler as any)

      const result = await handler.run({ initial: true, $: {} }, mockContext)
      expect(result.type).toBe('success')
      if (result.type === 'success') {
        expect(result.output.initial).toBe(true)
        expect(result.output.step1).toBe(true)
        expect(result.output.step2).toBe(true)
        expect(result.output.$).toBeDefined()
      }
    })

    test('should pause and resume with new input', async () => {
      const step1 = {
        id: 'step1',
        run: async (input: { value: number }) => ({ type: 'success' as const, output: { value: input.value * 2 } }),
      }
      const step2 = {
        id: 'step2',
        run: async (input: { value: number }, _ctx: any, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused' as const, state: { a: 1 } }
          }
          return { type: 'success' as const, output: { value: input.value + 1 } }
        },
      }
      const rootHandler = (step: any) => (step.id === 'step1' ? step1 : step2)
      const handler = sequentialStepSpecHandler.handler(
        { id: 'seq', type: 'sequential', steps: [step1 as any, step2 as any] },
        rootHandler as any,
      )

      // Run and pause
      const pausedResult = await handler.run({ value: 10, $: {} }, mockContext)
      expect(pausedResult.type).toBe('paused')

      const pausedState = (pausedResult as any).state

      // Resume with new input
      const resumedResult = await handler.run({ value: 100, $: {} }, mockContext, pausedState)
      expect(resumedResult).toEqual({ type: 'success', output: { value: 101 } })
    })

    test('a step input can reference output from a previous step', async () => {
      const rootHandler = combineHandlers(customStepSpecHandler)

      const step1: CustomStepSpec = {
        id: 'step1',
        type: 'custom',
        run: async () => ({ type: 'success', output: { message: 'from step1' } }),
      }
      const step2: CustomStepSpec = {
        id: 'step2',
        type: 'custom',
        run: async (input: any) => ({ type: 'success', output: { ref: input.$.step1.message } }),
      }
      const step3: CustomStepSpec = {
        id: 'step3',
        type: 'custom',
        run: async (input: any) => ({ type: 'success', output: { value: input.ref } }),
      }

      const handler = sequentialStepSpecHandler.handler(
        {
          id: 'seq',
          type: 'sequential',
          steps: [step1, step2, step3],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ $: {} }, mockContext)
      expect(result).toEqual({ type: 'success', output: { value: 'from step1' } })
    })

    test('should resume with allOutputs', async () => {
      const step1: CustomStepSpec = {
        id: 'step1',
        type: 'custom',
        run: async () => ({ type: 'success', output: { message: 'from step1' } }),
      }
      const step2: CustomStepSpec = {
        id: 'step2',
        type: 'custom',
        run: async (input: any, _ctx: any, resumedState?: any) => {
          if (!resumedState) {
            return { type: 'paused', state: { a: 1 } }
          }
          return { type: 'success', output: { ref: input.$.step1.message } }
        },
      }
      const step3: CustomStepSpec = {
        id: 'step3',
        type: 'custom',
        run: async (input) => ({ type: 'success', output: { value: input.ref } }),
      }

      const rootHandler = combineHandlers(customStepSpecHandler)
      const handler = sequentialStepSpecHandler.handler(
        {
          id: 'seq',
          type: 'sequential',
          steps: [step1, step2, step3],
        },
        (step, rh) => rootHandler(step, rh),
      )

      // Run and pause at step2
      const pausedResult = await handler.run({ $: {} }, mockContext)
      expect(pausedResult.type).toBe('paused')
      const pausedState = (pausedResult as any).state
      expect(pausedState.allOutputs.step1).toEqual({ message: 'from step1' })

      // Resume
      const resumedResult = await handler.run({ $: {} }, mockContext, pausedState)
      expect(resumedResult).toEqual({ type: 'success', output: { value: 'from step1' } })
    })
  })

  describe('workflowStepSpecHandler', () => {
    test('runs nested workflow and maps input/output while preserving context', async () => {
      const childContexts: WorkflowContext[] = []
      const childWorkflow: WorkflowSpec<{ childValue: number }, { doubled: number }> = {
        name: 'child',
        step: {
          id: 'child-step',
          type: 'custom',
          run: async (input: { childValue: number }, ctx) => {
            childContexts.push(ctx)
            return { type: 'success', output: { doubled: input.childValue * 2 } }
          },
        } as CustomStepSpec<{ childValue: number }, { doubled: number }>,
      }

      const combined = combineHandlers(sequentialStepSpecHandler, customStepSpecHandler, workflowStepSpecHandler)
      const rootHandler = (step: any, rh: any) => combined(step, rh)

      const handler = workflowStepSpecHandler.handler(
        {
          id: 'child-runner',
          type: 'workflow',
          workflow: childWorkflow,
          mapInput: (input: { value: number }) => ({ childValue: input.value }),
          mapOutput: ({ workflowOutput }) => ({ total: workflowOutput.doubled }),
        },
        rootHandler as any,
      )

      const context: WorkflowContext = { provider: {}, parameters: { nested: true } }
      const result = await handler.run({ value: 3, $: {} }, context)

      expect(result).toEqual({ type: 'success', output: { total: 6 } })
      expect(childContexts).toHaveLength(1)
      expect(childContexts[0]).toBe(context)
    })

    test('pauses and resumes nested workflow with new input', async () => {
      const childContexts: WorkflowContext[] = []
      let observedWorkflowInput: number | undefined
      const childWorkflow: WorkflowSpec<{ childValue: number }, { doubled: number }> = {
        name: 'child',
        step: {
          id: 'child-step',
          type: 'custom',
          run: async (input: { childValue: number }, ctx, resumedState?: any) => {
            childContexts.push(ctx)
            if (!resumedState) {
              return { type: 'paused' as const, state: { attempt: input.childValue } }
            }
            return { type: 'success' as const, output: { doubled: input.childValue * 2 } }
          },
        } as CustomStepSpec<{ childValue: number }, { doubled: number }>,
      }

      const combined = combineHandlers(sequentialStepSpecHandler, customStepSpecHandler, workflowStepSpecHandler)
      const rootHandler = (step: any, rh: any) => combined(step, rh)

      const handler = workflowStepSpecHandler.handler(
        {
          id: 'child-runner',
          type: 'workflow',
          workflow: childWorkflow,
          mapInput: (input: { value: number }) => ({ childValue: input.value }),
          mapOutput: ({ workflowInput, workflowOutput }) => {
            observedWorkflowInput = workflowInput.childValue
            return { total: workflowOutput.doubled }
          },
        },
        rootHandler as any,
      )

      const context: WorkflowContext = { provider: {}, parameters: { nested: true } }
      const paused = await handler.run({ value: 2, $: {} }, context)
      expect(paused.type).toBe('paused')
      const pausedState = (paused as any).state
      expect(pausedState.workflowState).toEqual({ attempt: 2 })

      const resumed = await handler.run({ value: 5, $: {} }, context, pausedState)
      expect(resumed).toEqual({ type: 'success', output: { total: 10 } })
      expect(observedWorkflowInput).toBe(5)
      expect(childContexts).toHaveLength(2)
      expect(childContexts[0]).toBe(context)
      expect(childContexts[1]).toBe(context)
    })
  })

  describe('parallelStepSpecHandler', () => {
    test('should run steps in parallel', async () => {
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>) => ({
          type: 'success',
          output: { result: (input as { value: number }).value * 2 },
        }),
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const result = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext)
      expect(result).toEqual({ type: 'success', output: { results: [{ result: 2 }, { result: 4 }, { result: 6 }] } })
    })

    test('should return an error if one of the steps fails', async () => {
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>) => {
          if ((input as { value: number }).value === 2) {
            return { type: 'error', error: 'Step failed' }
          }
          return {
            type: 'success',
            output: { result: (input as { value: number }).value * 2 },
          }
        },
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const result = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext)
      expect(result.type).toBe('error')
      expect((result as any).error).toBeInstanceOf(Error)
      expect((result as any).error.message).toBe('Multiple errors: Step failed')
    })

    test('should pause and resume', async () => {
      let runCount = 0
      const innerStep: CustomStepSpec = {
        id: 'inner',
        type: 'custom',
        inputSchema: z.object({ value: z.number() }) as any,
        outputSchema: z.object({ result: z.number() }) as any,
        run: async (input: Record<string, Json>, _ctx, resumedState) => {
          runCount++
          if ((input as { value: number }).value === 2 && !resumedState) {
            return { type: 'paused', state: { a: 1 } }
          }
          return {
            type: 'success',
            output: { result: (input as { value: number }).value * 2 },
          }
        },
      }
      const rootHandler = () => innerStep
      const handler = parallelStepSpecHandler.handler(
        {
          id: 'par',
          type: 'parallel',
          step: innerStep as any,
          inputSchema: z.object({ items: z.array(z.any()) }),
          outputSchema: z.object({ results: z.array(z.any()) }),
        },
        rootHandler as any,
      )

      const pausedResult = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext)
      expect(pausedResult.type).toBe('paused')
      expect(runCount).toBe(3)

      const pausedState = (pausedResult as any).state
      expect(pausedState).toEqual([
        { type: 'success', output: { result: 2 } },
        { type: 'paused', state: { a: 1 } },
        { type: 'success', output: { result: 6 } },
      ])

      runCount = 0
      const resumedResult = await handler.run({ items: [{ value: 1 }, { value: 2 }, { value: 3 }], $: {} }, mockContext, pausedState)
      expect(resumedResult).toEqual({
        type: 'success',
        output: { results: [{ result: 2 }, { result: 4 }, { result: 6 }] },
      })
      // Only the paused step should run again
      expect(runCount).toBe(1)
    })
  })

  describe('branchStepSpecHandler', () => {
    type BranchInput = {
      flag?: string
      $: {
        previous?: {
          value?: string
        }
      }
    }

    const isBranchPausedResult = (
      result: StepRunResult<Record<string, Json>>,
    ): result is Extract<StepRunResult<Record<string, Json>>, { type: 'paused'; state: { branchIndex: number } }> =>
      result.type === 'paused' && typeof result.state === 'object' && result.state !== null && 'branchIndex' in result.state

    test('selects the correct branch based on predicate', async () => {
      const branchOne: CustomStepSpec<BranchInput> = {
        id: 'branchOne',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'one' } }),
      }
      const branchTwo: CustomStepSpec<BranchInput> = {
        id: 'branchTwo',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'two' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: (input: BranchInput) => input.$.previous?.value === 'match',
              step: branchOne,
            },
            {
              id: 'second',
              when: () => true,
              step: branchTwo,
            },
          ],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ flag: 'ignored', $: { previous: { value: 'match' } } }, mockContext)
      expect(result).toEqual({ type: 'success', output: { chosen: 'one' } })
    })

    test('uses otherwise branch when no predicate matches', async () => {
      const branchOne: CustomStepSpec<BranchInput> = {
        id: 'branchOne',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'one' } }),
      }
      const otherwiseStep: CustomStepSpec<BranchInput> = {
        id: 'otherwise',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'otherwise' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: () => false,
              step: branchOne,
            },
          ],
          otherwise: otherwiseStep,
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ $: {} }, mockContext)
      expect(result).toEqual({ type: 'success', output: { chosen: 'otherwise' } })
    })

    test('returns an error when no predicate matches and no otherwise branch exists', async () => {
      const branchOne: CustomStepSpec<BranchInput> = {
        id: 'branchOne',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'one' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: () => false,
              step: branchOne,
            },
          ],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const result = await handler.run({ $: {} }, mockContext)
      expect(result.type).toBe('error')
      if (result.type === 'error') {
        expect(result.error).toBeInstanceOf(Error)
        expect(result.error.message).toBe('No branch predicate matched and no otherwise branch provided')
      }
    })

    test('resumes the previously selected branch', async () => {
      const branchOne: CustomStepSpec<BranchInput, { resumedWith: string }> = {
        id: 'branchOne',
        type: 'custom',
        run: async (input: BranchInput, _context, resumedState?: { paused: boolean }) => {
          if (!resumedState) {
            return { type: 'paused' as const, state: { paused: true } }
          }
          return { type: 'success' as const, output: { resumedWith: input.flag ?? 'unknown' } }
        },
      }
      const branchTwo: CustomStepSpec<BranchInput> = {
        id: 'branchTwo',
        type: 'custom',
        run: async () => ({ type: 'success', output: { chosen: 'two' } }),
      }

      const rootHandler = combineHandlers(branchStepSpecHandler, customStepSpecHandler)
      const handler = branchStepSpecHandler.handler(
        {
          id: 'branchRoot',
          type: 'branch',
          branches: [
            {
              id: 'first',
              when: (input: BranchInput) => input.flag === 'one',
              step: branchOne,
            },
            {
              id: 'second',
              when: () => true,
              step: branchTwo,
            },
          ],
        },
        (step, rh) => rootHandler(step, rh),
      )

      const paused = await handler.run({ flag: 'one', $: {} }, mockContext)
      expect(paused.type).toBe('paused')
      if (!isBranchPausedResult(paused)) {
        throw new Error('Expected paused branch result')
      }
      expect(paused.state).toEqual({ branchIndex: 0, stepState: { paused: true } })

      const resumed = await handler.run({ flag: 'changed', $: {} }, mockContext, paused.state)
      expect(resumed).toEqual({ type: 'success', output: { resumedWith: 'changed' } })
    })
  })

  describe('customStepSpecHandler', () => {
    test('should call the custom run function', async () => {
      const customStep: CustomStepSpec = {
        id: 'custom',
        type: 'custom',
        inputSchema: emptySchema,
        outputSchema: emptySchema,
        run: async (input, context) => {
          return { type: 'success', output: { ...input, custom: true, contextReceived: !!context } }
        },
      }
      const handler = customStepSpecHandler.handler(customStep, () => ({}) as any)
      const result = await handler.run({ initial: true, $: {} }, mockContext)
      expect(result).toEqual({
        type: 'success',
        output: { $: {}, initial: true, custom: true, contextReceived: true },
      })
    })
  })

  describe('loopStepSpecHandler', () => {
    const rootHandler = combineHandlers(customStepSpecHandler, loopStepSpecHandler)

    test('runs inner step multiple times with while predicate', async () => {
      const innerStep: CustomStepSpec<{ value: number }, { value: number }> = {
        id: 'increment',
        type: 'custom',
        run: async (iterationInput) => ({
          type: 'success',
          output: { value: (iterationInput as { value: number }).value + 1 },
        }),
      }

      const loopSpec: LoopStepSpec<{ start: number }, { value: number }> = {
        id: 'loop',
        type: 'loop',
        step: innerStep,
        while: (state) => state.iteration < 3,
        mapInput: (state) => ({ value: state.iteration === 0 ? state.input.start : (state.last as { value: number }).value }),
      }

      const handler = loopStepSpecHandler.handler(loopSpec, (step, rh) => rootHandler(step, rh))

      const result = await handler.run({ start: 0, $: {} }, mockContext)
      expect(result.type).toBe('success')
      if (result.type === 'success') {
        expect(result.output.results).toHaveLength(3)
        expect(result.output.last).toEqual({ value: 3 })
      }
    })

    test('terminates when until predicate returns true', async () => {
      const innerStep: CustomStepSpec<{ count: number }, { count: number }> = {
        id: 'counter',
        type: 'custom',
        run: async (iterationInput) => ({
          type: 'success',
          output: { count: (iterationInput as { count: number }).count + 1 },
        }),
      }

      const loopSpec: LoopStepSpec<{ count: number }, { count: number }> = {
        id: 'loop',
        type: 'loop',
        step: innerStep,
        until: (state) => Boolean(state.last && (state.last as { count: number }).count >= 3),
      }

      const handler = loopStepSpecHandler.handler(loopSpec, (step, rh) => rootHandler(step, rh))

      const result = await handler.run({ count: 0, $: {} }, mockContext)
      expect(result.type).toBe('success')
      if (result.type === 'success') {
        expect(result.output.results).toHaveLength(3)
        expect(result.output.last).toEqual({ count: 3 })
      }
    })

    test('throws when exceeding maxIterations with active predicate', async () => {
      const innerStep: CustomStepSpec<{ value: number }, { value: number }> = {
        id: 'increment',
        type: 'custom',
        run: async (iterationInput) => ({
          type: 'success',
          output: { value: (iterationInput as { value: number }).value + 1 },
        }),
      }

      const loopSpec: LoopStepSpec<{ value: number }, { value: number }> = {
        id: 'loop',
        type: 'loop',
        step: innerStep,
        while: () => true,
        maxIterations: 2,
      }

      const handler = loopStepSpecHandler.handler(loopSpec, (step, rh) => rootHandler(step, rh))

      const result = await handler.run({ value: 0, $: {} }, mockContext)
      expect(result.type).toBe('error')
      if (result.type === 'error') {
        expect(result.error).toBeInstanceOf(Error)
        expect((result.error as Error).message).toContain('max iterations')
      }
    })

    test('pauses and resumes with preserved iteration state', async () => {
      const innerStep: CustomStepSpec<{ value: number; pause?: boolean }, { value: number }> = {
        id: 'maybePause',
        type: 'custom',
        run: async (iterationInput, _ctx, resumedState) => {
          const inputValue = iterationInput as { value: number; pause?: boolean }
          if (inputValue.pause && !resumedState) {
            return { type: 'paused', state: { resume: true } } as const
          }
          return { type: 'success', output: { value: inputValue.value + 1 } } as const
        },
      }

      const loopSpec: LoopStepSpec<{ start: number }, { value: number }> = {
        id: 'loop',
        type: 'loop',
        step: innerStep,
        while: (state) => state.iteration < 2,
        mapInput: (state) => {
          if (state.iteration === 0) {
            return { value: state.input.start }
          }
          return { value: (state.last as { value: number }).value, pause: true }
        },
      }

      const handler = loopStepSpecHandler.handler(loopSpec, (step, rh) => rootHandler(step, rh))

      const paused = await handler.run({ start: 0, $: {} }, mockContext)
      expect(paused.type).toBe('paused')
      if (paused.type !== 'paused') {
        throw new Error('expected pause')
      }
      expect(paused.state.iteration).toBe(1)
      expect(paused.state.results).toEqual([{ value: 1 }])

      const resumed = await handler.run({ start: 0, $: {} }, mockContext, paused.state)
      expect(resumed.type).toBe('success')
      if (resumed.type === 'success') {
        expect(resumed.output.results).toEqual([{ value: 1 }, { value: 2 }])
        expect(resumed.output.last).toEqual({ value: 2 })
      }
    })
  })
})
