// generated by polka.codes

import { getProvider, printEvent } from '@polka-codes/cli-shared'
import { UsageMeter } from '@polka-codes/core'
import {
  type Logger,
  makeStepFn,
  type ToolRegistry,
  type WorkflowContext,
  type WorkflowFn,
  type WorkflowTools,
} from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash-es'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, toolCall } from './tool-implementations'

type RunWorkflowOptions = {
  commandName: string
  command: Command
  logger: Logger
  requiresProvider?: boolean
  yes?: boolean
}

export async function runWorkflow<TInput, TOutput, TTools extends ToolRegistry>(
  workflow: WorkflowFn<TInput, TOutput, TTools>,
  workflowInput: TInput,
  options: RunWorkflowOptions,
): Promise<TOutput | undefined> {
  const { commandName, command, logger, requiresProvider = true, yes } = options
  const globalOpts = (command.parent ?? command).opts()
  const { providerConfig, config, verbose } = parseOptions(globalOpts, {})

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
      process.exit(1)
    }
    logger.info('Provider:', commandConfig.provider)
    logger.info('Model:', commandConfig.model)
  }

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), {
    maxMessages: config.maxMessageCount,
    maxCost: config.budget,
  })
  const onEvent = printEvent(verbose, usage, process.stderr)
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const commandConfig = providerConfig.getConfigForCommand(commandName)
  if (!commandConfig) {
    throw new Error(`No provider configured for command: ${commandName}`)
  }
  const model = getModel(commandConfig)

  const providerOptions = getProviderOptions({
    provider: commandConfig.provider,
    modelId: commandConfig.model,
    parameters: commandConfig.parameters,
  })

  const parameters: AgentContextParameters = {
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  const tools = new Proxy({} as WorkflowTools<TTools>, {
    get: (_target, tool: string) => {
      return async (input: any) => {
        logger.debug(`Running tool: ${tool}`)
        return await toolCall(
          { tool: tool as any, input },
          {
            parameters,
            model,
            agentCallback: onEvent,
            toolProvider,
            command,
            yes,
          },
        )
      }
    },
  })

  const context: WorkflowContext<TTools> = {
    step: makeStepFn(),
    logger,
    tools,
  }

  try {
    logger.info('Running workflow...')
    const output = await workflow(workflowInput, context)
    logger.info('Workflow completed successfully.')
    logger.info(usage.getUsageText())
    return output
  } catch (e) {
    const error = e as any
    if (error instanceof UserCancelledError) {
      logger.warn('Workflow cancelled by user.')
    } else {
      logger.error(`Workflow failed: ${error.message}`)
      logger.error(error)
    }
    logger.info(usage.getUsageText())
    return undefined
  }
}
