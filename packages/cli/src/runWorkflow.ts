// generated by polka.codes

import { mkdir } from 'node:fs/promises'
import { dirname } from 'node:path'
import {
  detectProjectScope,
  getGlobalConfigPath,
  getProvider,
  loadConfigAtPath,
  logGlobalToolCallStats,
  MemoryManager,
  type ProviderOptions,
  printEvent,
  SQLiteMemoryStore,
} from '@polka-codes/cli-shared'
import {
  DEFAULT_MEMORY_CONFIG,
  type Logger,
  makeStepFn,
  resolveHomePath,
  search,
  type TaskEventCallback,
  TaskEventKind,
  type ToolProvider,
  type ToolRegistry,
  UsageMeter,
  type WorkflowContext,
  type WorkflowFn,
  type WorkflowTools,
} from '@polka-codes/core'
import { merge } from 'lodash-es'
import { AuthenticationError, ModelAccessError, ProviderError, QuotaExceededError, UserCancelledError } from './errors'
import { AiProvider, getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { McpError } from './mcp/errors'
import { McpManager } from './mcp/manager'
import { type CliOptions, parseOptions } from './options'
import prices from './prices'
import {
  type AgentContextParameters,
  initializeSkillContext,
  localToolNames,
  type ToolCallContext,
  toolCall,
  toolHandlers,
} from './tool-implementations'
import type { BaseWorkflowInput } from './workflows'

/**
 * Execution context for running workflows.
 * This replaces the Commander.js Command object, making the code
 * usable both from CLI and as a scripting API.
 */
export interface ExecutionContext extends CliOptions {
  // All CLI options are inherited from CliOptions
}

type RunWorkflowOptions = {
  commandName: string
  context: ExecutionContext
  logger: Logger
  interactive?: boolean
  getProvider?: (args: ProviderOptions) => ToolProvider
  onUsageMeterCreated?: (meter: UsageMeter) => void
  /** Optional provider/model override for this workflow execution */
  providerOverride?: {
    provider?: string
    model?: string
    parameters?: Record<string, unknown>
  }
}

export async function runWorkflow<TInput, TOutput, TTools extends ToolRegistry>(
  workflow: WorkflowFn<TInput & BaseWorkflowInput, TOutput, TTools>,
  workflowInput: TInput,
  options: RunWorkflowOptions,
): Promise<TOutput | undefined> {
  const { commandName, context, logger, interactive, providerOverride } = options
  const { providerConfig, config, verbose } = await parseOptions(context, {})
  const yes = context.yes

  const additionalTools: BaseWorkflowInput['additionalTools'] = {}
  if (config.tools?.search) {
    additionalTools.search = search
  }

  // Initialize MCP manager if MCP servers are configured
  const mcpManager = new McpManager(logger)

  // Determine interactive mode: respect explicit values in input, then options, then default based on yes flag
  // Safely access interactive property with optional chaining in case workflowInput doesn't extend BaseWorkflowInput
  const resolvedInteractive = (workflowInput as BaseWorkflowInput | undefined)?.interactive ?? interactive ?? yes !== true

  const finalWorkflowInput: TInput & BaseWorkflowInput = {
    ...workflowInput,
    interactive: resolvedInteractive,
    additionalTools,
  }

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), {
    maxMessages: config.maxMessageCount,
    maxCost: config.budget,
  })

  options.onUsageMeterCreated?.(usage)

  // Explicitly type onEvent as TaskEventCallback to avoid type inference issues
  const onEvent: TaskEventCallback = printEvent(verbose, usage, process.stderr)

  // Get command config once and reuse
  let commandConfig = providerConfig.getConfigForCommand(commandName)

  // Apply provider/model overrides if provided
  if (providerOverride) {
    const { provider: overrideProvider, model: overrideModel, parameters: overrideParameters } = providerOverride

    if (commandConfig) {
      // Create a merged config with overrides
      // Validate provider is a valid AiProvider enum value
      const validProvider =
        overrideProvider && Object.values(AiProvider).includes(overrideProvider as AiProvider)
          ? (overrideProvider as AiProvider)
          : commandConfig.provider

      commandConfig = {
        ...commandConfig,
        provider: validProvider,
        model: overrideModel || commandConfig.model,
        parameters: overrideParameters ? { ...commandConfig.parameters, ...overrideParameters } : commandConfig.parameters,
      }
    } else if (overrideProvider) {
      // No base config, but overrides provided - create config from overrides
      // resolveModelConfig will handle validation
      commandConfig = providerConfig.resolveModelConfig({
        provider: overrideProvider,
        model: overrideModel,
        parameters: overrideParameters,
      })
    }
  }

  // All workflows currently require a provider, so validate config exists
  if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
    const error = new Error(`No provider configured for command: ${commandName}. Please run "polka init" to configure your AI provider.`)
    logger.error(`Error: ${error.message}`)
    throw error
  }

  logger.info('Provider:', commandConfig.provider)
  logger.info('Model:', commandConfig.model)

  const model = getModel(commandConfig)

  const excludeFiles = [...(config.excludeFiles ?? [])]

  // Initialize SQLiteMemoryStore for persistent memory storage
  let memoryStore: { close(): void } | undefined
  try {
    const globalConfigPath = getGlobalConfigPath()
    const globalConfig = (await loadConfigAtPath(globalConfigPath)) as { memory?: { enabled: boolean; type: string; path?: string } } | null
    // Use same default configuration from core for consistency
    const memoryConfig = globalConfig?.memory || DEFAULT_MEMORY_CONFIG

    if (memoryConfig.enabled && memoryConfig.type === 'sqlite') {
      // Determine project scope using shared utility
      const cwd = process.cwd()
      const scope = detectProjectScope(cwd)

      // Resolve db path
      const dbPath = memoryConfig.path || DEFAULT_MEMORY_CONFIG.path
      const resolvedDbPath = resolveHomePath(dbPath)

      // Ensure database directory exists
      const dbDir = dirname(resolvedDbPath)
      await mkdir(dbDir, { recursive: true, mode: 0o700 })

      // Create SQLiteMemoryStore instance
      const sqliteStore = new SQLiteMemoryStore({ enabled: true, type: 'sqlite', path: dbPath }, scope)

      // Wrap with MemoryManager for safety limits and consistent behavior
      const memoryManager = new MemoryManager(sqliteStore)
      memoryStore = memoryManager

      // Update options to pass the memory store to getProvider
      options.getProvider = (opts: ProviderOptions) => getProvider({ ...opts, memoryStore: sqliteStore })
    }
  } catch (error) {
    // If memory store initialization fails, log warning but continue with in-memory store
    logger.warn(`Failed to initialize persistent memory store: ${error instanceof Error ? error.message : String(error)}`)
  }

  const toolProvider = (options.getProvider ?? getProvider)({
    excludeFiles,
    yes: context.yes,
    getModel: (tool) => {
      const toolConfig = config.tools?.[tool as keyof typeof config.tools]
      if (toolConfig === false) {
        return undefined
      }
      // Inherit from the main command config
      const baseConfig = commandConfig

      if (typeof toolConfig === 'object') {
        // Merge to allow partial overrides (e.g. just model)
        const mergedConfig = { ...baseConfig, ...toolConfig }
        const resolvedConfig = providerConfig.resolveModelConfig(mergedConfig)
        if (resolvedConfig) {
          return getModel(resolvedConfig)
        }
      }

      // Fallback for true or undefined
      return getModel(baseConfig)
    },
  })

  const providerOptions = getProviderOptions({
    provider: commandConfig.provider,
    modelId: commandConfig.model,
    parameters: commandConfig.parameters,
  })

  // Initialize skill context for Agent Skills support
  const skillContext = await initializeSkillContext()

  const parameters: AgentContextParameters = {
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
    skillContext,
    mcpManager,
  }

  let workflowContext: WorkflowContext<TTools>

  // Create a tools proxy with dynamic dispatch.
  // Note: We cast to WorkflowTools<TTools> even though the actual return type is Promise<ToolResponse>.
  // This is safe because ToolResponse is a union of all TTools[K]['output'] types, so at runtime
  // the returned value is always compatible with the expected type for the called tool.
  const tools = new Proxy({} as WorkflowTools<TTools>, {
    get: (_target, prop) => {
      // Return undefined for non-string properties (symbols, etc.)
      // and standard properties like 'then', 'toJSON' to avoid interfering
      // with JavaScript operations like Promise.then or JSON.stringify
      if (typeof prop !== 'string' || prop === 'then' || prop === 'toJSON') {
        return undefined
      }
      // Return undefined for unknown tools to support existence checks
      // Only return a function for known tools (including local tools and MCP tools)
      if (!toolHandlers.has(prop) && !localToolNames.includes(prop)) {
        return undefined
      }
      return (async (input: unknown) => {
        logger.debug(`Running tool: ${prop}`)
        return await toolCall({ tool: prop as never, input: input as never }, {
          parameters,
          model,
          agentCallback: onEvent,
          toolProvider,
          yes: context.yes,
          workflowContext: workflowContext,
        } as ToolCallContext)
      }) as WorkflowTools<TTools>[keyof TTools]
    },
  })

  workflowContext = {
    step: makeStepFn(),
    logger,
    tools,
  }

  try {
    // Connect to MCP servers inside the try block to ensure cleanup
    if (config.mcpServers && Object.keys(config.mcpServers).length > 0) {
      await mcpManager.connectToServers(config.mcpServers)
      const mcpTools = mcpManager.getFullToolInfos()
      if (mcpTools.length > 0) {
        additionalTools.mcpTools = mcpTools
        logger.info(`Loaded ${mcpTools.length} MCP tools`)
      }
    }

    logger.info('Running workflow...')
    const output = await workflow(finalWorkflowInput, workflowContext)
    logger.info('\n\nWorkflow completed successfully.')
    logger.info(usage.getUsageText())
    return output
  } catch (e) {
    const error = e as unknown

    // Handle different error types with appropriate messaging
    if (error instanceof UserCancelledError) {
      logger.warn('Workflow cancelled by user.')
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Exit',
          message: error.message,
          messages: [],
        },
      })
    } else if (error instanceof QuotaExceededError) {
      logger.error(`\n❌ Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof AuthenticationError) {
      logger.error(`\n❌ Authentication Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof ModelAccessError) {
      logger.error(`\n❌ Model Access Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof ProviderError) {
      // Handle all other provider errors
      logger.error(`\n❌ Provider Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof McpError) {
      // Handle all MCP errors
      logger.error(`\n❌ MCP Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else {
      // Generic error handling
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      const errorStack = error instanceof Error ? error.stack : undefined
      logger.error(`\n❌ Error: ${errorMessage}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: errorMessage, stack: errorStack },
          messages: [],
        },
      })
    }

    logger.info(usage.getUsageText())
    return undefined
  } finally {
    // Close memory store
    if (memoryStore) {
      try {
        await memoryStore.close()
      } catch (error) {
        logger.warn(`Failed to close memory store: ${error instanceof Error ? error.message : String(error)}`)
      }
    }
    // Disconnect MCP servers
    await mcpManager.disconnectAll()
    logGlobalToolCallStats(process.stderr)
  }
}
