// generated by polka.codes

import { spawnSync } from 'node:child_process'
import fs, { mkdir } from 'node:fs/promises'
import os from 'node:os'
import { dirname } from 'node:path'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { confirm as inquirerConfirm, input as inquirerInput, select as inquirerSelect } from '@inquirer/prompts'
import { getProvider, printEvent } from '@polka-codes/cli-shared'
import {
  type AgentBase,
  type AgentNameType,
  type AgentPolicy,
  AnalyzerAgent,
  ArchitectAgent,
  CodeFixerAgent,
  CoderAgent,
  EnableCachePolicy,
  parseJsonFromMarkdown,
  type SharedAgentOptions,
  type ToolFormat,
  type ToolResponse,
  ToolResponseType,
  UsageMeter,
} from '@polka-codes/core'
import { type PlainJson, run, type ToolCall, type ToolSignature, type Workflow } from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash'
import ora, { type Ora } from 'ora'
import z from 'zod'
import type { ApiProviderConfig } from './ApiProviderConfig'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { parseOptions } from './options'
import prices from './prices'
import type { WorkflowTools } from './workflow-tools'
import { getLocalChanges } from './workflows/workflow.utils'

type AgentContextParameters = {
  toolFormat?: ToolFormat
  os?: string
  policies?: AgentPolicy[]
  modelParameters?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter?: UsageMeter
}

const agentRegistry: Record<string, new (options: SharedAgentOptions) => AgentBase> = {
  analyzer: AnalyzerAgent,
  architect: ArchitectAgent,
  coder: CoderAgent,
  codefixer: CodeFixerAgent,
}

class WorkflowAgent extends CoderAgent {
  protected onBeforeInvokeTool(_name: string, _args: Record<string, string>): Promise<ToolResponse | undefined> {
    return Promise.resolve(undefined)
  }
}

async function handleToolCall(
  toolCall: ToolCall<WorkflowTools>,
  context: {
    providerConfig: ApiProviderConfig
    parameters: AgentContextParameters
    getModel: (name: AgentNameType) => Promise<LanguageModelV2>
    agentCallback?: (event: any) => void
    toolProvider: any // ToolProvider
    spinner: Ora
  },
) {
  switch (toolCall.tool) {
    case 'invokeAgent': {
      context.spinner.stop()
      const input = toolCall.input
      const model = await context.getModel(input.agent)

      const AgentClass = agentRegistry[input.agent] ?? WorkflowAgent

      const agent = new AgentClass({
        ai: model,
        os: context.parameters.os ?? 'linux',
        provider: context.toolProvider,
        toolFormat: context.parameters.toolFormat ?? 'native',
        policies: context.parameters.policies ?? [],
        usageMeter: context.parameters.usageMeter,
        parameters: context.parameters.modelParameters,
        scripts: context.parameters.scripts,
        callback: context.agentCallback,
        requireToolUse: false,
        retryCount: context.parameters.retryCount,
        requestTimeoutSeconds: context.parameters.requestTimeoutSeconds,
        additionalTools: input.tools,
      })

      const userPrompt = input.messages
        .filter((m) => typeof m === 'string' || m.type !== 'system')
        .map((m) => (typeof m === 'string' ? m : m.content))
        .join('\n\n')

      let exitReason = await agent.start(userPrompt)

      context.spinner.start()

      for (let i = 0; i < 5; i++) {
        if (exitReason.type !== ToolResponseType.Exit) {
          throw new Error(`Agent exited for an unhandled reason: ${JSON.stringify(exitReason)}`)
        }

        const parsed = parseJsonFromMarkdown(exitReason.message)
        if (!parsed.success) {
          const errorMessage = `Failed to parse JSON from markdown. Error: ${parsed.error}. Please correct the output.`
          if (i < 4) {
            context.spinner.stop()
            exitReason = await agent.continueTask(errorMessage)
            context.spinner.start()
            continue
          } else {
            throw new Error(errorMessage)
          }
        }

        if (input.outputSchema) {
          const validated = input.outputSchema.safeParse(parsed.data)
          if (!validated.success) {
            const errorMessage = `Output validation failed. Error: ${z.prettifyError(validated.error)}. Please correct the output.`
            if (i < 4) {
              context.spinner.stop()
              exitReason = await agent.continueTask(errorMessage)
              context.spinner.start()
              continue
            } else {
              throw new Error(z.prettifyError(validated.error))
            }
          }
          return validated.data
        }
        return parsed.data
      }

      throw new Error('Agent failed to produce valid output after 5 retries.')
    }
    case 'createPullRequest': {
      const { title, description } = toolCall.input as { title: string; description: string }
      context.spinner.stop()
      spawnSync('gh', ['pr', 'create', '--title', title, '--body', description], { stdio: 'inherit' })
      context.spinner.start()
      return { title, description }
    }
    case 'createCommit': {
      const { message } = toolCall.input
      context.spinner.stop()

      const result = spawnSync('git', ['commit', '-m', message], { stdio: 'inherit' })
      if (result.status !== 0) {
        throw new Error('Commit failed')
      }
      context.spinner.start()
      return { message }
    }
    case 'printChangeFile': {
      context.spinner.stop()

      const { stagedFiles, unstagedFiles } = getLocalChanges()
      if (stagedFiles.length === 0 && unstagedFiles.length === 0) {
        console.log('No changes to commit.')
      } else {
        if (stagedFiles.length > 0) {
          console.log('Staged files:')
          for (const file of stagedFiles) {
            console.log(`- ${file.status}: ${file.path}`)
          }
        }
        if (unstagedFiles.length > 0) {
          console.log('\nUnstaged files:')
          for (const file of unstagedFiles) {
            console.log(`- ${file.status}: ${file.path}`)
          }
        }
      }
      context.spinner.start()
      return { stagedFiles, unstagedFiles }
    }
    case 'confirm': {
      const { message } = toolCall.input
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerConfirm({ message })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'input': {
      const { message, default: defaultValue } = toolCall.input
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerInput({ message, default: defaultValue })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'select': {
      const { message, choices } = toolCall.input as { message: string; choices: { name: string; value: string }[] }
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerSelect({ message, choices })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'writeToFile': {
      const { path, content } = toolCall.input
      // generate parent directories if they don't exist
      await mkdir(dirname(path), { recursive: true })
      await fs.writeFile(path, content)
      return {}
    }
    default:
      throw new Error(`Unknown tool: ${String((toolCall as any).tool)}`)
  }
}

export async function runWorkflow<
  TInput extends PlainJson,
  TOutput extends PlainJson,
  TTools extends Record<string, ToolSignature<any, any>>,
>(
  commandName: string,
  workflow: Workflow<TInput, TOutput, TTools>,
  command: Command,
  workflowInput: TInput,
  requiresProvider: boolean = true,
): Promise<TOutput | undefined> {
  const { json } = command.opts()
  const logger = json ? new console.Console(process.stderr) : console
  const { providerConfig, config, verbose } = parseOptions(command.parent?.opts() ?? {})

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
      process.exit(1)
    }

    logger.log('Provider:', commandConfig.provider)
    logger.log('Model:', commandConfig.model)
  }

  const spinner = ora({ text: 'Running workflow...', ...(json && { stream: process.stderr }) }).start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), { maxMessages: config.maxMessageCount, maxCost: config.budget })
  const onEvent = verbose > 0 ? printEvent(verbose, usage, process.stderr) : undefined
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const agentConfig = providerConfig.getConfigForCommand(commandName)

  const parameters: AgentContextParameters = {
    toolFormat: config.toolFormat,
    os: os.platform(),
    policies: [EnableCachePolicy],
    modelParameters: agentConfig?.parameters,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  const originalConsole = { log: console.log, error: console.error, warn: console.warn }
  if (json) {
    console.log = logger.log
    console.error = logger.error
    console.warn = logger.warn
  }

  let result = await run(workflow, workflowInput, async (name, fn) => {
    spinner.text = name
    return await fn()
  })

  while (result.status === 'pending') {
    spinner.text = `Running tool: ${String(result.tool.tool)}`
    try {
      const toolResult = await handleToolCall(result.tool as ToolCall<WorkflowTools>, {
        providerConfig,
        parameters,
        spinner,
        getModel: async (agent: AgentNameType) => {
          const config = providerConfig.getConfigForAgent(agent) || providerConfig.getConfigForCommand(commandName)
          if (!config) {
            throw new Error(`Could not get model config for agent ${agent} or command ${commandName}`)
          }
          return getModel(config)
        },
        agentCallback: onEvent,
        toolProvider,
      })
      result = await result.next(toolResult)
    } catch (e) {
      result = { status: 'failed', error: e }
    }
  }

  if (json) {
    console.log = originalConsole.log
    console.error = originalConsole.error
    console.warn = originalConsole.warn
  }

  if (result.status === 'completed') {
    spinner.succeed('Workflow completed successfully.')
    usage.printUsage(logger)
    return result.output
  }

  if (result.status === 'failed') {
    const error = result.error as any
    if (error instanceof UserCancelledError) {
      spinner.warn('Workflow cancelled by user.')
    } else {
      spinner.fail(`Workflow failed: ${error.message}`)
      logger.error(error)
    }
  }

  spinner.stop()
  usage.printUsage(logger)
  return undefined
}
