// generated by polka.codes

import os from 'node:os'
import { getProvider, printEvent } from '@polka-codes/cli-shared'
import type { AgentNameType } from '@polka-codes/core'
import { EnableCachePolicy, UsageMeter } from '@polka-codes/core'
import { makeStepFn, run, type ToolCall, type ToolSignature, type Workflow } from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash'
import ora from 'ora'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, handleToolCall } from './tool-implementations'
import type { CliToolRegistry } from './workflow-tools'

export async function runWorkflow<TInput, TOutput, TTools extends Record<string, ToolSignature<any, any>>>(
  commandName: string,
  workflow: Workflow<TInput, TOutput, TTools>,
  command: Command,
  workflowInput: TInput,
  requiresProvider: boolean = true,
): Promise<TOutput | undefined> {
  const globalOpts = (command.parent ?? command).opts()
  const { json } = globalOpts
  const logger = json ? new console.Console(process.stderr) : console
  const { providerConfig, config, verbose } = parseOptions(globalOpts, { commandName })

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
      process.exit(1)
    }

    logger.log('Provider:', commandConfig.provider)
    logger.log('Model:', commandConfig.model)
  }

  const spinner = ora({ text: 'Running workflow...', ...(json && { stream: process.stderr }) }).start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), { maxMessages: config.maxMessageCount, maxCost: config.budget })
  const onEvent = printEvent(verbose, usage, process.stderr)
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const agentConfig = providerConfig.getConfigForCommand(commandName)
  const model = agentConfig ? getModel(agentConfig) : undefined

  const providerOptions = agentConfig
    ? getProviderOptions({
        provider: agentConfig.provider,
        modelId: agentConfig.model,
        parameters: agentConfig.parameters,
      })
    : {}

  const parameters: AgentContextParameters = {
    toolFormat: config.toolFormat,
    os: os.platform(),
    policies: [EnableCachePolicy],
    modelParameters: agentConfig?.parameters,
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  const originalConsole = { log: console.log, error: console.error, warn: console.warn }
  if (json) {
    console.log = logger.log
    console.error = logger.error
    console.warn = logger.warn
  }

  let result = await run(
    workflow,
    workflowInput,
    makeStepFn<TTools>({
      onEnterStep: (name) => {
        spinner.text = name
      },
    }),
  )

  while (result.status === 'pending') {
    spinner.text = `Running tool: ${String(result.tool.tool)}`
    let toolResult: any
    try {
      toolResult = await handleToolCall(result.tool as ToolCall<CliToolRegistry>, {
        providerConfig,
        parameters,
        spinner,
        getModel: async (agent: AgentNameType) => {
          const config = providerConfig.getConfigForAgent(agent) || providerConfig.getConfigForCommand(commandName)
          if (!config) {
            throw new Error(`Could not get model config for agent ${agent} or command ${commandName}`)
          }
          return getModel(config)
        },
        model,
        agentCallback: onEvent,
        toolProvider,
        command,
      })
    } catch (e) {
      result = await result.throw(e as Error)
      continue
    }
    result = await result.next(toolResult)
  }

  if (json) {
    console.log = originalConsole.log
    console.error = originalConsole.error
    console.warn = originalConsole.warn
  }

  if (result.status === 'completed') {
    spinner.succeed('Workflow completed successfully.')
    usage.printUsage(logger)
    return result.output
  }

  if (result.status === 'failed') {
    const error = result.error as any
    if (error instanceof UserCancelledError) {
      spinner.warn('Workflow cancelled by user.')
    } else {
      spinner.fail(`Workflow failed: ${error.message}`)
      logger.error(error)
    }
  }

  spinner.stop()
  usage.printUsage(logger)
  return undefined
}
