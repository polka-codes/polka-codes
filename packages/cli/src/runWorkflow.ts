// generated by polka.codes

import { getProvider, logGlobalToolCallStats, type ProviderOptions, printEvent } from '@polka-codes/cli-shared'
import {
  type Logger,
  makeStepFn,
  search,
  type TaskEventCallback,
  TaskEventKind,
  type ToolProvider,
  type ToolRegistry,
  UsageMeter,
  type WorkflowContext,
  type WorkflowFn,
  type WorkflowTools,
} from '@polka-codes/core'
import { merge } from 'lodash-es'
import { AuthenticationError, ModelAccessError, ProviderError, QuotaExceededError, UserCancelledError } from './errors'
import { getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { McpError } from './mcp/errors'
import { McpManager } from './mcp/manager'
import { type CliOptions, parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, initializeSkillContext, type ToolCallContext, toolCall } from './tool-implementations'
import type { BaseWorkflowInput } from './workflows'

/**
 * Execution context for running workflows.
 * This replaces the Commander.js Command object, making the code
 * usable both from CLI and as a scripting API.
 */
export interface ExecutionContext extends CliOptions {
  // All CLI options are inherited from CliOptions
}

type RunWorkflowOptions = {
  commandName: string
  context: ExecutionContext
  logger: Logger
  requiresProvider?: boolean
  interactive?: boolean
  getProvider?: (args: ProviderOptions) => ToolProvider
  onUsageMeterCreated?: (meter: UsageMeter) => void
}

export async function runWorkflow<TInput, TOutput, TTools extends ToolRegistry>(
  workflow: WorkflowFn<TInput & BaseWorkflowInput, TOutput, TTools>,
  workflowInput: TInput,
  options: RunWorkflowOptions,
): Promise<TOutput | undefined> {
  const { commandName, context, logger, requiresProvider = true, interactive } = options
  const { providerConfig, config, verbose } = await parseOptions(context, {})
  const yes = context.yes

  const additionalTools: BaseWorkflowInput['additionalTools'] = {}
  if (config.tools?.search) {
    additionalTools.search = search
  }

  // Initialize MCP manager if MCP servers are configured
  const mcpManager = new McpManager(logger)

  // Determine interactive mode: respect explicit values in input, then options, then default based on yes flag
  // Safely access interactive property with optional chaining in case workflowInput doesn't extend BaseWorkflowInput
  const resolvedInteractive = (workflowInput as BaseWorkflowInput | undefined)?.interactive ?? interactive ?? yes !== true

  const finalWorkflowInput: TInput & BaseWorkflowInput = {
    ...workflowInput,
    interactive: resolvedInteractive,
    additionalTools,
  }

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), {
    maxMessages: config.maxMessageCount,
    maxCost: config.budget,
  })

  options.onUsageMeterCreated?.(usage)

  // Explicitly type onEvent as TaskEventCallback to avoid type inference issues
  const onEvent: TaskEventCallback = printEvent(verbose, usage, process.stderr)

  // Get command config once and reuse
  const commandConfig = providerConfig.getConfigForCommand(commandName)

  // All workflows currently require a provider, so validate config exists
  if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
    const error = new Error(`No provider configured for command: ${commandName}. Please run "polka init" to configure your AI provider.`)
    logger.error(`Error: ${error.message}`)
    throw error
  }

  logger.info('Provider:', commandConfig.provider)
  logger.info('Model:', commandConfig.model)

  const model = getModel(commandConfig)

  const excludeFiles = [...(config.excludeFiles ?? [])]

  const toolProvider = (options.getProvider ?? getProvider)({
    excludeFiles,
    yes: context.yes,
    getModel: (tool) => {
      const toolConfig = config.tools?.[tool as keyof typeof config.tools]
      if (toolConfig === false) {
        return undefined
      }
      // Inherit from the main command config
      const baseConfig = commandConfig

      if (typeof toolConfig === 'object') {
        // Merge to allow partial overrides (e.g. just model)
        const mergedConfig = { ...baseConfig, ...toolConfig }
        const resolvedConfig = providerConfig.resolveModelConfig(mergedConfig)
        if (resolvedConfig) {
          return getModel(resolvedConfig)
        }
      }

      // Fallback for true or undefined
      return getModel(baseConfig)
    },
  })

  const providerOptions = getProviderOptions({
    provider: commandConfig.provider,
    modelId: commandConfig.model,
    parameters: commandConfig.parameters,
  })

  // Initialize skill context for Agent Skills support
  const skillContext = await initializeSkillContext()

  const parameters: AgentContextParameters = {
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
    skillContext,
    mcpManager,
  }

  let workflowContext: WorkflowContext<TTools>

  // Create a tools proxy with dynamic dispatch.
  // Note: We cast to WorkflowTools<TTools> even though the actual return type is Promise<ToolResponse>.
  // This is safe because ToolResponse is a union of all TTools[K]['output'] types, so at runtime
  // the returned value is always compatible with the expected type for the called tool.
  const tools = new Proxy({} as WorkflowTools<TTools>, {
    get: (_target, tool: string) => {
      return (async (input: unknown) => {
        logger.debug(`Running tool: ${tool}`)
        return await toolCall({ tool: tool as never, input: input as never }, {
          parameters,
          model,
          agentCallback: onEvent,
          toolProvider,
          yes: context.yes,
          workflowContext: workflowContext,
        } as ToolCallContext)
      }) as WorkflowTools<TTools>[keyof TTools]
    },
  })

  workflowContext = {
    step: makeStepFn(),
    logger,
    tools,
  }

  try {
    // Connect to MCP servers inside the try block to ensure cleanup
    if (config.mcpServers && Object.keys(config.mcpServers).length > 0) {
      await mcpManager.connectToServers(config.mcpServers)
      const mcpTools = mcpManager.getFullToolInfos()
      if (mcpTools.length > 0) {
        additionalTools.mcpTools = mcpTools
        logger.info(`Loaded ${mcpTools.length} MCP tools`)
      }
    }

    logger.info('Running workflow...')
    const output = await workflow(finalWorkflowInput, workflowContext)
    logger.info('\n\nWorkflow completed successfully.')
    logger.info(usage.getUsageText())
    return output
  } catch (e) {
    const error = e as unknown

    // Handle different error types with appropriate messaging
    if (error instanceof UserCancelledError) {
      logger.warn('Workflow cancelled by user.')
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Exit',
          message: error.message,
          messages: [],
        },
      })
    } else if (error instanceof QuotaExceededError) {
      logger.error(`\n❌ Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof AuthenticationError) {
      logger.error(`\n❌ Authentication Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof ModelAccessError) {
      logger.error(`\n❌ Model Access Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof ProviderError) {
      // Handle all other provider errors
      logger.error(`\n❌ Provider Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else if (error instanceof McpError) {
      // Handle all MCP errors
      logger.error(`\n❌ MCP Error: ${error.message}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: error.message, stack: error.stack },
          messages: [],
        },
      })
    } else {
      // Generic error handling
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      const errorStack = error instanceof Error ? error.stack : undefined
      logger.error(`\n❌ Error: ${errorMessage}`)
      onEvent({
        kind: TaskEventKind.EndTask,
        exitReason: {
          type: 'Error',
          error: { message: errorMessage, stack: errorStack },
          messages: [],
        },
      })
    }

    logger.info(usage.getUsageText())
    return undefined
  } finally {
    // Disconnect MCP servers
    await mcpManager.disconnectAll()
    logGlobalToolCallStats(process.stderr)
  }
}
