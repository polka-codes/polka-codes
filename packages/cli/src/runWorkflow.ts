// generated by polka.codes

import os from 'node:os'
import { getProvider, printEvent } from '@polka-codes/cli-shared'
import type { AgentNameType } from '@polka-codes/core'
import { EnableCachePolicy, UsageMeter } from '@polka-codes/core'
import { type PlainJson, run, type ToolCall, type ToolSignature, type Workflow } from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash'
import ora from 'ora'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, handleToolCall } from './tool-implementations'
import type { CliToolRegistry } from './workflow-tools'

export async function runWorkflow<
  TInput extends PlainJson,
  TOutput extends PlainJson,
  TTools extends Record<string, ToolSignature<any, any>>,
>(
  commandName: string,
  workflow: Workflow<TInput, TOutput, TTools>,
  command: Command,
  workflowInput: TInput,
  requiresProvider: boolean = true,
): Promise<TOutput | undefined> {
  const globalOpts = (command.parent ?? command).opts()
  const { json } = globalOpts
  const logger = json ? new console.Console(process.stderr) : console
  const { providerConfig, config, verbose } = parseOptions(globalOpts, { commandName })

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
      process.exit(1)
    }

    logger.log('Provider:', commandConfig.provider)
    logger.log('Model:', commandConfig.model)
  }

  const spinner = ora({ text: 'Running workflow...', ...(json && { stream: process.stderr }) }).start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), { maxMessages: config.maxMessageCount, maxCost: config.budget })
  const onEvent = printEvent(verbose, usage, process.stderr)
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const agentConfig = providerConfig.getConfigForCommand(commandName)

  const parameters: AgentContextParameters = {
    toolFormat: config.toolFormat,
    os: os.platform(),
    policies: [EnableCachePolicy],
    modelParameters: agentConfig?.parameters,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  const originalConsole = { log: console.log, error: console.error, warn: console.warn }
  if (json) {
    console.log = logger.log
    console.error = logger.error
    console.warn = logger.warn
  }

  let result = await run(workflow, workflowInput, async function* (name: string, fn: any) {
    spinner.text = name
    const resultOrGenerator = fn()
    if (resultOrGenerator && typeof (resultOrGenerator as any).next === 'function') {
      return yield* resultOrGenerator as any
    }
    return await resultOrGenerator
  } as any)

  while (result.status === 'pending') {
    spinner.text = `Running tool: ${String(result.tool.tool)}`
    try {
      const toolResult = await handleToolCall(result.tool as ToolCall<CliToolRegistry>, {
        providerConfig,
        parameters,
        spinner,
        getModel: async (agent: AgentNameType) => {
          const config = providerConfig.getConfigForAgent(agent) || providerConfig.getConfigForCommand(commandName)
          if (!config) {
            throw new Error(`Could not get model config for agent ${agent} or command ${commandName}`)
          }
          return getModel(config)
        },
        agentCallback: onEvent,
        toolProvider,
        command,
      })
      result = await result.next(toolResult)
    } catch (e) {
      result = { status: 'failed', error: e }
    }
  }

  if (json) {
    console.log = originalConsole.log
    console.error = originalConsole.error
    console.warn = originalConsole.warn
  }

  if (result.status === 'completed') {
    spinner.succeed('Workflow completed successfully.')
    usage.printUsage(logger)
    return result.output
  }

  if (result.status === 'failed') {
    const error = result.error as any
    if (error instanceof UserCancelledError) {
      spinner.warn('Workflow cancelled by user.')
    } else {
      spinner.fail(`Workflow failed: ${error.message}`)
      logger.error(error)
    }
  }

  spinner.stop()
  usage.printUsage(logger)
  return undefined
}
