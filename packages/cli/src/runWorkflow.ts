// generated by polka.codes

import { getProvider, logGlobalToolCallStats, printEvent } from '@polka-codes/cli-shared'
import {
  type Logger,
  makeStepFn,
  search,
  TaskEventKind,
  type ToolProvider,
  type ToolRegistry,
  UsageMeter,
  type WorkflowContext,
  type WorkflowFn,
  type WorkflowTools,
} from '@polka-codes/core'
import type { Command } from 'commander'
import { merge } from 'lodash-es'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, toolCall } from './tool-implementations'
import type { BaseWorkflowInput } from './workflows'

type RunWorkflowOptions = {
  commandName: string
  command: Command
  logger: Logger
  requiresProvider?: boolean
  yes?: boolean
  interactive?: boolean
  getProvider?: (args: { excludeFiles?: string[] }) => ToolProvider
  onUsageMeterCreated?: (meter: UsageMeter) => void
}

export async function runWorkflow<TInput, TOutput, TTools extends ToolRegistry>(
  workflow: WorkflowFn<TInput & BaseWorkflowInput, TOutput, TTools>,
  workflowInput: TInput,
  options: RunWorkflowOptions,
): Promise<TOutput | undefined> {
  const { commandName, command, logger, requiresProvider = true, yes, interactive } = options
  const globalOpts = (command.parent ?? command).opts()
  const { providerConfig, config, verbose } = await parseOptions(globalOpts, {})

  const additionalTools: BaseWorkflowInput['additionalTools'] = {}
  if (config.tools?.search) {
    additionalTools.search = search
  }

  const finalWorkflowInput: TInput & BaseWorkflowInput = {
    ...workflowInput,
    interactive: interactive ?? !yes,
    additionalTools,
  }

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka init" to configure your AI provider.`)
      process.exit(1)
    }
    logger.info('Provider:', commandConfig.provider)
    logger.info('Model:', commandConfig.model)
  }

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), {
    maxMessages: config.maxMessageCount,
    maxCost: config.budget,
  })

  options.onUsageMeterCreated?.(usage)

  const onEvent = printEvent(verbose, usage, process.stderr)

  const commandConfig = providerConfig.getConfigForCommand(commandName)
  if (!commandConfig) {
    throw new Error(`No provider configured for command: ${commandName}`)
  }
  const model = getModel(commandConfig)

  const excludeFiles = ['.epic.yml', ...(config.excludeFiles ?? [])]

  const toolProvider = (options.getProvider ?? getProvider)({
    excludeFiles,
    getModel: (tool) => {
      const toolConfig = config.tools?.[tool as keyof typeof config.tools]
      if (toolConfig === false) {
        return undefined
      }
      // Inherit from the main command config
      const baseConfig = commandConfig

      if (typeof toolConfig === 'object') {
        // Merge to allow partial overrides (e.g. just model)
        const mergedConfig = { ...baseConfig, ...toolConfig }
        const resolvedConfig = providerConfig.resolveModelConfig(mergedConfig)
        if (resolvedConfig) {
          return getModel(resolvedConfig)
        }
      }

      // Fallback for true or undefined
      return getModel(baseConfig)
    },
  })

  const providerOptions = getProviderOptions({
    provider: commandConfig.provider,
    modelId: commandConfig.model,
    parameters: commandConfig.parameters,
  })

  const parameters: AgentContextParameters = {
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  const tools = new Proxy({} as WorkflowTools<TTools>, {
    get: (_target, tool: string) => {
      return async (input: any) => {
        logger.debug(`Running tool: ${tool}`)
        return await toolCall(
          { tool: tool as any, input },
          {
            parameters,
            model,
            agentCallback: onEvent,
            toolProvider,
            command,
            yes,
          },
        )
      }
    },
  })

  const context: WorkflowContext<TTools> = {
    step: makeStepFn(),
    logger,
    tools,
  }

  try {
    logger.info('Running workflow...')
    const output = await workflow(finalWorkflowInput, context)
    logger.info('\n\nWorkflow completed successfully.')
    logger.info(usage.getUsageText())
    return output
  } catch (e) {
    const error = e as any
    onEvent({
      kind: TaskEventKind.EndTask,
      exitReason: {
        type: 'Error',
        error: { message: error.message, stack: error.stack },
        messages: [],
      },
    })
    if (error instanceof UserCancelledError) {
      logger.warn('Workflow cancelled by user.')
    }
    logger.info(usage.getUsageText())
    return undefined
  } finally {
    logGlobalToolCallStats(process.stderr)
  }
}
