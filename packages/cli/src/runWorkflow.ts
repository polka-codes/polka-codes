// generated by polka.codes

import { Console } from 'node:console'
import os from 'node:os'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { getProvider, type ProviderOptions, printEvent } from '@polka-codes/cli-shared'
import {
  type AgentContextParameters,
  type AgentStepSpec,
  combineHandlers,
  customStepSpecHandler,
  EnableCachePolicy,
  type Json,
  makeAgentStepSpecHandler,
  run,
  type StepRunResult,
  sequentialStepSpecHandler,
  UsageMeter,
  type WorkflowContext,
  type WorkflowSpec,
} from '@polka-codes/core'
import type { Command } from 'commander'
import { merge } from 'lodash'
import ora, { type Ora } from 'ora'
import { getModel } from './getModel'
import { parseOptions } from './options'
import prices from './prices'

export interface CommandWorkflowContext extends WorkflowContext {
  ui: { spinner: Ora }
  parameters: AgentContextParameters
}

type HandleSuccess<T extends Record<string, Json>> = (result: StepRunResult<T>, command?: Command) => Promise<void>

export async function runWorkflowCommand<TWorkflowInput extends Record<string, Json>, TWorkflowOutput extends Record<string, Json>>(
  commandName: 'review' | 'commit' | 'pr',
  workflow: WorkflowSpec<TWorkflowInput, TWorkflowOutput>,
  command: Command,
  workflowInput: TWorkflowInput,
  handleSuccess: HandleSuccess<TWorkflowOutput>,
  options: { json?: boolean } = {},
) {
  const parentOptions = command.parent?.opts() ?? {}
  const { providerConfig, config, verbose } = parseOptions(parentOptions)
  const commandConfig = providerConfig.getConfigForCommand(commandName)

  if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
    console.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
    process.exit(1)
  }

  const { json = false } = options
  if (!json) {
    console.log('Provider:', commandConfig.provider)
    console.log('Model:', commandConfig.model)
  }

  const agentStepHandler = makeAgentStepSpecHandler(async (_step: AgentStepSpec, _context: WorkflowContext): Promise<LanguageModelV2> => {
    return getModel(commandConfig)
  })

  const coreStepHandler = combineHandlers(customStepSpecHandler, sequentialStepSpecHandler, agentStepHandler)

  const spinner = ora({
    text: 'Gathering information...',
    stream: process.stderr,
  }).start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), { maxMessages: config.maxMessageCount, maxCost: config.budget })
  const customConsole = json ? new Console(process.stderr, process.stderr) : console
  const onEvent = verbose > 0 ? printEvent(verbose, usage, customConsole) : undefined
  const toolProviderOptions: ProviderOptions = {
    excludeFiles: config.excludeFiles,
  }
  const toolProvider = getProvider(toolProviderOptions)

  const agentConfig = providerConfig.getConfigForCommand(commandName)

  const context: CommandWorkflowContext = {
    ui: { spinner },
    provider: toolProvider,
    parameters: {
      toolFormat: config.toolFormat,
      os: os.platform(),
      policies: [EnableCachePolicy],
      modelParameters: agentConfig?.parameters,
      scripts: config.scripts,
      retryCount: config.retryCount,
      requestTimeoutSeconds: config.requestTimeoutSeconds,
      usageMeter: usage,
    },
    verbose,
    agentCallback: onEvent,
    logger: customConsole,
  }

  try {
    const result = await run(workflow, context, coreStepHandler, workflowInput)

    if (result.type === 'success') {
      await handleSuccess(result, command)
    } else if (result.type === 'error') {
      if (result.error?.message === 'User cancelled') {
        spinner.stop()
        process.exit(130)
      }
      const errorMessage = result.error?.message ?? 'An unknown error occurred'
      spinner.fail(`Error during ${commandName}: ${errorMessage}`)
      if (result.error) {
        console.error(result.error)
      }
      process.exit(1)
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    spinner.fail(`Error during ${commandName}: ${errorMessage}`)
    console.error(error)
    process.exit(1)
  } finally {
    if (!json) {
      usage.printUsage()
    }
  }
}
