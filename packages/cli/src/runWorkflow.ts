// generated by polka.codes

import os from 'node:os'
import { getProvider, printEvent } from '@polka-codes/cli-shared'
import type { AgentNameType } from '@polka-codes/core'
import { EnableCachePolicy, UsageMeter } from '@polka-codes/core'
import { type Logger, makeStepFn, run, type ToolCall, type ToolSignature, type Workflow, type WorkflowResult } from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash-es'
import ora from 'ora'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, handleToolCall } from './tool-implementations'
import type { CliToolRegistry } from './workflow-tools'

export async function runWorkflow<TInput, TOutput, TTools extends Record<string, ToolSignature<any, any>>>(
  commandName: string,
  workflow: Workflow<TInput, TOutput, TTools>,
  command: Command,
  workflowInput: TInput,
  logger: Logger,
  requiresProvider: boolean = true,
): Promise<TOutput | undefined> {
  const globalOpts = (command.parent ?? command).opts()
  const { json } = globalOpts
  const { providerConfig, config, verbose } = parseOptions(globalOpts, {})

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
      process.exit(1)
    }

    logger.info('Provider:', commandConfig.provider)
    logger.info('Model:', commandConfig.model)
  }

  const spinner = ora({
    text: 'Running workflow...',
    ...(json && { stream: process.stderr }),
  }).start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), {
    maxMessages: config.maxMessageCount,
    maxCost: config.budget,
  })
  const onEvent = printEvent(verbose, usage, process.stderr)
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const agentConfig = providerConfig.getConfigForCommand(commandName)
  const model = agentConfig ? getModel(agentConfig) : undefined

  const providerOptions = agentConfig
    ? getProviderOptions({
        provider: agentConfig.provider,
        modelId: agentConfig.model,
        parameters: agentConfig.parameters,
      })
    : {}

  const parameters: AgentContextParameters = {
    toolFormat: config.toolFormat,
    os: os.platform(),
    policies: [EnableCachePolicy],
    modelParameters: agentConfig?.parameters,
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  let result: WorkflowResult<TInput, TOutput, TTools>
  try {
    result = await run(
      workflow,
      workflowInput,
      makeStepFn<TTools>({
        onEnterStep: (name) => {
          spinner.text = name
        },
      }),
      logger,
    )

    while (result.status === 'pending') {
      spinner.text = `Running tool: ${String(result.tool.tool)}`
      let toolResult: any
      try {
        toolResult = await handleToolCall(result.tool as ToolCall<CliToolRegistry>, {
          providerConfig,
          parameters,
          spinner,
          getModel: async (agent: AgentNameType) => {
            const config = providerConfig.getConfigForAgent(agent) || providerConfig.getConfigForCommand(commandName)
            if (!config) {
              throw new Error(`Could not get model config for agent ${agent} or command ${commandName}`)
            }
            return getModel(config)
          },
          model,
          agentCallback: onEvent,
          toolProvider,
          command,
        })
      } catch (e) {
        result = await result.throw(e as Error)
        continue
      }
      result = await result.next(toolResult)
    }
  } catch (e) {
    result = { status: 'failed', error: e }
  }

  if (result.status === 'completed') {
    spinner.succeed('Workflow completed successfully.')
    logger.info(usage.getUsageText())
    return result.output
  }

  if (result.status === 'failed') {
    const error = result.error as any
    if (error instanceof UserCancelledError) {
      spinner.warn('Workflow cancelled by user.')
    } else {
      spinner.fail(`Workflow failed: ${error.message}`)
      logger.error(error)
    }
  }

  spinner.stop()
  logger.info(usage.getUsageText())
  return undefined
}
