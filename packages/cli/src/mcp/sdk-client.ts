// generated by polka.codes

import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'
import { McpConnectionError, McpToolError } from './errors'
import type { IMcpClient, McpResource, McpTool, McpToolResult } from './types'

/**
 * SDK-based MCP Client implementation
 *
 * Wraps the official @modelcontextprotocol/sdk Client to provide
 * the IMcpClient interface used by the rest of polka-codes.
 */
export class SdkMcpClient implements IMcpClient {
  private client: Client | null = null
  private transport: StdioClientTransport | null = null
  private initialized = false

  constructor(
    private readonly serverName: string,
    private readonly config: { command: string; args?: string[]; env?: Record<string, string> },
  ) {}

  /**
   * Connect to the MCP server and initialize
   */
  async connect(): Promise<void> {
    if (!this.config.command) {
      throw new McpConnectionError(this.serverName, new Error('No command specified for MCP server'))
    }

    try {
      // Create transport
      this.transport = new StdioClientTransport({
        command: this.config.command,
        args: this.config.args || [],
        env: this.config.env,
      })

      // Create client
      this.client = new Client(
        {
          name: `polka-codes-${this.serverName}`,
          version: '1.0.0',
        },
        {
          capabilities: {},
        },
      )

      // Connect and initialize (SDK handles initialization automatically)
      await this.client.connect(this.transport)

      this.initialized = true
    } catch (error) {
      throw new McpConnectionError(this.serverName, error instanceof Error ? error : new Error(String(error)))
    }
  }

  /**
   * Check if connected
   */
  isConnected(): boolean {
    return this.initialized && this.client !== null
  }

  /**
   * Disconnect from the server
   */
  async disconnect(): Promise<void> {
    if (this.client) {
      await this.client.close()
      this.client = null
    }
    this.transport = null
    this.initialized = false
  }

  /**
   * List available tools from the server
   */
  async listTools(): Promise<McpTool[]> {
    if (!this.client || !this.isConnected()) {
      throw new McpConnectionError(this.serverName, new Error('Client not connected'))
    }

    try {
      const response = await this.client.listTools({})

      return response.tools.map((tool) => ({
        name: tool.name,
        description: tool.description || '',
        inputSchema: tool.inputSchema as Record<string, unknown>,
      }))
    } catch (error) {
      throw new McpConnectionError(this.serverName, error instanceof Error ? error : new Error(String(error)))
    }
  }

  /**
   * Call a tool on the server
   */
  async callTool(name: string, args: Record<string, unknown>): Promise<McpToolResult> {
    if (!this.client || !this.isConnected()) {
      throw new McpConnectionError(this.serverName, new Error('Client not connected'))
    }

    try {
      const response = await this.client.callTool({
        name,
        arguments: args,
      })

      // Extract and join all text content from response
      // Handle both task-based and regular tool responses
      type ContentItem =
        | { type: 'text'; text: string }
        | { type: 'image'; data: string; mimeType: string }
        | { type: 'audio'; data: string; mimeType: string }
        | { type: 'resource'; resource: unknown }
        | { type: 'resource_link'; uri: string; name: string }

      const content = 'content' in response ? (response.content as ContentItem[]) : []

      const textParts = content.filter((c): c is { type: 'text'; text: string } => c.type === 'text').map((c) => c.text)

      const text = textParts.length > 0 ? textParts.join('\n') : JSON.stringify(response, null, 2)

      return {
        content: [
          {
            type: 'text',
            text,
          },
        ],
        isError: ('isError' in response ? response.isError : undefined) as boolean | undefined,
      }
    } catch (error) {
      // Errors from SDK are connection/protocol errors (tool errors are returned as isError: true)
      if (error instanceof McpToolError) {
        throw error
      }

      // Wrap in connection error with context about which operation failed
      const errorMessage =
        error instanceof Error ? `Failed to call tool '${name}': ${error.message}` : `Failed to call tool '${name}': ${String(error)}`

      throw new McpConnectionError(this.serverName, new Error(errorMessage))
    }
  }

  /**
   * List available resources from the server
   */
  async listResources(): Promise<McpResource[]> {
    if (!this.client || !this.isConnected()) {
      throw new McpConnectionError(this.serverName, new Error('Client not connected'))
    }

    try {
      const response = await this.client.listResources({})

      return response.resources.map((resource) => ({
        uri: resource.uri,
        name: resource.name,
        description: resource.description,
        mimeType: resource.mimeType,
      }))
    } catch (error) {
      throw new McpConnectionError(this.serverName, error instanceof Error ? error : new Error(String(error)))
    }
  }

  /**
   * Read a resource from the server
   */
  async readResource(uri: string): Promise<string> {
    if (!this.client || !this.isConnected()) {
      throw new McpConnectionError(this.serverName, new Error('Client not connected'))
    }

    try {
      const response = await this.client.readResource({ uri })

      // Extract and join all text content from response
      // ResourceContents has either 'text' or 'blob' property
      const textParts =
        response.contents?.filter((c): c is { uri: string; text: string; mimeType?: string } => 'text' in c).map((c) => c.text) || []

      return textParts.length > 0 ? textParts.join('\n') : JSON.stringify(response, null, 2)
    } catch (error) {
      throw new McpConnectionError(this.serverName, error instanceof Error ? error : new Error(String(error)))
    }
  }

  /**
   * Get the server name
   */
  getServerName(): string {
    return this.serverName
  }
}
