// generated by polka.codes

import { type ChildProcess, spawn } from 'node:child_process'
import { EventEmitter } from 'node:events'

/**
 * JSON-RPC message format used by MCP
 */
export interface JsonRpcMessage {
  jsonrpc: '2.0'
  id?: number | string
  method?: string
  params?: unknown
  result?: unknown
  error?: {
    code: number
    message: string
    data?: unknown
  }
}

/**
 * Transport layer for communicating with MCP servers
 */
export class StdioTransport extends EventEmitter {
  private process: ChildProcess | null = null
  private messageId = 0
  private pendingRequests = new Map<number | string, { resolve: (value: unknown) => void; reject: (error: Error) => void }>()
  private buffer = ''

  constructor(private readonly config: { command: string; args?: string[]; env?: Record<string, string> }) {
    super()
  }

  /**
   * Start the MCP server process
   */
  async start(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.process = spawn(this.config.command, this.config.args || [], {
          env: { ...process.env, ...this.config.env },
          stdio: ['pipe', 'pipe', 'inherit'],
        })

        const proc = this.process

        if (!proc.stdout) {
          reject(new Error('Failed to create stdout for MCP process'))
          return
        }

        if (!proc.stdin) {
          reject(new Error('Failed to create stdin for MCP process'))
          return
        }

        // Handle stdout from MCP server
        proc.stdout.on('data', (data: Buffer) => {
          this.handleData(data.toString())
        })

        // Handle process exit
        proc.on('exit', (code, signal) => {
          this.emit('close', { code, signal })
          // Reject all pending requests
          for (const [id, { reject }] of this.pendingRequests) {
            reject(new Error(`MCP process exited with code ${code} and signal ${signal}`))
            this.pendingRequests.delete(id)
          }
        })

        // Handle process errors
        proc.on('error', (error: Error) => {
          this.emit('error', error)
          reject(error)
        })

        // Wait a bit for the process to start
        setTimeout(() => resolve(), 100)
      } catch (error) {
        reject(error)
      }
    })
  }

  /**
   * Stop the MCP server process
   */
  async stop(): Promise<void> {
    if (this.process) {
      this.process.kill('SIGTERM')
      this.process = null
    }
  }

  /**
   * Send a JSON-RPC request and wait for response
   */
  async sendRequest(method: string, params?: unknown): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const id = ++this.messageId

      // Store the promise callbacks
      this.pendingRequests.set(id, { resolve, reject })

      // Send the request
      const message: JsonRpcMessage = {
        jsonrpc: '2.0',
        id,
        method,
        params,
      }

      this.sendMessage(message)

      // Set timeout (default 30 seconds)
      setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id)
          reject(new Error(`Request timeout: ${method}`))
        }
      }, 30000)
    })
  }

  /**
   * Send a JSON-RPC notification (no response expected)
   */
  sendNotification(method: string, params?: unknown): void {
    const message: JsonRpcMessage = {
      jsonrpc: '2.0',
      method,
      params,
    }
    this.sendMessage(message)
  }

  /**
   * Send a raw message to the MCP server
   */
  private sendMessage(message: JsonRpcMessage): void {
    if (!this.process?.stdin) {
      throw new Error('MCP process not running or stdin not available')
    }

    const json = JSON.stringify(message)
    this.process.stdin.write(`${json}\n`)
  }

  /**
   * Handle incoming data from the MCP server
   */
  private handleData(data: string): void {
    this.buffer += data

    // Process complete messages (separated by newlines)
    const lines = this.buffer.split('\n')
    this.buffer = lines.pop() || ''

    for (const line of lines) {
      if (!line.trim()) continue

      try {
        const message: JsonRpcMessage = JSON.parse(line)

        // Handle response to a request
        if (message.id !== undefined) {
          const pending = this.pendingRequests.get(message.id)
          if (pending) {
            this.pendingRequests.delete(message.id)

            if (message.error) {
              pending.reject(new Error(`${message.error.message} (${message.error.code})`))
            } else {
              pending.resolve(message.result)
            }
          }
        } else {
          // Handle notification
          this.emit('notification', message)
        }
      } catch (_error) {
        this.emit('error', new Error(`Failed to parse MCP message: ${line}`))
      }
    }
  }

  /**
   * Check if the process is running
   */
  isRunning(): boolean {
    return this.process !== null && this.process.exitCode === null
  }
}
