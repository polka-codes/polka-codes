// generated by polka.codes

import { type ChildProcess, spawn } from 'node:child_process'
import { EventEmitter } from 'node:events'

/**
 * JSON-RPC message format used by MCP
 */
export interface JsonRpcMessage {
  jsonrpc: '2.0'
  id?: number | string
  method?: string
  params?: unknown
  result?: unknown
  error?: {
    code: number
    message: string
    data?: unknown
  }
}

/**
 * Transport layer for communicating with MCP servers
 */
export class StdioTransport extends EventEmitter {
  private process: ChildProcess | null = null
  private messageId = 0
  private pendingRequests = new Map<number | string, { resolve: (value: unknown) => void; reject: (error: Error) => void }>()
  private buffer = ''

  constructor(private readonly config: { command: string; args?: string[]; env?: Record<string, string> }) {
    super()
  }

  /**
   * Start the MCP server process
   */
  async start(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.process = spawn(this.config.command, this.config.args || [], {
          env: { ...process.env, ...this.config.env },
          stdio: ['pipe', 'pipe', 'inherit'],
        })

        const proc = this.process

        if (!proc.stdout) {
          reject(new Error('Failed to create stdout for MCP process'))
          return
        }

        if (!proc.stdin) {
          reject(new Error('Failed to create stdin for MCP process'))
          return
        }

        // Handle stdout from MCP server
        proc.stdout.on('data', (data: Buffer) => {
          this.handleData(data.toString())
        })

        // Handle process exit
        proc.on('exit', (code, signal) => {
          this.emit('close', { code, signal })
          // Reject all pending requests
          for (const [id, { reject }] of this.pendingRequests) {
            reject(new Error(`MCP process exited with code ${code} and signal ${signal}`))
            this.pendingRequests.delete(id)
          }
        })

        // Handle process errors
        proc.on('error', (error: Error) => {
          this.emit('error', error)
          reject(error)
        })

        // Wait a bit for the process to start
        setTimeout(() => resolve(), 100)
      } catch (error) {
        reject(error)
      }
    })
  }

  /**
   * Stop the MCP server process
   */
  async stop(): Promise<void> {
    if (this.process) {
      this.process.kill('SIGTERM')
      this.process = null
    }
  }

  /**
   * Send a JSON-RPC request and wait for response
   */
  async sendRequest(method: string, params?: unknown): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const id = ++this.messageId

      // Store the promise callbacks
      this.pendingRequests.set(id, { resolve, reject })

      // Send the request
      const message: JsonRpcMessage = {
        jsonrpc: '2.0',
        id,
        method,
        params,
      }

      this.sendMessage(message)

      // Set timeout (default 30 seconds)
      setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id)
          reject(new Error(`Request timeout: ${method}`))
        }
      }, 30000)
    })
  }

  /**
   * Send a JSON-RPC notification (no response expected)
   */
  sendNotification(method: string, params?: unknown): void {
    const message: JsonRpcMessage = {
      jsonrpc: '2.0',
      method,
      params,
    }
    this.sendMessage(message)
  }

  /**
   * Send a raw message to the MCP server
   */
  private sendMessage(message: JsonRpcMessage): void {
    if (!this.process?.stdin) {
      throw new Error('MCP process not running or stdin not available')
    }

    const json = JSON.stringify(message)
    this.process.stdin.write(`${json}\n`)
  }

  /**
   * Handle incoming data from the MCP server
   * Supports both Content-Length header framing and newline-delimited messages
   */
  private handleData(data: string): void {
    this.buffer += data

    // Try to parse messages using Content-Length framing first
    while (this.buffer.length > 0) {
      // Check for Content-Length header format
      const contentLengthMatch = this.buffer.match(/^Content-Length:\s*(\d+)\r?\n\r?\n/i)

      if (contentLengthMatch) {
        const contentLength = Number.parseInt(contentLengthMatch[1], 10)
        const headerEnd = contentLengthMatch[0].length
        const totalLength = headerEnd + contentLength

        if (this.buffer.length >= totalLength) {
          const messageData = this.buffer.slice(headerEnd, totalLength)
          this.buffer = this.buffer.slice(totalLength)

          try {
            const message: JsonRpcMessage = JSON.parse(messageData)
            this.processMessage(message)
          } catch (_error) {
            this.emit('error', new Error(`Failed to parse MCP message: ${messageData}`))
          }
          continue
        } else {
          // Need more data
          break
        }
      }

      // Fall back to newline-delimited parsing (for compatibility)
      const newlineIndex = this.buffer.indexOf('\n')
      if (newlineIndex !== -1) {
        const line = this.buffer.slice(0, newlineIndex)
        this.buffer = this.buffer.slice(newlineIndex + 1)

        if (!line.trim()) continue

        try {
          const message: JsonRpcMessage = JSON.parse(line)
          this.processMessage(message)
        } catch (_error) {
          this.emit('error', new Error(`Failed to parse MCP message: ${line}`))
        }
        continue
      }

      // No complete message found
      break
    }
  }

  /**
   * Process a parsed JSON-RPC message
   */
  private processMessage(message: JsonRpcMessage): void {
    // Handle response to a request
    if (message.id !== undefined) {
      const pending = this.pendingRequests.get(message.id)
      if (pending) {
        this.pendingRequests.delete(message.id)

        if (message.error) {
          pending.reject(new Error(`${message.error.message} (${message.error.code})`))
        } else {
          pending.resolve(message.result)
        }
      }
    } else {
      // Handle notification
      this.emit('notification', message)
    }
  }

  /**
   * Check if the process is running
   */
  isRunning(): boolean {
    return this.process !== null && this.process.exitCode === null
  }
}
