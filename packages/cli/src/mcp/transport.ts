// generated by polka.codes

import { type ChildProcess, spawn } from 'node:child_process'
import { EventEmitter } from 'node:events'
import { StringDecoder } from 'node:string_decoder'

/**
 * JSON-RPC message format used by MCP
 */
export interface JsonRpcMessage {
  jsonrpc: '2.0'
  id?: number | string
  method?: string
  params?: unknown
  result?: unknown
  error?: {
    code: number
    message: string
    data?: unknown
  }
}

/**
 * Transport layer for communicating with MCP servers
 */
export class StdioTransport extends EventEmitter {
  private process: ChildProcess | null = null
  private messageId = 0
  private pendingRequests = new Map<number | string, { resolve: (value: unknown) => void; reject: (error: Error) => void }>()
  private buffer = ''
  private decoder = new StringDecoder('utf8') // Properly handle multi-byte characters across chunk boundaries
  // Store event handler references for cleanup
  private stdoutDataHandler: ((data: Buffer) => void) | null = null
  private exitHandler: ((code: number | null, signal: NodeJS.Signals | null) => void) | null = null
  private errorHandler: ((error: Error) => void) | null = null

  constructor(private readonly config: { command: string; args?: string[]; env?: Record<string, string> }) {
    super()
  }

  /**
   * Start the MCP server process
   */
  async start(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.process = spawn(this.config.command, this.config.args || [], {
          env: { ...process.env, ...this.config.env },
          stdio: ['pipe', 'pipe', 'inherit'],
        })

        const proc = this.process

        if (!proc.stdout) {
          reject(new Error('Failed to create stdout for MCP process'))
          return
        }

        if (!proc.stdin) {
          reject(new Error('Failed to create stdin for MCP process'))
          return
        }

        // Store handler references for cleanup
        this.stdoutDataHandler = (data: Buffer) => {
          this.handleData(this.decoder.write(data))
        }

        this.exitHandler = (code, signal) => {
          this.emit('close', { code, signal })
          // Reject all pending requests
          for (const [id, { reject }] of this.pendingRequests) {
            reject(new Error(`MCP process exited with code ${code} and signal ${signal}`))
            this.pendingRequests.delete(id)
          }
        }

        this.errorHandler = (error: Error) => {
          this.emit('error', error)
          reject(error)
        }

        // Handle stdout from MCP server
        proc.stdout.on('data', this.stdoutDataHandler)

        // Handle process exit
        proc.on('exit', this.exitHandler)

        // Handle process errors
        proc.on('error', this.errorHandler)

        // Wait a bit for the process to start
        setTimeout(() => resolve(), 100)
      } catch (error) {
        reject(error)
      }
    })
  }

  /**
   * Stop the MCP server process and clean up event listeners
   */
  async stop(): Promise<void> {
    if (this.process) {
      // Remove event listeners to prevent memory leaks
      if (this.stdoutDataHandler && this.process.stdout) {
        this.process.stdout.off('data', this.stdoutDataHandler)
      }
      if (this.exitHandler) {
        this.process.off('exit', this.exitHandler)
      }
      if (this.errorHandler) {
        this.process.off('error', this.errorHandler)
      }

      // Clear handler references
      this.stdoutDataHandler = null
      this.exitHandler = null
      this.errorHandler = null

      // Kill the process
      this.process.kill('SIGTERM')
      this.process = null
    }

    // Clear all pending requests
    for (const [id, { reject }] of this.pendingRequests) {
      reject(new Error('MCP transport stopped'))
      this.pendingRequests.delete(id)
    }
  }

  /**
   * Send a JSON-RPC request and wait for response
   */
  async sendRequest(method: string, params?: unknown): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const id = ++this.messageId

      // Store the promise callbacks
      this.pendingRequests.set(id, { resolve, reject })

      // Send the request
      const message: JsonRpcMessage = {
        jsonrpc: '2.0',
        id,
        method,
        params,
      }

      this.sendMessage(message)

      // Set timeout (default 30 seconds) - store timeout ID for cleanup
      const timeoutId = setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id)
          reject(new Error(`Request timeout: ${method}`))
        }
      }, 30000)

      // Clear timeout when request completes (store timeout with pending request)
      const pending = this.pendingRequests.get(id)
      if (pending) {
        // Augment the pending request with timeout cleanup
        this.pendingRequests.set(id, {
          resolve: (value: unknown) => {
            clearTimeout(timeoutId)
            resolve(value)
          },
          reject: (error: Error) => {
            clearTimeout(timeoutId)
            reject(error)
          },
        })
      }
    })
  }

  /**
   * Send a JSON-RPC notification (no response expected)
   */
  sendNotification(method: string, params?: unknown): void {
    const message: JsonRpcMessage = {
      jsonrpc: '2.0',
      method,
      params,
    }
    this.sendMessage(message)
  }

  /**
   * Send a raw message to the MCP server
   */
  private sendMessage(message: JsonRpcMessage): void {
    if (!this.process?.stdin) {
      throw new Error('MCP process not running or stdin not available')
    }

    const json = JSON.stringify(message)
    this.process.stdin.write(`${json}\n`)
  }

  /**
   * Handle incoming data from the MCP server
   * Supports both Content-Length header framing and newline-delimited messages
   */
  private handleData(data: string): void {
    // Prevent memory exhaustion from malicious or malfunctioning servers
    const MAX_BUFFER_SIZE = 10 * 1024 * 1024 // 10MB
    if (this.buffer.length + data.length > MAX_BUFFER_SIZE) {
      throw new Error(`Buffer exceeded maximum size of ${MAX_BUFFER_SIZE} bytes. Possible malicious server or malformed data.`)
    }

    this.buffer += data

    // Try to parse messages using Content-Length framing first
    while (this.buffer.length > 0) {
      // Check for Content-Length header format (not anchored to start for robustness)
      const contentLengthMatch = this.buffer.match(/Content-Length:\s*(\d+)\r?\n\r?\n/i)

      if (contentLengthMatch) {
        const contentLength = Number.parseInt(contentLengthMatch[1], 10)
        const matchStart = contentLengthMatch.index ?? 0
        const headerEnd = matchStart + contentLengthMatch[0].length
        const totalLength = headerEnd + contentLength

        // If we have enough data, extract the message
        if (this.buffer.length >= totalLength) {
          // Skip any data before the header
          if (matchStart > 0) {
            this.buffer = this.buffer.slice(matchStart)
          }

          const messageData = this.buffer.slice(contentLengthMatch[0].length, contentLengthMatch[0].length + contentLength)
          this.buffer = this.buffer.slice(totalLength - matchStart)

          try {
            const message: JsonRpcMessage = JSON.parse(messageData)
            this.processMessage(message)
          } catch (error) {
            // Log parse errors instead of emitting to avoid unhandled error events
            console.warn(`[MCP Transport] Failed to parse message: ${messageData.slice(0, 100)}...`)
            console.debug(`[MCP Transport] Parse error:`, error)
          }
          continue
        } else {
          // Need more data
          break
        }
      }

      // Fall back to newline-delimited parsing (for compatibility)
      const newlineIndex = this.buffer.indexOf('\n')
      if (newlineIndex !== -1) {
        const line = this.buffer.slice(0, newlineIndex)
        this.buffer = this.buffer.slice(newlineIndex + 1)

        if (!line.trim()) continue

        try {
          const message: JsonRpcMessage = JSON.parse(line)
          this.processMessage(message)
        } catch (error) {
          // Log parse errors instead of emitting to avoid unhandled error events
          console.warn(`[MCP Transport] Failed to parse message: ${line.slice(0, 100)}...`)
          console.debug(`[MCP Transport] Parse error:`, error)
        }
        continue
      }

      // No complete message found
      break
    }
  }

  /**
   * Process a parsed JSON-RPC message
   */
  private processMessage(message: JsonRpcMessage): void {
    // Handle response to a request
    if (message.id !== undefined) {
      const pending = this.pendingRequests.get(message.id)
      if (pending) {
        this.pendingRequests.delete(message.id)

        if (message.error) {
          pending.reject(new Error(`${message.error.message} (${message.error.code})`))
        } else {
          pending.resolve(message.result)
        }
      }
    } else {
      // Handle notification
      this.emit('notification', message)
    }
  }

  /**
   * Check if the process is running
   */
  isRunning(): boolean {
    return this.process !== null && this.process.exitCode === null
  }
}
