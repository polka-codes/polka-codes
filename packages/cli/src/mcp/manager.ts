// generated by polka.codes

import type { FullToolInfo, Logger, McpServerConfig, ToolResponse } from '@polka-codes/core'
import { convertJsonSchemaToZod } from '@polka-codes/core'
import type { z } from 'zod'
import { createMcpClient } from './client'
import { McpConnectionError, McpServerError } from './errors'
import type { IMcpClient, McpTool } from './types'

type ConfigMcpServerConfig = McpServerConfig

/**
 * Manages MCP server connections and tools
 */
export class McpManager {
  private connections = new Map<string, IMcpClient>()
  private tools = new Map<string, { serverName: string; tool: McpTool }>()

  constructor(private readonly logger?: Logger) {}

  /**
   * Connect to all configured MCP servers
   */
  async connectToServers(servers: Record<string, ConfigMcpServerConfig>): Promise<void> {
    for (const [serverName, serverConfig] of Object.entries(servers)) {
      try {
        await this.connectToServer(serverName, serverConfig)
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error)
        if (this.logger) {
          this.logger.warn(`Failed to connect to MCP server '${serverName}': ${errorMessage}`)
        } else {
          console.warn(`Failed to connect to MCP server '${serverName}': ${errorMessage}`)
        }
        // Continue connecting to other servers even if one fails
      }
    }
  }

  /**
   * Connect to a single MCP server
   */
  async connectToServer(serverName: string, serverConfig: ConfigMcpServerConfig): Promise<void> {
    if (this.connections.has(serverName)) {
      if (this.logger) {
        this.logger.warn(`MCP server '${serverName}' is already connected`)
      }
      return
    }

    if (!serverConfig.command) {
      throw new McpConnectionError(serverName, new Error('No command specified for MCP server'))
    }

    try {
      const client = await createMcpClient(serverName, {
        command: serverConfig.command,
        args: serverConfig.args,
        env: serverConfig.env,
      })

      this.connections.set(serverName, client)

      // List available tools from the server
      const serverTools = await client.listTools()

      // Register tools
      for (const tool of serverTools) {
        const fullToolName = `${serverName}/${tool.name}`
        this.tools.set(fullToolName, { serverName, tool })
      }

      if (this.logger) {
        this.logger.info(`Connected to MCP server '${serverName}' with ${serverTools.length} tools`)
      }
    } catch (error) {
      throw new McpConnectionError(serverName, error instanceof Error ? error : new Error(String(error)))
    }
  }

  /**
   * Disconnect from all MCP servers
   */
  async disconnectAll(): Promise<void> {
    const disconnectPromises: Promise<void>[] = []

    for (const [serverName, client] of this.connections.entries()) {
      disconnectPromises.push(
        client.disconnect().catch((error) => {
          if (this.logger) {
            this.logger.warn(`Error disconnecting from MCP server '${serverName}': ${error}`)
          }
        }),
      )
    }

    await Promise.all(disconnectPromises)
    this.connections.clear()
    this.tools.clear()
  }

  /**
   * Disconnect from a specific MCP server
   */
  async disconnectServer(serverName: string): Promise<void> {
    const client = this.connections.get(serverName)
    if (!client) {
      throw new McpServerError(serverName)
    }

    await client.disconnect()
    this.connections.delete(serverName)

    // Remove tools from this server
    for (const [toolName, { serverName: s }] of this.tools.entries()) {
      if (s === serverName) {
        this.tools.delete(toolName)
      }
    }
  }

  /**
   * Get all available tools from all connected MCP servers
   */
  getAllTools(): Map<string, { serverName: string; tool: McpTool }> {
    return new Map(this.tools)
  }

  /**
   * Get tools from a specific server
   */
  getServerTools(serverName: string): Map<string, McpTool> {
    const serverTools = new Map<string, McpTool>()

    for (const [toolName, { serverName: s, tool }] of this.tools.entries()) {
      if (s === serverName) {
        serverTools.set(toolName, tool)
      }
    }

    return serverTools
  }

  /**
   * Call a tool on an MCP server
   */
  async callTool(fullToolName: string, args: Record<string, unknown>): Promise<unknown> {
    const toolInfo = this.tools.get(fullToolName)

    if (!toolInfo) {
      throw new Error(`Tool '${fullToolName}' not found`)
    }

    const { serverName, tool } = toolInfo
    const client = this.connections.get(serverName)

    if (!client) {
      throw new McpServerError(serverName)
    }

    const result = await client.callTool(tool.name, args)

    // Check if the tool call returned an error
    if (result.isError) {
      throw new Error(`Tool '${fullToolName}' returned an error: ${JSON.stringify(result.content)}`)
    }

    // Return the text content from the tool result
    if (result.content && result.content.length > 0) {
      const textParts = result.content.filter((c) => c.type === 'text').map((c) => (c as { text: string }).text)
      return textParts.join('\n')
    }

    return undefined
  }

  /**
   * Check if a tool exists
   */
  hasTool(toolName: string): boolean {
    return this.tools.has(toolName)
  }

  /**
   * Get tool information
   */
  getTool(toolName: string): { serverName: string; tool: McpTool } | undefined {
    return this.tools.get(toolName)
  }

  /**
   * List all connected servers
   */
  listConnectedServers(): string[] {
    return Array.from(this.connections.keys())
  }

  /**
   * Check if a server is connected
   */
  isServerConnected(serverName: string): boolean {
    return this.connections.has(serverName)
  }

  /**
   * Convert MCP tools to FullToolInfo format for use in workflows
   * This allows MCP tools to be exposed to AI agents
   */
  getFullToolInfos(): FullToolInfo[] {
    const toolInfos: FullToolInfo[] = []

    for (const [fullToolName, { tool }] of this.tools.entries()) {
      // Convert the MCP tool's inputSchema to a Zod schema
      // MCP tools use JSON Schema, we need to convert to Zod
      let zodSchema: z.ZodObject<any>

      try {
        // MCP schemas are JSON Schema compatible, but use looser types
        // Cast to JsonSchema to satisfy convertJsonSchemaToZod
        zodSchema = convertJsonSchemaToZod(tool.inputSchema as any) as z.ZodObject<any>
      } catch (error) {
        // If schema conversion fails, skip the tool rather than using a dangerous fallback
        const errorMessage = error instanceof Error ? error.message : String(error)
        if (this.logger) {
          this.logger.error(
            `Skipping MCP tool '${fullToolName}' due to schema conversion error: ${errorMessage}. ` +
              `The tool may have unsupported JSON Schema features. ` +
              `Please report this if the tool should be supported.`,
          )
        }
        continue // Skip this tool entirely
      }

      const description = tool.description || `MCP tool: ${fullToolName}`

      toolInfos.push({
        name: fullToolName,
        description,
        parameters: zodSchema,
        handler: async (_provider, args) => {
          try {
            const result = await this.callTool(fullToolName, args)

            // Return the result in the expected format
            const response: ToolResponse = {
              success: true,
              message: {
                type: 'text',
                value: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
              },
            }
            return response
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error)
            const errorResponse: ToolResponse = {
              success: false,
              message: {
                type: 'error-text',
                value: `Error calling MCP tool '${fullToolName}': ${errorMessage}`,
              },
            }
            return errorResponse
          }
        },
      })
    }

    return toolInfos
  }
}
