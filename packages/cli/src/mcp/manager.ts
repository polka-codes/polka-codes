// generated by polka.codes

import type { FullToolInfo, Logger, McpServerConfig, ToolResponse } from '@polka-codes/core'
import { z } from 'zod'
import { createMcpClient } from './client'
import { McpConnectionError, McpServerError } from './errors'
import type { IMcpClient, McpTool } from './types'

type ConfigMcpServerConfig = McpServerConfig

/**
 * Manages MCP server connections and tools
 */
export class McpManager {
  private connections = new Map<string, IMcpClient>()
  private tools = new Map<string, { serverName: string; tool: McpTool }>()

  constructor(private readonly logger?: Logger) {}

  /**
   * Connect to all configured MCP servers
   */
  async connectToServers(servers: Record<string, ConfigMcpServerConfig>): Promise<void> {
    for (const [serverName, serverConfig] of Object.entries(servers)) {
      try {
        await this.connectToServer(serverName, serverConfig)
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error)
        if (this.logger) {
          this.logger.warn(`Failed to connect to MCP server '${serverName}': ${errorMessage}`)
        } else {
          console.warn(`Failed to connect to MCP server '${serverName}': ${errorMessage}`)
        }
        // Continue connecting to other servers even if one fails
      }
    }
  }

  /**
   * Connect to a single MCP server
   */
  async connectToServer(serverName: string, serverConfig: ConfigMcpServerConfig): Promise<void> {
    if (this.connections.has(serverName)) {
      if (this.logger) {
        this.logger.warn(`MCP server '${serverName}' is already connected`)
      }
      return
    }

    if (!serverConfig.command) {
      throw new McpConnectionError(serverName, new Error('No command specified for MCP server'))
    }

    try {
      const client = await createMcpClient(serverName, {
        command: serverConfig.command,
        args: serverConfig.args,
        env: serverConfig.env,
      })

      this.connections.set(serverName, client)

      // List available tools from the server
      const serverTools = await client.listTools()

      // Register tools
      for (const tool of serverTools) {
        const fullToolName = `${serverName}/${tool.name}`
        this.tools.set(fullToolName, { serverName, tool })
      }

      if (this.logger) {
        this.logger.info(`Connected to MCP server '${serverName}' with ${serverTools.length} tools`)
      }
    } catch (error) {
      throw new McpConnectionError(serverName, error instanceof Error ? error : new Error(String(error)))
    }
  }

  /**
   * Disconnect from all MCP servers
   */
  async disconnectAll(): Promise<void> {
    const disconnectPromises: Promise<void>[] = []

    for (const [serverName, client] of this.connections.entries()) {
      disconnectPromises.push(
        client.disconnect().catch((error) => {
          if (this.logger) {
            this.logger.warn(`Error disconnecting from MCP server '${serverName}': ${error}`)
          }
        }),
      )
    }

    await Promise.all(disconnectPromises)
    this.connections.clear()
    this.tools.clear()
  }

  /**
   * Disconnect from a specific MCP server
   */
  async disconnectServer(serverName: string): Promise<void> {
    const client = this.connections.get(serverName)
    if (!client) {
      throw new McpServerError(serverName)
    }

    await client.disconnect()
    this.connections.delete(serverName)

    // Remove tools from this server
    for (const [toolName, { serverName: s }] of this.tools.entries()) {
      if (s === serverName) {
        this.tools.delete(toolName)
      }
    }
  }

  /**
   * Get all available tools from all connected MCP servers
   */
  getAllTools(): Map<string, { serverName: string; tool: McpTool }> {
    return new Map(this.tools)
  }

  /**
   * Get tools from a specific server
   */
  getServerTools(serverName: string): Map<string, McpTool> {
    const serverTools = new Map<string, McpTool>()

    for (const [toolName, { serverName: s, tool }] of this.tools.entries()) {
      if (s === serverName) {
        serverTools.set(toolName, tool)
      }
    }

    return serverTools
  }

  /**
   * Call a tool on an MCP server
   */
  async callTool(fullToolName: string, args: Record<string, unknown>): Promise<unknown> {
    const toolInfo = this.tools.get(fullToolName)

    if (!toolInfo) {
      throw new Error(`Tool '${fullToolName}' not found`)
    }

    const { serverName, tool } = toolInfo
    const client = this.connections.get(serverName)

    if (!client) {
      throw new McpServerError(serverName)
    }

    const result = await client.callTool(tool.name, args)

    // Check if the tool call returned an error
    if (result.isError) {
      throw new Error(`Tool '${fullToolName}' returned an error: ${JSON.stringify(result.content)}`)
    }

    // Return the text content from the tool result
    if (result.content && result.content.length > 0) {
      const textParts = result.content.filter((c) => c.type === 'text').map((c) => (c as { text: string }).text)
      return textParts.join('\n')
    }

    return undefined
  }

  /**
   * Check if a tool exists
   */
  hasTool(toolName: string): boolean {
    return this.tools.has(toolName)
  }

  /**
   * Get tool information
   */
  getTool(toolName: string): { serverName: string; tool: McpTool } | undefined {
    return this.tools.get(toolName)
  }

  /**
   * List all connected servers
   */
  listConnectedServers(): string[] {
    return Array.from(this.connections.keys())
  }

  /**
   * Check if a server is connected
   */
  isServerConnected(serverName: string): boolean {
    return this.connections.has(serverName)
  }

  /**
   * Convert MCP tools to FullToolInfo format for use in workflows
   * This allows MCP tools to be exposed to AI agents
   */
  getFullToolInfos(): FullToolInfo[] {
    const toolInfos: FullToolInfo[] = []

    for (const [fullToolName, { tool }] of this.tools.entries()) {
      // Convert the MCP tool's inputSchema to a Zod schema
      // MCP tools use JSON Schema, we need to convert to Zod
      let zodSchema: z.ZodObject<any>

      try {
        zodSchema = this.jsonSchemaToZod(tool.inputSchema)
      } catch (error) {
        // If schema conversion fails, use a generic object schema
        if (this.logger) {
          this.logger.warn(`Failed to convert schema for MCP tool '${fullToolName}': ${error}`)
        }
        zodSchema = z.object({}) as any
      }

      const description = tool.description || `MCP tool: ${fullToolName}`

      toolInfos.push({
        name: fullToolName,
        description,
        parameters: zodSchema,
        handler: async (_provider, args) => {
          try {
            const result = await this.callTool(fullToolName, args)

            // Return the result in the expected format
            const response: ToolResponse = {
              success: true,
              message: {
                type: 'text',
                value: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
              },
            }
            return response
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error)
            const errorResponse: ToolResponse = {
              success: false,
              message: {
                type: 'error-text',
                value: `Error calling MCP tool '${fullToolName}': ${errorMessage}`,
              },
            }
            return errorResponse
          }
        },
      })
    }

    return toolInfos
  }

  /**
   * Convert JSON Schema to Zod schema
   * This is a simplified converter that handles common cases
   */
  private jsonSchemaToZod(schema: Record<string, unknown>): z.ZodObject<any> {
    const properties: Record<string, z.ZodTypeAny> = {}
    const required: string[] = []

    if (schema.properties && typeof schema.properties === 'object') {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        const propDef = propSchema as Record<string, unknown>
        properties[propName] = this.convertProperty(propDef)
      }
    }

    if (Array.isArray(schema.required)) {
      required.push(...schema.required)
    }

    // Build the object schema
    let objectSchema: any = z.object(properties)

    // Make non-required fields optional
    if (required.length > 0) {
      const optionalSchema: Record<string, z.ZodTypeAny> = {}
      for (const [key, value] of Object.entries(properties)) {
        if (!required.includes(key)) {
          optionalSchema[key] = value.optional()
        } else {
          optionalSchema[key] = value
        }
      }
      objectSchema = z.object(optionalSchema)
    }

    return objectSchema
  }

  /**
   * Convert a JSON Schema property definition to Zod type
   */
  private convertProperty(propDef: Record<string, unknown>): z.ZodTypeAny {
    const type = propDef.type

    // Handle enum type
    if (propDef.enum && Array.isArray(propDef.enum)) {
      const enumValues = propDef.enum
      // z.enum requires at least one value and all values must be strings
      if (enumValues.length > 0 && enumValues.every((v) => typeof v === 'string')) {
        return z.enum(enumValues as [string, ...string[]])
      }
      // For empty enums or non-string enums, fall back to z.any()
    }

    // Handle const type
    if (propDef.const !== undefined) {
      const constValue = propDef.const
      // z.literal only accepts string, number, boolean, or null as const values
      if (typeof constValue === 'string' || typeof constValue === 'number' || typeof constValue === 'boolean' || constValue === null) {
        return z.literal(constValue as string | number | boolean | null)
      }
      // For other const values (objects, arrays), fall back to z.any()
    }

    switch (type) {
      case 'string':
        return z.string()
      case 'number':
      case 'integer':
        return z.number()
      case 'boolean':
        return z.boolean()
      case 'array':
        if (propDef.items && typeof propDef.items === 'object') {
          const itemsSchema = this.convertProperty(propDef.items as Record<string, unknown>)
          return z.array(itemsSchema)
        }
        return z.array(z.any())
      case 'object':
        if (propDef.properties && typeof propDef.properties === 'object') {
          return this.jsonSchemaToZod(propDef as Record<string, unknown>)
        }
        return z.record(z.string(), z.any())
      default:
        // Log unsupported types for debugging
        if (this.logger) {
          this.logger.debug(`Unsupported JSON Schema type: ${type}, falling back to z.any()`)
        }
        return z.any()
    }
  }
}
