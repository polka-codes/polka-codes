// Error scenario tests for MCP tools
// generated by polka.codes

import { describe, expect, test } from 'bun:test'
import { z } from 'zod'
import { adaptMcpSchemaToZod } from './tools'

describe('MCP Tools - Error Scenarios', () => {
  describe('adaptMcpSchemaToZod - Error Handling', () => {
    test('should handle malformed schemas gracefully', () => {
      const malformedSchema = {
        type: 'invalid-type',
        properties: null,
      }

      const result = adaptMcpSchemaToZod(malformedSchema)

      // Should still return a valid Zod schema
      expect(result).toBeInstanceOf(z.ZodType)

      // Should accept various inputs without throwing
      const validResult = result.safeParse({ any: 'input' })
      expect(validResult.success).toBe(true)
    })

    test('should handle circular references', () => {
      const circular: any = { type: 'object' }
      circular.self = circular

      const result = adaptMcpSchemaToZod(circular)

      // Should not throw and should return a valid Zod schema
      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle arrays as schemas', () => {
      const arraySchema = [{ type: 'string' }, { type: 'number' }]

      const result = adaptMcpSchemaToZod(arraySchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle deeply nested objects', () => {
      const deepSchema = {
        level1: {
          level2: {
            level3: {
              level4: {
                type: 'string',
              },
            },
          },
        },
      }

      const result = adaptMcpSchemaToZod(deepSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schemas with special characters in keys', () => {
      const specialKeySchema = {
        'key-with-dash': { type: 'string' },
        key_with_underscore: { type: 'number' },
        'key.with.dots': { type: 'boolean' },
        'key with spaces': { type: 'string' },
      }

      const result = adaptMcpSchemaToZod(specialKeySchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle empty schemas', () => {
      const emptySchema = {}

      const result = adaptMcpSchemaToZod(emptySchema)

      expect(result).toBeInstanceOf(z.ZodType)

      // Should validate empty object
      const validResult = result.safeParse({})
      expect(validResult.success).toBe(true)
    })

    test('should handle schemas with conflicting types', () => {
      const conflictSchema = {
        type: ['string', 'number', 'boolean'],
        properties: {
          field1: { type: 'string' },
          field2: { type: 'number' },
        },
      }

      const result = adaptMcpSchemaToZod(conflictSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle very large schemas', () => {
      const largeSchema: any = {
        type: 'object',
        properties: {},
      }

      // Create 100 properties
      for (let i = 0; i < 100; i++) {
        largeSchema.properties[`field${i}`] = { type: 'string' }
      }

      const result = adaptMcpSchemaToZod(largeSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schemas with enum values', () => {
      const enumSchema = {
        type: 'string',
        enum: ['value1', 'value2', 'value3'],
      }

      const result = adaptMcpSchemaToZod(enumSchema)

      expect(result).toBeInstanceOf(z.ZodType)

      // Our adapter creates a flexible schema (record or passthrough object)
      // that works with various input types since it can't fully parse JSON Schema
      // The actual enum validation happens on the MCP server side
      const objectResult = result.safeParse({ any: 'input' })
      expect(objectResult.success).toBe(true)
    })

    test('should handle Zod schemas with complex transformations', () => {
      const complexZodSchema = z
        .object({
          email: z.string().email(),
          age: z.number().min(0).max(120),
          name: z.string().min(1),
        })
        .transform((data) => ({
          ...data,
          formatted: `${data.name} (${data.email})`,
        }))

      const result = adaptMcpSchemaToZod(complexZodSchema)

      // Should detect it's a Zod schema and return it
      expect(result).toBe(complexZodSchema)
    })

    test('should handle schemas with regex patterns', () => {
      const regexSchema = {
        type: 'string',
        pattern: '^[a-zA-Z0-9]+$',
      }

      const result = adaptMcpSchemaToZod(regexSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schemas with $schema reference', () => {
      const draft7Schema = {
        $schema: 'http://json-schema.org/draft-07/schema#',
        type: 'object',
        properties: {
          name: { type: 'string' },
        },
      }

      const result = adaptMcpSchemaToZod(draft7Schema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schemas with allOf', () => {
      const allOfSchema = {
        allOf: [
          { type: 'object', properties: { a: { type: 'string' } } },
          { type: 'object', properties: { b: { type: 'number' } } },
        ],
      }

      const result = adaptMcpSchemaToZod(allOfSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schemas with anyOf', () => {
      const anyOfSchema = {
        anyOf: [{ type: 'string' }, { type: 'number' }, { type: 'boolean' }],
      }

      const result = adaptMcpSchemaToZod(anyOfSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schemas with oneOf', () => {
      const oneOfSchema = {
        oneOf: [
          { type: 'string', enum: ['a', 'b'] },
          { type: 'number', minimum: 0 },
        ],
      }

      const result = adaptMcpSchemaToZod(oneOfSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })
  })

  describe('Edge Cases', () => {
    test('should handle functions as schemas (unusual but possible)', () => {
      const functionSchema = () => ({ type: 'string' })

      const result = adaptMcpSchemaToZod(functionSchema as any)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle Date objects', () => {
      const dateSchema = new Date()

      const result = adaptMcpSchemaToZod(dateSchema as any)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle Buffer objects', () => {
      const bufferSchema = Buffer.from('test')

      const result = adaptMcpSchemaToZod(bufferSchema as any)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schema with null properties', () => {
      const nullPropsSchema = {
        type: 'object',
        properties: {
          validField: { type: 'string' },
          nullField: null,
          undefinedField: undefined,
        },
      }

      const result = adaptMcpSchemaToZod(nullPropsSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle schema with getter/setter', () => {
      const accessorSchema: any = {
        type: 'object',
        get dynamicField() {
          return 'string'
        },
        set dynamicField(_value) {
          // noop
        },
      }

      const result = adaptMcpSchemaToZod(accessorSchema)

      expect(result).toBeInstanceOf(z.ZodType)
    })
  })
})
