// Integration tests for MCP tools
// generated by polka.codes

import { describe, expect, test } from 'bun:test'
import { z } from 'zod'
import { adaptMcpSchemaToZod, createMcpTools, getMcpToolNames } from './tools'

describe('MCP Tools - Integration Tests', () => {
  describe('adaptMcpSchemaToZod', () => {
    test('should handle Zod schemas correctly', () => {
      const zodSchema = z.object({
        name: z.string(),
        age: z.number().optional(),
      })

      const result = adaptMcpSchemaToZod(zodSchema)

      // Should return the same Zod schema
      expect(result).toBe(zodSchema)
    })

    test('should handle JSON Schema objects', () => {
      const jsonSchema = {
        type: 'object' as const,
        properties: {
          name: { type: 'string' },
          age: { type: 'number' },
        },
        required: ['name'],
      }

      const result = adaptMcpSchemaToZod(jsonSchema)

      // Should return a valid Zod schema
      expect(result).toBeInstanceOf(z.ZodType)
    })

    test('should handle plain Record objects', () => {
      const plainRecord = {
        foo: 'bar',
        baz: 123,
      }

      const result = adaptMcpSchemaToZod(plainRecord)

      // Should return a flexible Zod schema
      expect(result).toBeInstanceOf(z.ZodType)

      // Should validate various inputs
      const validResult = result.safeParse({ key: 'value' })
      expect(validResult.success).toBe(true)
    })

    test('should handle null and undefined', () => {
      const nullResult = adaptMcpSchemaToZod(null)
      expect(nullResult).toBeInstanceOf(z.ZodType)

      const undefinedResult = adaptMcpSchemaToZod(undefined)
      expect(undefinedResult).toBeInstanceOf(z.ZodType)
    })

    test('should handle primitive values', () => {
      const stringResult = adaptMcpSchemaToZod('string')
      expect(stringResult).toBeInstanceOf(z.ZodType)

      const numberResult = adaptMcpSchemaToZod(123)
      expect(numberResult).toBeInstanceOf(z.ZodType)
    })
  })

  describe('createMcpTools', () => {
    test('should create empty tool set when no tools available', () => {
      const mockManager = {
        getAllTools: () => new Map(),
      } as any

      const result = createMcpTools(mockManager)

      expect(result).toEqual({})
    })

    test('should create tools with Zod schemas', () => {
      const zodSchema = z.object({
        input: z.string(),
      })

      const mockManager = {
        getAllTools: () =>
          new Map([
            [
              'test-server/test-tool',
              {
                tool: {
                  name: 'test-tool',
                  description: 'A test tool',
                  inputSchema: zodSchema,
                },
              },
            ],
          ]),
      } as any

      const result = createMcpTools(mockManager)

      expect(result['test-server/test-tool']).toBeDefined()
      expect(result['test-server/test-tool'].description).toBe('A test tool')
      expect(result['test-server/test-tool'].inputSchema).toBe(zodSchema)
    })

    test('should create tools with JSON Schema objects', () => {
      const jsonSchema = {
        type: 'object' as const,
        properties: {
          input: { type: 'string' },
        },
      }

      const mockManager = {
        getAllTools: () =>
          new Map([
            [
              'test-server/json-tool',
              {
                tool: {
                  name: 'json-tool',
                  description: 'A JSON schema tool',
                  inputSchema: jsonSchema,
                },
              },
            ],
          ]),
      } as any

      const result = createMcpTools(mockManager)

      expect(result['test-server/json-tool']).toBeDefined()
      expect(result['test-server/json-tool'].description).toBe('A JSON schema tool')
      expect(result['test-server/json-tool'].inputSchema).toBeInstanceOf(z.ZodType)
    })

    test('should use default description when none provided', () => {
      const mockManager = {
        getAllTools: () =>
          new Map([
            [
              'test-server/no-desc-tool',
              {
                tool: {
                  name: 'no-desc-tool',
                  description: '',
                  inputSchema: z.object({}),
                },
              },
            ],
          ]),
      } as any

      const result = createMcpTools(mockManager)

      expect(result['test-server/no-desc-tool'].description).toBe('MCP tool: no-desc-tool')
    })

    test('should execute tools through manager', async () => {
      let capturedToolName: string | undefined
      const mockCallTool = async (toolName: string, _args: Record<string, unknown>) => {
        capturedToolName = toolName
        return { result: 'success' }
      }

      const mockManager = {
        getAllTools: () =>
          new Map([
            [
              'test-server/executable-tool',
              {
                tool: {
                  name: 'executable-tool',
                  description: 'An executable tool',
                  inputSchema: z.object({ input: z.string() }),
                },
              },
            ],
          ]),
        callTool: mockCallTool,
      } as any

      const result = createMcpTools(mockManager)
      const tool = result['test-server/executable-tool']

      expect(tool).toBeDefined()
      expect(tool).toHaveProperty('execute')

      // Call execute and verify it calls the manager
      const execute = tool.execute as (args: Record<string, unknown>) => Promise<unknown>
      const toolResult = await execute({ input: 'test' })

      expect(capturedToolName).toBe('test-server/executable-tool')
      expect(toolResult).toEqual({ result: 'success' })
    })
  })

  describe('getMcpToolNames', () => {
    test('should return all tool names when no server specified', () => {
      const mockManager = {
        getAllTools: () =>
          new Map([
            ['server1/tool1', { tool: { name: 'tool1' } }],
            ['server1/tool2', { tool: { name: 'tool2' } }],
            ['server2/tool3', { tool: { name: 'tool3' } }],
          ]),
      } as any

      const result = getMcpToolNames(mockManager)

      expect(result).toEqual(['server1/tool1', 'server1/tool2', 'server2/tool3'])
    })

    test('should return server-specific tools when server specified', () => {
      const mockManager = {
        getServerTools: (serverName: string) => {
          if (serverName === 'server1') {
            return new Map([
              ['tool1', { tool: { name: 'tool1' } }],
              ['tool2', { tool: { name: 'tool2' } }],
            ])
          }
          return new Map()
        },
      } as any

      const result = getMcpToolNames(mockManager, 'server1')

      expect(result).toEqual(['tool1', 'tool2'])
    })

    test('should return empty array for non-existent server', () => {
      const mockManager = {
        getServerTools: () => new Map(),
      } as any

      const result = getMcpToolNames(mockManager, 'non-existent')

      expect(result).toEqual([])
    })
  })
})
