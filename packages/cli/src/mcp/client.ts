// generated by polka.codes

import { McpConnectionError, McpProtocolError, McpTimeoutError, McpToolError } from './errors'
import { StdioTransport } from './transport'
import type { IMcpClient, McpResource, McpTool, McpToolResult } from './types'

/**
 * MCP Client implementation
 */
export class McpClient implements IMcpClient {
  private transport: StdioTransport | null = null
  private initialized = false

  constructor(
    private readonly serverName: string,
    private readonly config: { command: string; args?: string[]; env?: Record<string, string> },
  ) {}

  /**
   * Connect to the MCP server and initialize
   */
  async connect(): Promise<void> {
    if (!this.config.command) {
      throw new McpConnectionError(this.serverName, new Error('No command specified for MCP server'))
    }

    try {
      // Create and start the transport
      this.transport = new StdioTransport(this.config)
      await this.transport.start()

      // Initialize the MCP session
      await this.sendRequest('initialize', {
        protocolVersion: '2024-11-05',
        capabilities: {},
        clientInfo: {
          name: 'polka-codes',
          version: '1.0.0',
        },
      })

      // Send initialized notification
      this.transport.sendNotification('notifications/initialized')

      this.initialized = true
    } catch (error) {
      this.transport = null
      this.initialized = false

      if (error instanceof Error) {
        if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {
          throw new McpTimeoutError(this.serverName, 30)
        }
        throw new McpConnectionError(this.serverName, error)
      }
      throw new McpConnectionError(this.serverName, new Error(String(error)))
    }
  }

  /**
   * Disconnect from the MCP server
   */
  async disconnect(): Promise<void> {
    if (this.transport) {
      await this.transport.stop()
      this.transport = null
      this.initialized = false
    }
  }

  /**
   * List available tools from the server
   */
  async listTools(): Promise<McpTool[]> {
    this.ensureConnected()

    try {
      const response = await this.sendRequest('tools/list')

      if (!response || typeof response !== 'object') {
        throw new McpProtocolError(this.serverName, 'Invalid response from tools/list')
      }

      const result = response as { tools?: unknown[] }

      if (!result.tools || !Array.isArray(result.tools)) {
        throw new McpProtocolError(this.serverName, 'tools/list did not return an array')
      }

      return result.tools as McpTool[]
    } catch (error) {
      if (error instanceof McpProtocolError) {
        throw error
      }
      throw new McpProtocolError(this.serverName, `Failed to list tools: ${error}`)
    }
  }

  /**
   * Call a tool on the server
   */
  async callTool(name: string, args: Record<string, unknown>): Promise<McpToolResult> {
    this.ensureConnected()

    try {
      const response = await this.sendRequest('tools/call', {
        name,
        arguments: args,
      })

      if (!response || typeof response !== 'object') {
        throw new McpToolError(this.serverName, name, 'Invalid response from tool call')
      }

      return response as McpToolResult
    } catch (error) {
      if (error instanceof McpToolError) {
        throw error
      }
      throw new McpToolError(this.serverName, name, `Tool call failed: ${error}`, error instanceof Error ? error : undefined)
    }
  }

  /**
   * List available resources from the server
   */
  async listResources(): Promise<McpResource[]> {
    this.ensureConnected()

    try {
      const response = await this.sendRequest('resources/list')

      if (!response || typeof response !== 'object') {
        throw new McpProtocolError(this.serverName, 'Invalid response from resources/list')
      }

      const result = response as { resources?: unknown[] }

      if (!result.resources || !Array.isArray(result.resources)) {
        throw new McpProtocolError(this.serverName, 'resources/list did not return an array')
      }

      return result.resources as McpResource[]
    } catch (error) {
      if (error instanceof McpProtocolError) {
        throw error
      }
      throw new McpProtocolError(this.serverName, `Failed to list resources: ${error}`)
    }
  }

  /**
   * Read a resource from the server
   */
  async readResource(uri: string): Promise<string> {
    this.ensureConnected()

    try {
      const response = await this.sendRequest('resources/read', {
        uri,
      })

      if (!response || typeof response !== 'object') {
        throw new McpProtocolError(this.serverName, 'Invalid response from resources/read')
      }

      const result = response as { contents?: Array<{ text?: string; blob?: string }> }

      if (!result.contents || !Array.isArray(result.contents) || result.contents.length === 0) {
        throw new McpProtocolError(this.serverName, 'resources/read did not return any content')
      }

      // Check for binary content (blob)
      const hasBinaryContent = result.contents.some((c) => c.blob !== undefined)
      if (hasBinaryContent) {
        throw new McpProtocolError(
          this.serverName,
          'Binary resources (blob) are not currently supported. Only text resources are supported.',
        )
      }

      // Concatenate all text content
      return result.contents.map((c) => c.text || '').join('\n')
    } catch (error) {
      if (error instanceof McpProtocolError) {
        throw error
      }
      throw new McpProtocolError(this.serverName, `Failed to read resource: ${error}`)
    }
  }

  /**
   * Ensure the client is connected
   */
  private ensureConnected(): void {
    if (!this.initialized || !this.transport?.isRunning()) {
      throw new McpConnectionError(this.serverName)
    }
  }

  /**
   * Send a request to the MCP server
   */
  private async sendRequest(method: string, params?: unknown): Promise<unknown> {
    if (!this.transport) {
      throw new McpConnectionError(this.serverName)
    }

    return this.transport.sendRequest(method, params)
  }
}

/**
 * Factory function to create an MCP client
 */
export async function createMcpClient(
  serverName: string,
  config: { command: string; args?: string[]; env?: Record<string, string> },
): Promise<IMcpClient> {
  const client = new McpClient(serverName, config)
  await client.connect()
  return client
}
