/**
 * Tests for searchFiles utility
 * Generated by polka.codes
 */
import { afterAll, beforeAll, describe, expect, it, spyOn } from 'bun:test'
import * as child_process from 'node:child_process'
import { EventEmitter } from 'node:events'
import { promises as fs } from 'node:fs'
import { join } from 'node:path'
import { searchFiles } from './searchFiles'

describe('searchFiles with mocks', () => {
  it('should execute ripgrep with correct arguments', async () => {
    const mockSpawn = spyOn(child_process, 'spawn')

    // Create mock process
    const mockProcess = new EventEmitter() as any
    mockProcess.stdout = new EventEmitter()
    mockProcess.stderr = new EventEmitter()
    mockSpawn.mockImplementation(() => mockProcess)

    // Start search
    const searchPromise = searchFiles('src', 'test', '*.ts', '/test/path')

    // Verify arguments
    expect(mockSpawn).toHaveBeenCalled()
    const args = mockSpawn.mock.calls[0][1]
    expect(args).toContain('--line-number')
    expect(args).toContain('--context=5')
    expect(args).toContain('--glob')
    expect(args).toContain('*.ts')
    expect(args).toContain('test')
    expect(args).toContain('src')

    // Simulate successful search
    mockProcess.stdout.emit('data', 'file1.ts:10:test match\n')
    mockProcess.emit('close', 0)

    const results = await searchPromise
    expect(results).toEqual(['file1.ts:10:test match'])
  })

  describe('searchFiles with real files', () => {
    const testDir = join(__dirname, 'search-test-fixtures')

    // Create files with searchable content
    beforeAll(async () => {
      // Create test directory structure
      await fs.mkdir(testDir, { recursive: true })

      // Create files with searchable content
      await fs.writeFile(join(testDir, 'file1.txt'), 'This file contains SEARCHABLE text')
      await fs.writeFile(join(testDir, 'file2.txt'), 'Another file with SEARCHABLE content')
      await fs.writeFile(join(testDir, 'excluded.txt'), 'This file has SEARCHABLE content but should be excluded')

      // Create subdirectory
      const subDir = join(testDir, 'subdir')
      await fs.mkdir(subDir, { recursive: true })
      await fs.writeFile(join(subDir, 'file3.txt'), 'Subdirectory file with SEARCHABLE content')
      await fs.writeFile(join(subDir, 'excluded-too.txt'), 'Another SEARCHABLE file to exclude')
    })

    afterAll(async () => {
      // Clean up test directory
      await fs.rm(testDir, { recursive: true, force: true })
    })

    it('should find all files with searchable content when no exclusions specified', async () => {
      const results = await searchFiles(testDir, 'SEARCHABLE', '*.txt', testDir)

      // Should find all 5 files
      expect(results.length).toBeGreaterThan(0)

      // Check if all files are found
      const fileMatches = results.join('\n')
      expect(fileMatches).toContain('file1.txt')
      expect(fileMatches).toContain('file2.txt')
      expect(fileMatches).toContain('excluded.txt')
      expect(fileMatches).toContain('subdir/file3.txt')
      expect(fileMatches).toContain('subdir/excluded-too.txt')
    })

    it('should exclude files specified in excludeFiles parameter', async () => {
      const results = await searchFiles(testDir, 'SEARCHABLE', '*.txt', testDir, ['excluded.txt', 'subdir/excluded-too.txt'])

      // Should still find matches
      expect(results.length).toBeGreaterThan(0)

      // Check if excluded files are not in results
      const fileMatches = results.join('\n')
      expect(fileMatches).toContain('file1.txt')
      expect(fileMatches).toContain('file2.txt')
      expect(fileMatches).toContain('subdir/file3.txt')

      // Excluded files should not be found
      expect(fileMatches).not.toContain('excluded.txt:')
      expect(fileMatches).not.toContain('subdir/excluded-too.txt:')
    })

    it('should exclude files using glob patterns', async () => {
      const results = await searchFiles(
        testDir,
        'SEARCHABLE',
        '*.txt',
        testDir,
        ['**/excluded*.txt'], // Exclude all files starting with 'excluded'
      )

      // Should still find matches
      expect(results.length).toBeGreaterThan(0)

      // Check if excluded files are not in results
      const fileMatches = results.join('\n')
      expect(fileMatches).toContain('file1.txt')
      expect(fileMatches).toContain('file2.txt')
      expect(fileMatches).toContain('subdir/file3.txt')

      // Excluded files should not be found
      expect(fileMatches).not.toContain('excluded.txt:')
      expect(fileMatches).not.toContain('subdir/excluded-too.txt:')
    })

    it('should exclude entire directories', async () => {
      const results = await searchFiles(
        testDir,
        'SEARCHABLE',
        '*.txt',
        testDir,
        ['subdir'], // Exclude the entire subdirectory
      )

      // Should still find matches
      expect(results.length).toBeGreaterThan(0)

      // Check if excluded directory files are not in results
      const fileMatches = results.join('\n')
      expect(fileMatches).toContain('file1.txt')
      expect(fileMatches).toContain('file2.txt')
      expect(fileMatches).toContain('excluded.txt')

      // Files in excluded directory should not be found
      expect(fileMatches).not.toContain('subdir/file3.txt')
      expect(fileMatches).not.toContain('subdir/excluded-too.txt')
    })
  })

  it('should handle no matches gracefully', async () => {
    const mockSpawn = spyOn(child_process, 'spawn')

    const mockProcess = new EventEmitter() as any
    mockProcess.stdout = new EventEmitter()
    mockProcess.stderr = new EventEmitter()
    mockSpawn.mockImplementation(() => mockProcess)

    const searchPromise = searchFiles('src', 'nonexistent', '*.ts', '/test/path')

    mockProcess.emit('close', 1) // Exit code 1 means no matches

    const results = await searchPromise
    expect(results).toEqual([])
  })

  it('should handle errors', async () => {
    const mockSpawn = spyOn(child_process, 'spawn')

    const mockProcess = new EventEmitter() as any
    mockProcess.stdout = new EventEmitter()
    mockProcess.stderr = new EventEmitter()
    mockSpawn.mockImplementation(() => mockProcess)

    const searchPromise = searchFiles('src', 'test', '*.ts', '/test/path')

    mockProcess.emit('error', new Error('Test error'))

    await expect(searchPromise).rejects.toThrow('Failed to execute ripgrep')
  })
})
