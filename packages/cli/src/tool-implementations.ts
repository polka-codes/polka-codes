// generated by polka.codes
import { spawn, spawnSync } from 'node:child_process'
import fs, { mkdir } from 'node:fs/promises'
import { dirname } from 'node:path'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { confirm as inquirerConfirm, select as inquirerSelect } from '@inquirer/prompts'
import type {
  MemoryProvider,
  TodoItem,
  TodoProvider,
  ToolResponse,
  UpdateTodoItemInput,
  UpdateTodoItemOutput,
  UsageMeter,
} from '@polka-codes/core'
import {
  askFollowupQuestion,
  computeRateLimitBackoffSeconds,
  executeCommand as executeCommandTool,
  fetchUrl,
  fromJsonModelMessage,
  getTodoItem as getTodoItemTool,
  type JsonModelMessage,
  listFiles as listFilesTool,
  listMemoryTopics as listMemoryTopicsTool,
  listTodoItems as listTodoItemsTool,
  readBinaryFile,
  readFile as readFileTool,
  readMemory as readMemoryTool,
  removeFile,
  renameFile,
  replaceInFile,
  search,
  searchFiles,
  type TaskEvent,
  type TaskEventCallback,
  TaskEventKind,
  type ToolRegistry,
  ToolResponseType,
  updateMemory as updateMemoryTool,
  updateTodoItem as updateTodoItemTool,
  writeToFile as writeToFileTool,
} from '@polka-codes/core'
import { streamText, type ToolSet } from 'ai'

import type { Command } from 'commander'

import { UserCancelledError } from './errors'

export type AgentContextParameters = {
  providerOptions?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter: UsageMeter
}

import { gitDiff } from './tools'
import { applyCacheControl } from './utils/cacheControl'
import { getUserInput } from './utils/userInput'
import type { CliToolRegistry } from './workflow-tools'
import { getLocalChanges } from './workflows/workflow.utils'

const allTools = [
  askFollowupQuestion,
  executeCommandTool,
  fetchUrl,
  listFilesTool,
  readBinaryFile,
  readFileTool,
  readMemoryTool,
  listMemoryTopicsTool,
  updateMemoryTool,
  removeFile,
  renameFile,
  replaceInFile,
  search,
  searchFiles,
  writeToFileTool,
  gitDiff,
  getTodoItemTool,
  listTodoItemsTool,
  updateTodoItemTool,
] as const
const toolHandlers = new Map(allTools.map((t) => [t.name, t]))

type ToolCall<TTools extends ToolRegistry> = {
  [K in keyof TTools]: {
    tool: K
    input: TTools[K]['input']
  }
}[keyof TTools]

type ToolCallContext = {
  parameters: AgentContextParameters
  model: LanguageModelV2
  agentCallback?: TaskEventCallback
  toolProvider: any // ToolProvider
  command: Command
  yes?: boolean
}

async function createPullRequest(input: { title: string; description: string }, _context: ToolCallContext) {
  spawnSync('gh', ['pr', 'create', '--title', input.title, '--body', input.description], {
    stdio: 'inherit',
  })
  return { title: input.title, description: input.description }
}

async function createCommit(input: { message: string }, _context: ToolCallContext) {
  const result = spawnSync('git', ['commit', '-m', input.message], {
    stdio: 'inherit',
  })
  if (result.status !== 0) {
    throw new Error('Commit failed')
  }
  return { message: input.message }
}

async function printChangeFile(_input: unknown, _context: ToolCallContext) {
  const { stagedFiles, unstagedFiles } = getLocalChanges()
  if (stagedFiles.length === 0 && unstagedFiles.length === 0) {
    console.log('No changes to commit.')
  } else {
    if (stagedFiles.length > 0) {
      console.log('Staged files:')
      for (const file of stagedFiles) {
        console.log(`- ${file.status}: ${file.path}`)
      }
    }
    if (unstagedFiles.length > 0) {
      console.log('\nUnstaged files:')
      for (const file of unstagedFiles) {
        console.log(`- ${file.status}: ${file.path}`)
      }
    }
  }
  return { stagedFiles, unstagedFiles }
}

async function confirm(input: { message: string }, context: ToolCallContext) {
  if (context.yes) {
    return true
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  try {
    process.stderr.write('\u0007')
    const result = await inquirerConfirm({ message: input.message })
    return result
  } catch (_e) {
    throw new UserCancelledError()
  }
}

async function input(input: { message: string; default: string }, context: ToolCallContext) {
  if (context.yes) {
    return input.default ?? ''
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  process.stderr.write('\u0007')
  const result = await getUserInput(input.message, {
    default: input.default,
  })

  if (result === undefined) {
    throw new UserCancelledError()
  }
  return result
}

async function select(input: { message: string; choices: { name: string; value: string }[] }, context: ToolCallContext) {
  if (context.yes) {
    return input.choices[0].value
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  try {
    process.stderr.write('\u0007')
    const result = await inquirerSelect({ message: input.message, choices: input.choices })
    return result
  } catch (_e) {
    throw new UserCancelledError()
  }
}

async function writeToFile(input: { path: string; content: string }) {
  // generate parent directories if they don't exist
  await mkdir(dirname(input.path), { recursive: true })
  await fs.writeFile(input.path, input.content)
  return {}
}

async function readFile(input: { path: string }) {
  try {
    const content = await fs.readFile(input.path, 'utf8')
    return content
  } catch {
    // return null if file doesn't exist or can't be read
  }
  return null
}

async function executeCommand(input: { command: string; shell?: boolean; pipe?: boolean; args?: string[] }) {
  return new Promise((resolve, reject) => {
    const child =
      input.shell === true
        ? spawn(input.command, { shell: true, stdio: 'pipe' })
        : spawn(input.command, input.args, {
            shell: false,
            stdio: 'pipe',
          })

    let stdout = ''
    let stderr = ''
    let stdoutEnded = !child.stdout
    let stderrEnded = !child.stderr
    let closeEventFired = false
    let exitCode: number | null = null

    const checkAndResolve = () => {
      if (stdoutEnded && stderrEnded && closeEventFired) {
        resolve({ exitCode: exitCode ?? -1, stdout, stderr })
      }
    }

    if (child.stdout) {
      child.stdout.setEncoding('utf8')
      child.stdout.on('data', (data: string) => {
        if (input.pipe) {
          process.stdout.write(data)
        }
        stdout += data
      })
      child.stdout.on('end', () => {
        stdoutEnded = true
        checkAndResolve()
      })
    }

    if (child.stderr) {
      child.stderr.setEncoding('utf8')
      child.stderr.on('data', (data: string) => {
        if (input.pipe) {
          process.stderr.write(data)
        }
        stderr += data
      })
      child.stderr.on('end', () => {
        stderrEnded = true
        checkAndResolve()
      })
    }

    child.on('close', (code: number | null) => {
      exitCode = code
      closeEventFired = true
      checkAndResolve()
    })

    child.on('error', (err: Error) => {
      reject(err)
    })
  })
}

async function generateText(input: { messages: JsonModelMessage[]; tools: ToolSet }, context: ToolCallContext) {
  const { model, agentCallback } = context
  if (!model) {
    throw new Error('Model not found in context')
  }

  if (context.parameters.usageMeter.isLimitExceeded().result) {
    agentCallback?.({
      kind: TaskEventKind.UsageExceeded,
    })
    throw new Error('Usage limit exceeded')
  }

  const { retryCount = 5, requestTimeoutSeconds = 90 } = context.parameters

  // Convert messages and apply cache control
  const messages = applyCacheControl(input.messages.map(fromJsonModelMessage), model.provider, model.modelId)

  for (let i = 0; i < retryCount; i++) {
    const abortController = new AbortController()
    let timeout = setTimeout(() => abortController.abort(), requestTimeoutSeconds * 1000)

    const lastOutputs: string[] = []
    let repetitionDetected = false

    const usageMeterOnFinishHandler = context.parameters.usageMeter.onFinishHandler(model)

    try {
      const stream = streamText({
        model,
        temperature: 0,
        messages,
        tools: input.tools,
        async onChunk({ chunk }) {
          clearTimeout(timeout)
          timeout = setTimeout(() => abortController.abort(), requestTimeoutSeconds * 1000)
          switch (chunk.type) {
            case 'text-delta':
              lastOutputs.push(chunk.text)
              if (lastOutputs.length > 20) {
                lastOutputs.shift()
              }
              if (lastOutputs.length === 20) {
                const firstHalf = lastOutputs.slice(0, 10).join('')
                const secondHalf = lastOutputs.slice(10).join('')
                if (firstHalf === secondHalf) {
                  if (firstHalf.length > 20) {
                    repetitionDetected = true
                    abortController.abort()
                  }
                }
              }
              agentCallback?.({
                kind: TaskEventKind.Text,
                newText: chunk.text,
              })
              break
            case 'reasoning-delta':
              agentCallback?.({
                kind: TaskEventKind.Reasoning,
                newText: chunk.text,
              })
              break
          }
        },
        onFinish(result) {
          usageMeterOnFinishHandler?.(result)
        },
        providerOptions: context.parameters.providerOptions,
        abortSignal: abortController.signal,
      })

      await stream.consumeStream({
        onError: (error) => {
          console.error('Error in stream:', error)
        },
      })

      const resp = await stream.response
      return resp.messages
    } catch (error: any) {
      if (error.name === 'AbortError') {
        if (repetitionDetected) {
          console.warn('Repetition detected, retrying...')
          continue
        }
        // This is a timeout
        console.warn(`Request timed out after ${requestTimeoutSeconds} seconds, retrying...`)
        continue
      }
      if ('response' in error) {
        const response: Response = error.response
        if (response.status === 429) {
          const backoff = computeRateLimitBackoffSeconds(i)
          await new Promise((resolve) => setTimeout(resolve, backoff * 1000))
          continue
        }
      }
      throw error
    } finally {
      clearTimeout(timeout)
    }
  }
  throw new Error(`Failed to get a response from the model after ${retryCount} retries.`)
}

async function invokeTool(input: { toolName: string; input: any }, context: ToolCallContext): Promise<ToolResponse> {
  const tool = toolHandlers.get(input.toolName as any)
  if (!tool) {
    return {
      type: ToolResponseType.Error,
      message: {
        type: 'error-text',
        value: `Tool not found: ${input.toolName}`,
      },
    }
  }
  try {
    const result = await tool.handler(context.toolProvider, input.input)
    return result
  } catch (error: any) {
    return {
      type: ToolResponseType.Error,
      message: {
        type: 'error-text',
        value: error?.message ?? `${error}`,
      },
    }
  }
}

async function taskEvent(input: TaskEvent, context: ToolCallContext) {
  await context.agentCallback?.(input)
}

async function getMemoryContext(_input: unknown, context: ToolCallContext) {
  const provider: MemoryProvider = context.toolProvider
  const topics = await provider.listMemoryTopics()
  const defaultContent = await provider.readMemory()

  const contextParts: string[] = []

  if (topics?.length > 0) {
    const topicList = topics.map((topic: string) => `- ${topic}`).join('\n')
    contextParts.push(`<memory_topics>\n${topicList}\n</memory_topics>`)
  }

  if (defaultContent) {
    contextParts.push(`<memory topic=":default:">\n${defaultContent}\n</memory>`)
  }

  return contextParts.join('\n')
}

async function readMemory(input: { topic?: string }, context: ToolCallContext): Promise<string> {
  const provider: MemoryProvider = context.toolProvider
  return (await provider.readMemory(input.topic)) ?? ''
}

async function listMemoryTopics(_input: unknown, context: ToolCallContext): Promise<string[]> {
  const provider: MemoryProvider = context.toolProvider
  return provider.listMemoryTopics()
}

async function updateMemory(
  input:
    | { operation: 'append'; topic?: string; content: string }
    | { operation: 'replace'; topic?: string; content: string }
    | { operation: 'remove'; topic?: string },
  context: ToolCallContext,
) {
  const provider: MemoryProvider = context.toolProvider
  const content = 'content' in input ? input.content : undefined
  return provider.updateMemory(input.operation, input.topic, content)
}

async function listTodoItems(
  input: { id?: string | null; status?: 'open' | 'completed' | 'closed' | null },
  context: ToolCallContext,
): Promise<TodoItem[]> {
  const provider: TodoProvider = context.toolProvider
  return provider.listTodoItems(input.id, input.status)
}

async function getTodoItem(input: { id: string }, context: ToolCallContext): Promise<TodoItem | undefined> {
  const provider: TodoProvider = context.toolProvider
  return provider.getTodoItem(input.id)
}

async function updateTodoItem(input: UpdateTodoItemInput, context: ToolCallContext): Promise<UpdateTodoItemOutput> {
  const provider: TodoProvider = context.toolProvider
  return provider.updateTodoItem(input)
}

const localToolHandlers = {
  createPullRequest,
  createCommit,
  printChangeFile,
  confirm,
  input,
  select,
  writeToFile,
  readFile,
  executeCommand,
  generateText,
  invokeTool,
  taskEvent,
  getMemoryContext,
  readMemory,
  listMemoryTopics,
  updateMemory,
  listTodoItems,
  getTodoItem,
  updateTodoItem,
}

export async function toolCall(toolCall: ToolCall<CliToolRegistry>, context: ToolCallContext) {
  const handler = localToolHandlers[toolCall.tool]
  if (handler) {
    return handler(toolCall.input as any, context)
  }
  throw new Error(`Unknown tool: ${(toolCall as any).tool}`)
}
