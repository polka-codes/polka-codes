// generated by polka.codes
import { spawn, spawnSync } from 'node:child_process'
import fs, { mkdir } from 'node:fs/promises'
import { dirname } from 'node:path'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { confirm as inquirerConfirm, input as inquirerInput, select as inquirerSelect } from '@inquirer/prompts'
import { readMultiline } from '@polka-codes/cli-shared'
import type { AgentPolicy, TaskEvent, TaskEventCallback, ToolFormat, UsageMeter } from '@polka-codes/core'
import {
  type AgentNameType,
  askFollowupQuestion,
  computeRateLimitBackoffSeconds,
  executeCommand as executeCommandTool,
  fetchUrl,
  listFiles as listFilesTool,
  readBinaryFile,
  readFile as readFileTool,
  removeFile,
  renameFile,
  replaceInFile,
  searchFiles,
  TaskEventKind,
  ToolResponseType,
  writeToFile as writeToFileTool,
} from '@polka-codes/core'
import { fromJsonModelMessage, type JsonModelMessage, type ToolRegistry } from '@polka-codes/workflow'
import { streamText, type ToolSet } from 'ai'
import chalk from 'chalk'
import type { Command } from 'commander'

import type { ApiProviderConfig } from './ApiProviderConfig'
import { UserCancelledError } from './errors'

export type AgentContextParameters = {
  toolFormat?: ToolFormat
  os?: string
  policies?: AgentPolicy[]
  modelParameters?: Record<string, any>
  providerOptions?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter?: UsageMeter
}

import { camelCase } from 'lodash-es'
import { gitDiff } from './tools'
import type { CliToolRegistry } from './workflow-tools'
import { getLocalChanges } from './workflows/workflow.utils'

const allTools = [
  askFollowupQuestion,
  executeCommandTool,
  fetchUrl,
  listFilesTool,
  readBinaryFile,
  readFileTool,
  removeFile,
  renameFile,
  replaceInFile,
  searchFiles,
  writeToFileTool,
  gitDiff,
] as const
const toolHandlers = new Map(allTools.map((t) => [camelCase(t.name), t]))

type ToolCall<TTools extends ToolRegistry> = {
  [K in keyof TTools]: {
    tool: K
    input: TTools[K]['input']
  }
}[keyof TTools]

type ToolCallContext = {
  providerConfig: ApiProviderConfig
  parameters: AgentContextParameters
  getModel: (name: AgentNameType) => Promise<LanguageModelV2>
  model?: LanguageModelV2
  agentCallback?: TaskEventCallback
  toolProvider: any // ToolProvider
  command: Command
  yes?: boolean
}

async function createPullRequest(input: { title: string; description: string }, _context: ToolCallContext) {
  spawnSync('gh', ['pr', 'create', '--title', input.title, '--body', input.description], {
    stdio: 'inherit',
  })
  return { title: input.title, description: input.description }
}

async function createCommit(input: { message: string }, _context: ToolCallContext) {
  const result = spawnSync('git', ['commit', '-m', input.message], {
    stdio: 'inherit',
  })
  if (result.status !== 0) {
    throw new Error('Commit failed')
  }
  return { message: input.message }
}

async function printChangeFile(_input: unknown, _context: ToolCallContext) {
  const { stagedFiles, unstagedFiles } = getLocalChanges()
  if (stagedFiles.length === 0 && unstagedFiles.length === 0) {
    console.log('No changes to commit.')
  } else {
    if (stagedFiles.length > 0) {
      console.log('Staged files:')
      for (const file of stagedFiles) {
        console.log(`- ${file.status}: ${file.path}`)
      }
    }
    if (unstagedFiles.length > 0) {
      console.log('\nUnstaged files:')
      for (const file of unstagedFiles) {
        console.log(`- ${file.status}: ${file.path}`)
      }
    }
  }
  return { stagedFiles, unstagedFiles }
}

async function confirm(input: { message: string }, context: ToolCallContext) {
  if (context.yes) {
    return true
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  try {
    const result = await inquirerConfirm({ message: input.message })
    return result
  } catch (_e) {
    throw new UserCancelledError()
  }
}

async function input(input: { message: string; default: string }, context: ToolCallContext) {
  if (context.yes) {
    return input.default ?? ''
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  try {
    let result = await inquirerInput({
      message: `${input.message}${chalk.gray(' (type .m for multiline)')}`,
      default: input.default,
    })
    if (result === '.m') {
      result = await readMultiline('Enter multiline text (Ctrl+D to finish):')
    }
    return result
  } catch (_e) {
    throw new UserCancelledError()
  }
}

async function select(input: { message: string; choices: { name: string; value: string }[] }, context: ToolCallContext) {
  if (context.yes) {
    return input.choices[0].value
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  try {
    const result = await inquirerSelect({ message: input.message, choices: input.choices })
    return result
  } catch (_e) {
    throw new UserCancelledError()
  }
}

async function writeToFile(input: { path: string; content: string }) {
  // generate parent directories if they don't exist
  await mkdir(dirname(input.path), { recursive: true })
  await fs.writeFile(input.path, input.content)
  return {}
}

async function readFile(input: { path: string }) {
  try {
    const content = await fs.readFile(input.path, 'utf8')
    return content
  } catch {
    // return null if file doesn't exist or can't be read
  }
  return null
}

async function executeCommand(input: { command: string; shell?: boolean; pipe?: boolean; args?: string[] }) {
  return new Promise((resolve, reject) => {
    const child =
      input.shell === true
        ? spawn(input.command, { shell: true, stdio: 'pipe' })
        : spawn(input.command, input.args, {
            shell: false,
            stdio: 'pipe',
          })

    let stdout = ''
    let stderr = ''
    let stdoutEnded = !child.stdout
    let stderrEnded = !child.stderr
    let closeEventFired = false
    let exitCode: number | null = null

    const checkAndResolve = () => {
      if (stdoutEnded && stderrEnded && closeEventFired) {
        resolve({ exitCode: exitCode ?? -1, stdout, stderr })
      }
    }

    if (child.stdout) {
      child.stdout.setEncoding('utf8')
      child.stdout.on('data', (data: string) => {
        if (input.pipe) {
          process.stdout.write(data)
        }
        stdout += data
      })
      child.stdout.on('end', () => {
        stdoutEnded = true
        checkAndResolve()
      })
    }

    if (child.stderr) {
      child.stderr.setEncoding('utf8')
      child.stderr.on('data', (data: string) => {
        if (input.pipe) {
          process.stderr.write(data)
        }
        stderr += data
      })
      child.stderr.on('end', () => {
        stderrEnded = true
        checkAndResolve()
      })
    }

    child.on('close', (code: number | null) => {
      exitCode = code
      closeEventFired = true
      checkAndResolve()
    })

    child.on('error', (err: Error) => {
      reject(err)
    })
  })
}

async function generateText(input: { messages: JsonModelMessage[]; tools: ToolSet }, context: ToolCallContext) {
  const { model, agentCallback } = context
  if (!model) {
    throw new Error('Model not found in context')
  }

  const { retryCount = 5, requestTimeoutSeconds = 90 } = context.parameters

  for (let i = 0; i < retryCount; i++) {
    const abortController = new AbortController()
    const timeout = setTimeout(() => abortController.abort(), requestTimeoutSeconds * 1000)

    const usageMeterOnFinishHandler = context.parameters.usageMeter?.onFinishHandler(model)

    try {
      const stream = streamText({
        model,
        temperature: 0,
        messages: input.messages.map(fromJsonModelMessage),
        tools: input.tools,
        async onChunk({ chunk }) {
          switch (chunk.type) {
            case 'text-delta':
              agentCallback?.({
                kind: TaskEventKind.Text,
                newText: chunk.text,
              })
              break
            case 'reasoning-delta':
              agentCallback?.({
                kind: TaskEventKind.Reasoning,
                newText: chunk.text,
              })
              break
          }
        },
        onFinish(result) {
          usageMeterOnFinishHandler?.(result)
          agentCallback?.({
            kind: TaskEventKind.Usage,
            usage: result.usage,
          })
        },
        providerOptions: context.parameters.providerOptions,
        abortSignal: abortController.signal,
      })

      await stream.consumeStream({
        onError: (error) => {
          console.error('Error in stream:', error)
        },
      })

      const resp = await stream.response
      return resp.messages
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // This is a timeout
        continue
      }
      if ('response' in error) {
        const response: Response = error.response
        if (response.status === 429) {
          const backoff = computeRateLimitBackoffSeconds(i)
          await new Promise((resolve) => setTimeout(resolve, backoff * 1000))
          continue
        }
      }
      throw error
    } finally {
      clearTimeout(timeout)
    }
  }
  throw new Error(`Failed to get a response from the model after ${retryCount} retries.`)
}

async function invokeTool(input: { toolName: string; input: any }, context: ToolCallContext) {
  const tool = toolHandlers.get(input.toolName as any)
  if (!tool) {
    return {
      type: ToolResponseType.Error,
      error: `Tool not found: ${input.toolName}`,
    }
  }
  try {
    const result = await tool.handler(context.toolProvider, input.input)
    return result
  } catch (error: any) {
    return {
      type: ToolResponseType.Error,
      error: error.message,
    }
  }
}

async function taskEvent(input: TaskEvent, context: ToolCallContext) {
  await context.agentCallback?.(input)
}

const localToolHandlers = {
  createPullRequest,
  createCommit,
  printChangeFile,
  confirm,
  input,
  select,
  writeToFile,
  readFile,
  executeCommand,
  generateText,
  invokeTool,
  taskEvent,
}

export async function toolCall(toolCall: ToolCall<CliToolRegistry>, context: ToolCallContext) {
  const handler = localToolHandlers[toolCall.tool]
  if (handler) {
    return handler(toolCall.input as any, context)
  }
  throw new Error(`Unknown tool: ${(toolCall as any).tool}`)
}
