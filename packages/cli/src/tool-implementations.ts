// generated by polka.codes
import { spawn, spawnSync } from 'node:child_process'
import fs, { mkdir } from 'node:fs/promises'
import { dirname } from 'node:path'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { confirm as inquirerConfirm, select as inquirerSelect } from '@inquirer/prompts'
import type {
  AgentWorkflowInput,
  MemoryProvider,
  ScriptConfig,
  SkillContext,
  TodoItem,
  TodoProvider,
  ToolParameterValue,
  ToolResponse,
  UpdateTodoItemInput,
  UpdateTodoItemOutput,
  UsageMeter,
} from '@polka-codes/core'
import {
  agentWorkflow,
  askFollowupQuestion,
  computeRateLimitBackoffSeconds,
  listSkills as coreListSkills,
  loadSkill as coreLoadSkill,
  readSkillFile as coreReadSkillFile,
  executeCommand as executeCommandTool,
  type FullToolInfo,
  fetchUrl,
  fromJsonModelMessage,
  type JsonModelMessage,
  listFiles as listFilesTool,
  readBinaryFile,
  readFile as readFileTool,
  removeFile,
  renameFile,
  replaceInFile,
  SOURCE_ICONS,
  search,
  searchFiles,
  type TaskEvent,
  type TaskEventCallback,
  TaskEventKind,
  type ToolRegistry,
  toJsonModelMessage,
  writeToFile as writeToFileTool,
} from '@polka-codes/core'
import { streamText, type ToolSet } from 'ai'
import {
  createProviderErrorFromStatus,
  MaxRetriesExceededError,
  ProviderTimeoutError,
  QuotaExceededError,
  UserCancelledError,
} from './errors'
import { McpError } from './mcp/errors'
import type { McpManager } from './mcp/manager'
import { createSkillContext, generateSkillsSystemPrompt } from './skillIntegration'

export type AgentContextParameters = {
  providerOptions?: Record<string, any>
  scripts?: Record<string, ScriptConfig>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter: UsageMeter
  skillContext?: SkillContext
  mcpManager?: McpManager // MCP manager for MCP server connections
}

import {
  getTodoItem as getTodoItemTool,
  gitDiff,
  listMemoryTopics as listMemoryTopicsTool,
  listTodoItems as listTodoItemsTool,
  readMemory as readMemoryTool,
  updateMemory as updateMemoryTool,
  updateTodoItem as updateTodoItemTool,
} from './tools'
import { applyCacheControl } from './utils/cacheControl'
import { getUserInput } from './utils/userInput'
import type { CliToolRegistry } from './workflow-tools'
import { getLocalChanges } from './workflows/workflow.utils'

const allTools = [
  askFollowupQuestion,
  executeCommandTool,
  fetchUrl,
  listFilesTool,
  readBinaryFile,
  readFileTool,
  readMemoryTool,
  listMemoryTopicsTool,
  updateMemoryTool,
  removeFile,
  renameFile,
  replaceInFile,
  search,
  searchFiles,
  writeToFileTool,
  gitDiff,
  getTodoItemTool,
  listTodoItemsTool,
  updateTodoItemTool,
] as const
const toolHandlers = new Map<string, FullToolInfo>(allTools.map((t) => [t.name, t]))

type ToolCall<TTools extends ToolRegistry> = {
  [K in keyof TTools]: {
    tool: K
    input: TTools[K]['input']
  }
}[keyof TTools]

type ToolCallContext = {
  parameters: AgentContextParameters
  model: LanguageModelV2
  agentCallback?: TaskEventCallback
  toolProvider: any
  yes?: boolean
  workflowContext: any
}

async function createPullRequest(input: { title: string; description: string }, _context: ToolCallContext) {
  spawnSync('gh', ['pr', 'create', '--title', input.title, '--body', input.description], {
    stdio: 'inherit',
  })
  return { title: input.title, description: input.description }
}

async function createCommit(input: { message: string }, _context: ToolCallContext) {
  const result = spawnSync('git', ['commit', '-m', input.message], {
    stdio: 'inherit',
  })
  if (result.status !== 0) {
    throw new Error('Commit failed')
  }
  return { message: input.message }
}

async function printChangeFile(_input: unknown, _context: ToolCallContext) {
  const { stagedFiles, unstagedFiles } = getLocalChanges()
  if (stagedFiles.length === 0 && unstagedFiles.length === 0) {
    console.log('No changes to commit.')
  } else {
    if (stagedFiles.length > 0) {
      console.log('Staged files:')
      for (const file of stagedFiles) {
        console.log(`- ${file.status}: ${file.path}`)
      }
    }
    if (unstagedFiles.length > 0) {
      console.log('\nUnstaged files:')
      for (const file of unstagedFiles) {
        console.log(`- ${file.status}: ${file.path}`)
      }
    }
  }
  return { stagedFiles, unstagedFiles }
}

async function confirm(input: { message: string }, context: ToolCallContext) {
  if (context.yes) {
    return true
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  process.stderr.write('\u0007')
  return await inquirerConfirm({ message: input.message })
}

async function input(input: { message: string; default: string }, context: ToolCallContext) {
  if (context.yes) {
    return input.default ?? ''
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  process.stderr.write('\u0007')
  const result = await getUserInput(input.message, {
    default: input.default,
  })

  if (result === undefined) {
    throw new UserCancelledError()
  }
  return result
}

async function select(input: { message: string; choices: { name: string; value: string }[] }, context: ToolCallContext) {
  if (context.yes) {
    return input.choices[0].value
  }

  // to allow ora to fully stop the spinner so inquirer can takeover the cli window
  await new Promise((resolve) => setTimeout(resolve, 50))
  process.stderr.write('\u0007')
  return await inquirerSelect({ message: input.message, choices: input.choices })
}

async function writeToFile(input: { path: string; content: string }) {
  // generate parent directories if they don't exist
  await mkdir(dirname(input.path), { recursive: true })
  await fs.writeFile(input.path, input.content)
  return {}
}

async function readFile(input: { path: string }) {
  try {
    return await fs.readFile(input.path, 'utf8')
  } catch (error: unknown) {
    // Return null for file not found errors, rethrow others
    if (error && typeof error === 'object' && 'code' in error && (error.code === 'ENOENT' || error.code === 'EISDIR')) {
      return null
    }
    throw error
  }
}

async function executeCommand(input: { command: string; shell?: boolean; pipe?: boolean; args?: string[] }) {
  return new Promise((resolve, reject) => {
    const child =
      input.shell === true
        ? spawn(input.command, { shell: true, stdio: 'pipe' })
        : spawn(input.command, input.args, {
            shell: false,
            stdio: 'pipe',
          })

    let stdout = ''
    let stderr = ''
    let stdoutEnded = !child.stdout
    let stderrEnded = !child.stderr
    let closeEventFired = false
    let exitCode: number | null = null

    const checkAndResolve = () => {
      if (stdoutEnded && stderrEnded && closeEventFired) {
        resolve({ exitCode: exitCode ?? -1, stdout, stderr })
      }
    }

    if (child.stdout) {
      child.stdout.setEncoding('utf8')
      child.stdout.on('data', (data: string) => {
        if (input.pipe) {
          process.stdout.write(data)
        }
        stdout += data
      })
      child.stdout.on('end', () => {
        stdoutEnded = true
        checkAndResolve()
      })
    }

    if (child.stderr) {
      child.stderr.setEncoding('utf8')
      child.stderr.on('data', (data: string) => {
        if (input.pipe) {
          process.stderr.write(data)
        }
        stderr += data
      })
      child.stderr.on('end', () => {
        stderrEnded = true
        checkAndResolve()
      })
    }

    child.on('close', (code: number | null) => {
      exitCode = code
      closeEventFired = true
      checkAndResolve()
    })

    child.on('error', (err: Error) => {
      reject(err)
    })
  })
}

async function generateText(input: { messages: JsonModelMessage[]; tools: ToolSet }, context: ToolCallContext) {
  const { model, agentCallback } = context
  if (!model) {
    throw new Error('Model not found in context')
  }

  // Check usage limits
  const limitResult = context.parameters.usageMeter.isLimitExceeded()
  if (limitResult.result) {
    agentCallback?.({
      kind: TaskEventKind.UsageExceeded,
    })
    throw new QuotaExceededError(model.provider, model.modelId, context.parameters.usageMeter.usage.cost, limitResult.maxCost)
  }

  const { retryCount = 5, requestTimeoutSeconds = 90 } = context.parameters

  // Convert messages and apply cache control
  const messages = applyCacheControl(input.messages.map(fromJsonModelMessage), model.provider, model.modelId)

  let lastError: Error | undefined

  for (let i = 0; i < retryCount; i++) {
    const abortController = new AbortController()
    let timeout = setTimeout(() => abortController.abort(), requestTimeoutSeconds * 1000)

    const lastOutputs: string[] = []
    let repetitionDetected = false

    const usageMeterOnFinishHandler = context.parameters.usageMeter.onFinishHandler(model)

    try {
      const stream = streamText({
        model,
        temperature: 0,
        messages,
        tools: input.tools,
        async onChunk({ chunk }) {
          clearTimeout(timeout)
          timeout = setTimeout(() => abortController.abort(), requestTimeoutSeconds * 1000)
          switch (chunk.type) {
            case 'text-delta':
              lastOutputs.push(chunk.text)
              if (lastOutputs.length > 20) {
                lastOutputs.shift()
              }
              if (lastOutputs.length === 20) {
                const firstHalf = lastOutputs.slice(0, 10).join('')
                const secondHalf = lastOutputs.slice(10).join('')
                if (firstHalf === secondHalf) {
                  if (firstHalf.length > 20) {
                    repetitionDetected = true
                    abortController.abort()
                  }
                }
              }
              agentCallback?.({
                kind: TaskEventKind.Text,
                newText: chunk.text,
              })
              break
            case 'reasoning-delta':
              agentCallback?.({
                kind: TaskEventKind.Reasoning,
                newText: chunk.text,
              })
              break
          }
        },
        onFinish(result) {
          usageMeterOnFinishHandler?.(result)
        },
        providerOptions: context.parameters.providerOptions,
        abortSignal: abortController.signal,
      })

      await stream.consumeStream({
        onError: (error) => {
          // Log stream errors but don't throw - let the main error handler deal with it
          console.error('Error in stream:', error)
          lastError = error instanceof Error ? error : new Error(String(error))
        },
      })

      const resp = await stream.response
      return resp.messages.map(toJsonModelMessage)
    } catch (error: unknown) {
      // Handle AbortError (timeouts and repetition)
      if (error instanceof Error && error.name === 'AbortError') {
        if (repetitionDetected) {
          console.warn('Repetition detected, retrying...')
          lastError = new Error('Repetition detected in model output')
          continue
        }
        // This is a timeout
        console.warn(`Request timed out after ${requestTimeoutSeconds} seconds, retrying...`)
        lastError = new ProviderTimeoutError(model.provider, model.modelId, requestTimeoutSeconds)
        continue
      }

      // Handle HTTP errors
      if (error && typeof error === 'object' && 'response' in error) {
        const errorWithResponse = error as { response: Response }
        const response = errorWithResponse.response
        const statusCode = response.status

        // Create appropriate error based on status code
        const providerError = createProviderErrorFromStatus(
          model.provider,
          model.modelId,
          statusCode,
          error instanceof Error ? error : undefined,
        )

        // Only retry if error is retryable
        if (providerError.retryable && (statusCode === 429 || statusCode >= 500)) {
          console.warn(`${providerError.message} (attempt ${i + 1}/${retryCount})`)
          lastError = providerError

          const backoff = computeRateLimitBackoffSeconds(i)
          console.debug(`Waiting ${backoff}s before retry...`)
          await new Promise((resolve) => setTimeout(resolve, backoff * 1000))
          continue
        }

        // Non-retryable HTTP error - throw immediately
        throw providerError
      }

      // Handle other errors
      if (error instanceof Error) {
        // Check for network errors
        if (error.message.includes('ECONNREFUSED') || error.message.includes('ENOTFOUND') || error.message.includes('ETIMEDOUT')) {
          console.warn(`Network error: ${error.message}, retrying...`)
          lastError = error
          continue
        }

        // Unknown error - save and continue to retry
        console.warn(`Unexpected error: ${error.message}, retrying...`)
        lastError = error
        continue
      }

      // Non-Error throwable
      lastError = new Error(String(error))
    } finally {
      clearTimeout(timeout)
    }
  }

  // All retries exhausted
  throw new MaxRetriesExceededError(model.provider, model.modelId, retryCount, lastError || new Error('Unknown error'))
}

async function invokeTool(input: { toolName: string; input: any }, context: ToolCallContext): Promise<ToolResponse> {
  const tool = toolHandlers.get(input.toolName)
  if (!tool) {
    return {
      success: false,
      message: {
        type: 'error-text',
        value: `Tool not found: ${input.toolName}`,
      },
    }
  }
  try {
    const result = await tool.handler(context.toolProvider, input.input)
    return result
  } catch (error: unknown) {
    return {
      success: false,
      message: {
        type: 'error-text',
        value: error instanceof Error ? error.message : String(error),
      },
    }
  }
}

async function taskEvent(input: TaskEvent, context: ToolCallContext) {
  await context.agentCallback?.(input)
}

async function getMemoryContext(_input: unknown, context: ToolCallContext) {
  const provider: MemoryProvider = context.toolProvider
  const topics = await provider.listMemoryTopics()
  const defaultContent = await provider.readMemory()

  const contextParts: string[] = []

  if (topics?.length > 0) {
    const topicList = topics.map((topic: string) => `- ${topic}`).join('\n')
    contextParts.push(`<memory_topics>\n${topicList}\n</memory_topics>`)
  }

  if (defaultContent) {
    contextParts.push(`<memory topic=":default:">\n${defaultContent}\n</memory>`)
  }

  return contextParts.join('\n')
}

async function readMemory(input: { topic?: string }, context: ToolCallContext): Promise<string> {
  const provider: MemoryProvider = context.toolProvider
  return (await provider.readMemory(input.topic)) ?? ''
}

async function listMemoryTopics(_input: unknown, context: ToolCallContext): Promise<string[]> {
  const provider: MemoryProvider = context.toolProvider
  return provider.listMemoryTopics()
}

async function updateMemory(
  input:
    | { operation: 'append'; topic?: string; content: string }
    | { operation: 'replace'; topic?: string; content: string }
    | { operation: 'remove'; topic?: string },
  context: ToolCallContext,
) {
  const provider: MemoryProvider = context.toolProvider
  const content = 'content' in input ? input.content : undefined
  return provider.updateMemory(input.operation, input.topic, content)
}

async function listTodoItems(
  input: { id?: string | null; status?: 'open' | 'completed' | 'closed' | null },
  context: ToolCallContext,
): Promise<TodoItem[]> {
  const provider: TodoProvider = context.toolProvider
  return provider.listTodoItems(input.id, input.status)
}

async function getTodoItem(input: { id: string }, context: ToolCallContext): Promise<TodoItem | undefined> {
  const provider: TodoProvider = context.toolProvider
  return provider.getTodoItem(input.id)
}

async function updateTodoItem(input: UpdateTodoItemInput, context: ToolCallContext): Promise<UpdateTodoItemOutput> {
  const provider: TodoProvider = context.toolProvider
  return provider.updateTodoItem(input)
}

async function runAgent(input: AgentWorkflowInput, context: ToolCallContext) {
  return await agentWorkflow(input, context.workflowContext)
}

/**
 * Wrapper for skill tool operations that handles context validation and error handling
 */
async function withSkillContext<_T>(
  context: ToolCallContext,
  fn: (skillContext: SkillContext) => Promise<ToolResponse>,
): Promise<ToolResponse> {
  if (!context.parameters.skillContext) {
    return {
      success: false,
      message: { type: 'error-text', value: 'Skill context not initialized' },
    }
  }

  try {
    return await fn(context.parameters.skillContext)
  } catch (error: unknown) {
    return {
      success: false,
      message: {
        type: 'error-text',
        value: error instanceof Error ? error.message : String(error),
      },
    }
  }
}

async function loadSkill(input: { skillName: string }, context: ToolCallContext): Promise<ToolResponse> {
  return withSkillContext(context, async (skillContext) => {
    const result = await coreLoadSkill(input, skillContext)
    if (!result.success || !result.skill) {
      return {
        success: false,
        message: { type: 'error-text', value: result.error ?? 'Failed to load skill' },
      }
    }
    return {
      success: true,
      message: {
        type: 'text',
        value: `Loaded skill '${result.skill.name}':\n\n${result.skill.content}\n\nAvailable files: ${result.skill.availableFiles.join(', ')}${result.warnings && result.warnings.length > 0 ? `\n\nWarnings:\n${result.warnings.join('\n')}` : ''}`,
      },
    }
  })
}

async function listSkills(input: { filter?: string }, context: ToolCallContext): Promise<ToolResponse> {
  return withSkillContext(context, async (skillContext) => {
    const result = await coreListSkills(input, skillContext)
    const skillsList = result.skills
      .map((skill: { name: string; description: string; source: string }) => {
        const sourceIcon = SOURCE_ICONS[skill.source as keyof typeof SOURCE_ICONS]
        return `${sourceIcon} **${skill.name}**: ${skill.description}`
      })
      .join('\n')

    return {
      success: true,
      message: {
        type: 'text',
        value: `Found ${result.total} skill${result.total === 1 ? '' : 's'}:\n\n${skillsList}`,
      },
    }
  })
}

async function readSkillFile(input: { skillName: string; filename: string }, context: ToolCallContext): Promise<ToolResponse> {
  return withSkillContext(context, async (skillContext) => {
    const result = await coreReadSkillFile(input, skillContext)
    if (!result.success || !result.content) {
      return {
        success: false,
        message: { type: 'error-text', value: result.error ?? 'Failed to read skill file' },
      }
    }
    return {
      success: true,
      message: { type: 'text', value: result.content },
    }
  })
}

const localToolHandlers = {
  runAgent,
  createPullRequest,
  createCommit,
  printChangeFile,
  confirm,
  input,
  select,
  writeToFile,
  readFile,
  executeCommand,
  generateText,
  invokeTool,
  taskEvent,
  getMemoryContext,
  readMemory,
  listMemoryTopics,
  updateMemory,
  listTodoItems,
  getTodoItem,
  updateTodoItem,
  loadSkill,
  listSkills,
  readSkillFile,
}

export async function toolCall(toolCall: ToolCall<CliToolRegistry>, context: ToolCallContext) {
  // Check localToolHandlers first
  const handler = localToolHandlers[toolCall.tool]
  if (handler) {
    // Runtime tool selection means TypeScript can't infer the correct input type
    // We use 'as never' to bypass the type check since the actual type is validated at runtime
    return handler(toolCall.input as never, context)
  }

  // Check MCP tools
  if (context.parameters.mcpManager?.hasTool(toolCall.tool as string)) {
    const input = typeof toolCall.input === 'object' && toolCall.input !== null && !Array.isArray(toolCall.input) ? toolCall.input : {}
    try {
      const result = await context.parameters.mcpManager.callTool(toolCall.tool as string, input as Record<string, unknown>)
      // Wrap result in ToolResponse format
      const value = typeof result === 'string' ? result : result == null ? '' : JSON.stringify(result, null, 2)
      return {
        success: true,
        message: {
          type: 'text',
          value,
        },
      }
    } catch (error) {
      // McpError should bubble up to the workflow level for proper handling
      if (error instanceof McpError) {
        throw error
      }
      // Other errors are returned as ToolResponse so the agent can see them and recover
      return {
        success: false,
        message: {
          type: 'error-text',
          value: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      }
    }
  }

  // Check toolHandlers Map (for core/registered tools)
  const toolHandler = toolHandlers.get(toolCall.tool as keyof ToolRegistry)
  if (toolHandler) {
    // The tool handler expects specific input types based on the tool
    // We cast to satisfy TypeScript since the exact type varies by tool
    return toolHandler.handler(context.toolProvider, toolCall.input as Partial<Record<string, ToolParameterValue>>)
  }

  throw new Error(`Unknown tool: ${toolCall.tool}`)
}

/**
 * Create skill context for agent execution
 */
export async function initializeSkillContext(cwd?: string): Promise<SkillContext> {
  return await createSkillContext(cwd)
}

/**
 * Generate system prompt with available skills
 */
export function generateSystemPromptWithSkills(basePrompt: string, skillContext?: SkillContext): string {
  if (!skillContext || skillContext.availableSkills.length === 0) {
    return basePrompt
  }

  const skillsPrompt = generateSkillsSystemPrompt(skillContext.availableSkills)
  return basePrompt + skillsPrompt
}
