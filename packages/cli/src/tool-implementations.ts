// generated by polka.codes
import { spawn, spawnSync } from 'node:child_process'
import fs, { mkdir } from 'node:fs/promises'
import { dirname } from 'node:path'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { confirm as inquirerConfirm, input as inquirerInput, select as inquirerSelect } from '@inquirer/prompts'
import { listFiles, readMultiline } from '@polka-codes/cli-shared'
import type { AgentPolicy, ToolFormat, UsageMeter } from '@polka-codes/core'
import {
  type AgentBase,
  type AgentNameType,
  AnalyzerAgent,
  ArchitectAgent,
  CodeFixerAgent,
  CoderAgent,
  parseJsonFromMarkdown,
  type SharedAgentOptions,
  ToolResponseType,
} from '@polka-codes/core'
import type { PlainJson, ToolCall } from '@polka-codes/workflow'
import chalk from 'chalk'
import type { Command } from 'commander'
import type { Ora } from 'ora'
import { z } from 'zod'
import type { ApiProviderConfig } from './ApiProviderConfig'
import { UserCancelledError } from './errors'
import { parseOptions } from './options'

export type AgentContextParameters = {
  toolFormat?: ToolFormat
  os?: string
  policies?: AgentPolicy[]
  modelParameters?: Record<string, any>
  providerOptions?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter?: UsageMeter
}

import type { CliToolRegistry } from './workflow-tools'
import { getLocalChanges } from './workflows/workflow.utils'

const agentRegistry: Record<string, new (options: SharedAgentOptions) => AgentBase> = {
  analyzer: AnalyzerAgent,
  architect: ArchitectAgent,
  coder: CoderAgent,
  codefixer: CodeFixerAgent,
}

class WorkflowAgent extends CoderAgent {
  protected onBeforeInvokeTool(_name: string, _args: Record<string, string>): Promise<any | undefined> {
    return Promise.resolve(undefined)
  }
}

export async function handleToolCall(
  toolCall: ToolCall<CliToolRegistry>,
  context: {
    providerConfig: ApiProviderConfig
    parameters: AgentContextParameters
    getModel: (name: AgentNameType) => Promise<LanguageModelV2>
    agentCallback?: (event: any) => void
    toolProvider: any // ToolProvider
    spinner: Ora
    command: Command
  },
) {
  switch (toolCall.tool) {
    case 'invokeAgent': {
      context.spinner.stop()
      const input = toolCall.input
      const model = await context.getModel(input.agent)

      const AgentClass = agentRegistry[input.agent] ?? WorkflowAgent

      const agent = new AgentClass({
        ai: model,
        os: context.parameters.os ?? 'linux',
        provider: context.toolProvider,
        toolFormat: context.parameters.toolFormat ?? 'native',
        policies: context.parameters.policies ?? [],
        usageMeter: context.parameters.usageMeter,
        parameters: {
          ...context.parameters.modelParameters,
          providerOptions: context.parameters.providerOptions,
        },
        scripts: context.parameters.scripts,
        callback: context.agentCallback,
        requireToolUse: false,
        retryCount: context.parameters.retryCount,
        requestTimeoutSeconds: context.parameters.requestTimeoutSeconds,
        additionalTools: input.tools,
      })

      const messages = input.messages.map((m) =>
        typeof m === 'string' ? { role: 'user' as const, content: m } : { role: m.type, content: m.content },
      )

      const lastMessage = messages.at(-1)
      if (!lastMessage || lastMessage.role !== 'user') {
        throw new Error('The last message must be a user message.')
      }
      const history = messages.slice(0, -1)
      const userPrompt = lastMessage.content

      // If there is history, set it. Otherwise, the agent will use its default system prompt.
      if (history.length > 0) {
        agent.setMessages(history)
      }

      let combinedContext = input.context ?? ''
      if (input.defaultContext) {
        const { config } = parseOptions((context.command.parent ?? context.command).opts())

        const cwd = process.cwd()
        const agentConfig = config.agents?.[input.agent] ?? config.agents?.default ?? {}
        const maxFileCount = agentConfig.initialContext?.maxFileCount ?? 200
        const excludes = agentConfig.initialContext?.excludes ?? []
        const finalExcludes = excludes.concat(config.excludeFiles ?? [])
        const [fileList] = await listFiles(cwd, true, maxFileCount, cwd, finalExcludes)
        const fileContext = `<files>\n${fileList.join('\n')}\n</files>`

        const defaultContext = `<now_date>${new Date().toISOString().slice(0, 10)}</now_date>${fileContext}`
        combinedContext = defaultContext + (combinedContext ? `\n\n${combinedContext}` : '')
      }

      const finalPrompt = combinedContext ? `${userPrompt}\n\n<context>${combinedContext}</context>` : userPrompt
      let exitReason = await agent.start(finalPrompt)

      context.spinner.start()

      for (let i = 0; i < 5; i++) {
        if (exitReason.type !== ToolResponseType.Exit) {
          throw new Error(`Agent exited for an unhandled reason: ${JSON.stringify(exitReason)}`)
        }

        if (!input.outputSchema) {
          return {
            output: exitReason.message,
            messages: agent.messages as PlainJson,
          }
        }

        const parsed = parseJsonFromMarkdown(exitReason.message)
        if (!parsed.success) {
          const errorMessage = `Failed to parse JSON from markdown. Error: ${parsed.error}. Please correct the output. It MUST be in valid JSON format.`
          if (i < 4) {
            context.spinner.stop()
            exitReason = await agent.continueTask(errorMessage)
            context.spinner.start()
            continue
          } else {
            throw new Error(errorMessage)
          }
        }

        const validated = input.outputSchema.safeParse(parsed.data)
        if (!validated.success) {
          const errorMessage = `Output validation failed. Error: ${z.prettifyError(validated.error)}. Please correct the output.`
          if (i < 4) {
            context.spinner.stop()
            exitReason = await agent.continueTask(errorMessage)
            context.spinner.start()
            continue
          } else {
            throw new Error(z.prettifyError(validated.error))
          }
        }
        return {
          output: validated.data,
          messages: agent.messages as PlainJson,
        }
      }

      throw new Error('Agent failed to produce valid output after 5 retries.')
    }
    case 'createPullRequest': {
      const { title, description } = toolCall.input as {
        title: string
        description: string
      }
      context.spinner.stop()
      spawnSync('gh', ['pr', 'create', '--title', title, '--body', description], {
        stdio: 'inherit',
      })
      context.spinner.start()
      return { title, description }
    }
    case 'createCommit': {
      const { message } = toolCall.input
      context.spinner.stop()

      const result = spawnSync('git', ['commit', '-m', message], {
        stdio: 'inherit',
      })
      if (result.status !== 0) {
        throw new Error('Commit failed')
      }
      context.spinner.start()
      return { message }
    }
    case 'printChangeFile': {
      context.spinner.stop()

      const { stagedFiles, unstagedFiles } = getLocalChanges()
      if (stagedFiles.length === 0 && unstagedFiles.length === 0) {
        console.log('No changes to commit.')
      } else {
        if (stagedFiles.length > 0) {
          console.log('Staged files:')
          for (const file of stagedFiles) {
            console.log(`- ${file.status}: ${file.path}`)
          }
        }
        if (unstagedFiles.length > 0) {
          console.log('\nUnstaged files:')
          for (const file of unstagedFiles) {
            console.log(`- ${file.status}: ${file.path}`)
          }
        }
      }
      context.spinner.start()
      return { stagedFiles, unstagedFiles }
    }
    case 'confirm': {
      const { message } = toolCall.input
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerConfirm({ message })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'input': {
      const { message, default: defaultValue } = toolCall.input
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        let result = await inquirerInput({
          message: `${message}${chalk.gray(' (type .m for multiline)')}`,
          default: defaultValue,
        })
        if (result === '.m') {
          result = await readMultiline('Enter multiline text (Ctrl+D to finish):')
        }
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'select': {
      const { message, choices } = toolCall.input as {
        message: string
        choices: { name: string; value: string }[]
      }
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerSelect({ message, choices })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'writeToFile': {
      const { path, content } = toolCall.input
      // generate parent directories if they don't exist
      await mkdir(dirname(path), { recursive: true })
      await fs.writeFile(path, content)
      return {}
    }
    case 'readFile': {
      const { path } = toolCall.input
      try {
        const content = await fs.readFile(path, 'utf8')
        return content
      } catch {
        // return null if file doesn't exist or can't be read
      }
      return null
    }
    case 'executeCommand': {
      const { command, shell, pipe } = toolCall.input
      return new Promise((resolve, reject) => {
        const child =
          shell === true
            ? spawn(command, { shell: true, stdio: 'pipe' })
            : spawn(command, toolCall.input.args, {
                shell: false,
                stdio: 'pipe',
              })

        let stdout = ''
        let stderr = ''
        let stdoutEnded = !child.stdout
        let stderrEnded = !child.stderr
        let closeEventFired = false
        let exitCode: number | null = null

        const checkAndResolve = () => {
          if (stdoutEnded && stderrEnded && closeEventFired) {
            resolve({ exitCode: exitCode ?? -1, stdout, stderr })
          }
        }

        if (child.stdout) {
          child.stdout.setEncoding('utf8')
          child.stdout.on('data', (data: string) => {
            if (pipe) {
              process.stdout.write(data)
            }
            stdout += data
          })
          child.stdout.on('end', () => {
            stdoutEnded = true
            checkAndResolve()
          })
        }

        if (child.stderr) {
          child.stderr.setEncoding('utf8')
          child.stderr.on('data', (data: string) => {
            if (pipe) {
              process.stderr.write(data)
            }
            stderr += data
          })
          child.stderr.on('end', () => {
            stderrEnded = true
            checkAndResolve()
          })
        }

        child.on('close', (code: number | null) => {
          exitCode = code
          closeEventFired = true
          checkAndResolve()
        })

        child.on('error', (err: Error) => {
          reject(err)
        })
      })
    }
    case 'runTask': {
      const { task } = toolCall.input as { task: string }
      context.spinner.stop()

      const { config, providerConfig, verbose, maxMessageCount, budget, agent, silent } = parseOptions(
        (context.command.parent ?? context.command).opts(),
      )
      const { Runner } = await import('./Runner') // Lazy import to avoid circular dependency

      const runner = new Runner({
        providerConfig,
        config,
        maxMessageCount,
        budget,
        interactive: false,
        verbose,
        silent,
        externalUsageMeter: context.parameters.usageMeter,
      })

      await runner.startTask(task, agent)

      if (!silent) {
        runner.printUsage()
      }

      context.spinner.start()
      return {}
    }
  }
  throw new Error(`Unknown tool: ${String((toolCall as any).tool)}`)
}
