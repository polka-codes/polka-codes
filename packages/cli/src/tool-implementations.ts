// generated by polka.codes
import { spawn, spawnSync } from 'node:child_process'
import fs, { mkdir } from 'node:fs/promises'
import { dirname } from 'node:path'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { confirm as inquirerConfirm, input as inquirerInput, select as inquirerSelect } from '@inquirer/prompts'
import { listFiles, readMultiline } from '@polka-codes/cli-shared'
import type { AgentPolicy, TaskEventCallback, ToolFormat, UsageMeter } from '@polka-codes/core'
import {
  type AgentBase,
  type AgentNameType,
  AnalyzerAgent,
  ArchitectAgent,
  attemptCompletion,
  CodeFixerAgent,
  CoderAgent,
  computeRateLimitBackoffSeconds,
  delegate,
  executeCommand,
  fetchUrl,
  handOver,
  listFiles as listFilesTool,
  parseJsonFromMarkdown,
  readBinaryFile,
  readFile,
  removeFile,
  renameFile,
  replaceInFile,
  type SharedAgentOptions,
  searchFiles,
  TaskEventKind,
  ToolResponseType,
  writeToFile,
} from '@polka-codes/core'
import { fromJsonModelMessage, type ToolRegistry } from '@polka-codes/workflow'
import { streamText } from 'ai'
import chalk from 'chalk'
import type { Command } from 'commander'
import type { Ora } from 'ora'
import { z } from 'zod'
import type { ApiProviderConfig } from './ApiProviderConfig'
import { UserCancelledError } from './errors'
import { parseOptions } from './options'

export type AgentContextParameters = {
  toolFormat?: ToolFormat
  os?: string
  policies?: AgentPolicy[]
  modelParameters?: Record<string, any>
  providerOptions?: Record<string, any>
  scripts?: Record<string, string | { command: string; description: string }>
  retryCount?: number
  requestTimeoutSeconds?: number
  usageMeter?: UsageMeter
}

import { camelCase } from 'lodash-es'
import { gitDiff } from './tools'
import type { CliToolRegistry } from './workflow-tools'
import { getLocalChanges } from './workflows/workflow.utils'

const allTools = [
  attemptCompletion,
  delegate,
  executeCommand,
  fetchUrl,
  handOver,
  listFilesTool,
  readBinaryFile,
  readFile,
  removeFile,
  renameFile,
  replaceInFile,
  searchFiles,
  writeToFile,
  gitDiff,
] as const
const toolHandlers = new Map(allTools.map((t) => [camelCase(t.name), t]))

const agentRegistry: Record<string, new (options: SharedAgentOptions) => AgentBase> = {
  analyzer: AnalyzerAgent,
  architect: ArchitectAgent,
  coder: CoderAgent,
  codefixer: CodeFixerAgent,
}

class WorkflowAgent extends CoderAgent {
  protected onBeforeInvokeTool(_name: string, _args: Record<string, string>): Promise<any | undefined> {
    return Promise.resolve(undefined)
  }
}

type ToolCall<TTools extends ToolRegistry> = {
  [K in keyof TTools]: {
    tool: K
    input: TTools[K]['input']
  }
}[keyof TTools]

export async function handleToolCall(
  toolCall: ToolCall<CliToolRegistry>,
  context: {
    providerConfig: ApiProviderConfig
    parameters: AgentContextParameters
    getModel: (name: AgentNameType) => Promise<LanguageModelV2>
    model?: LanguageModelV2
    agentCallback?: TaskEventCallback
    toolProvider: any // ToolProvider
    spinner: Ora
    command: Command
  },
) {
  switch (toolCall.tool) {
    case 'invokeAgent': {
      context.spinner.stop()
      const input = toolCall.input
      const model = await context.getModel(input.agent)

      const AgentClass = agentRegistry[input.agent] ?? WorkflowAgent

      const agent = new AgentClass({
        ai: model,
        os: context.parameters.os ?? 'linux',
        provider: context.toolProvider,
        toolFormat: context.parameters.toolFormat ?? 'native',
        policies: context.parameters.policies ?? [],
        usageMeter: context.parameters.usageMeter,
        parameters: {
          ...context.parameters.modelParameters,
          providerOptions: context.parameters.providerOptions,
        },
        scripts: context.parameters.scripts,
        callback: context.agentCallback,
        requireToolUse: false,
        retryCount: context.parameters.retryCount,
        requestTimeoutSeconds: context.parameters.requestTimeoutSeconds,
        additionalTools: input.tools,
      })

      const messages = input.messages.map((m) =>
        typeof m === 'string' ? { role: 'user' as const, content: m } : { role: m.type, content: m.content },
      )

      const lastMessage = messages.at(-1)
      if (!lastMessage || lastMessage.role !== 'user') {
        throw new Error('The last message must be a user message.')
      }
      const history = messages.slice(0, -1)
      const userPrompt = lastMessage.content

      // If there is history, set it. Otherwise, the agent will use its default system prompt.
      if (history.length > 0) {
        agent.setMessages(history)
      }

      let combinedContext = input.context ?? ''
      if (input.defaultContext) {
        const { config } = parseOptions((context.command.parent ?? context.command).opts())

        const cwd = process.cwd()
        const agentConfig = config.agents?.[input.agent] ?? config.agents?.default ?? {}
        const maxFileCount = agentConfig.initialContext?.maxFileCount ?? 200
        const excludes = agentConfig.initialContext?.excludes ?? []
        const finalExcludes = excludes.concat(config.excludeFiles ?? [])
        const [fileList] = await listFiles(cwd, true, maxFileCount, cwd, finalExcludes)
        const fileContext = `<files>\n${fileList.join('\n')}\n</files>`

        const defaultContext = `<now_date>${new Date().toISOString().slice(0, 10)}</now_date>${fileContext}`
        combinedContext = defaultContext + (combinedContext ? `\n\n${combinedContext}` : '')
      }

      const finalPrompt = combinedContext ? `${userPrompt}\n\n<context>${combinedContext}</context>` : userPrompt
      let exitReason = await agent.start(finalPrompt)

      context.spinner.start()

      for (let i = 0; i < 5; i++) {
        if (exitReason.type !== ToolResponseType.Exit) {
          throw new Error(`Agent exited for an unhandled reason: ${JSON.stringify(exitReason)}`)
        }

        if (!input.outputSchema) {
          return {
            output: exitReason.message,
            messages: agent.messages,
          }
        }

        const parsed = parseJsonFromMarkdown(exitReason.message)
        if (!parsed.success) {
          const errorMessage = `Failed to parse JSON from markdown. Error: ${parsed.error}. Please correct the output. It MUST be in valid JSON format.`
          if (i < 4) {
            context.spinner.stop()
            exitReason = await agent.continueTask(errorMessage)
            context.spinner.start()
            continue
          } else {
            throw new Error(errorMessage)
          }
        }

        const validated = input.outputSchema.safeParse(parsed.data)
        if (!validated.success) {
          const errorMessage = `Output validation failed. Error: ${z.prettifyError(validated.error)}. Please correct the output.`
          if (i < 4) {
            context.spinner.stop()
            exitReason = await agent.continueTask(errorMessage)
            context.spinner.start()
            continue
          } else {
            throw new Error(z.prettifyError(validated.error))
          }
        }
        return {
          output: validated.data,
          messages: agent.messages,
        }
      }

      throw new Error('Agent failed to produce valid output after 5 retries.')
    }
    case 'createPullRequest': {
      const { title, description } = toolCall.input as {
        title: string
        description: string
      }
      context.spinner.stop()
      spawnSync('gh', ['pr', 'create', '--title', title, '--body', description], {
        stdio: 'inherit',
      })
      context.spinner.start()
      return { title, description }
    }
    case 'createCommit': {
      const { message } = toolCall.input
      context.spinner.stop()

      const result = spawnSync('git', ['commit', '-m', message], {
        stdio: 'inherit',
      })
      if (result.status !== 0) {
        throw new Error('Commit failed')
      }
      context.spinner.start()
      return { message }
    }
    case 'printChangeFile': {
      context.spinner.stop()

      const { stagedFiles, unstagedFiles } = getLocalChanges()
      if (stagedFiles.length === 0 && unstagedFiles.length === 0) {
        console.log('No changes to commit.')
      } else {
        if (stagedFiles.length > 0) {
          console.log('Staged files:')
          for (const file of stagedFiles) {
            console.log(`- ${file.status}: ${file.path}`)
          }
        }
        if (unstagedFiles.length > 0) {
          console.log('\nUnstaged files:')
          for (const file of unstagedFiles) {
            console.log(`- ${file.status}: ${file.path}`)
          }
        }
      }
      context.spinner.start()
      return { stagedFiles, unstagedFiles }
    }
    case 'confirm': {
      const { message } = toolCall.input
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerConfirm({ message })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'input': {
      const { message, default: defaultValue } = toolCall.input
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        let result = await inquirerInput({
          message: `${message}${chalk.gray(' (type .m for multiline)')}`,
          default: defaultValue,
        })
        if (result === '.m') {
          result = await readMultiline('Enter multiline text (Ctrl+D to finish):')
        }
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'select': {
      const { message, choices } = toolCall.input as {
        message: string
        choices: { name: string; value: string }[]
      }
      context.spinner.stop()

      // to allow ora to fully stop the spinner so inquirer can takeover the cli window
      await new Promise((resolve) => setTimeout(resolve, 50))
      try {
        const result = await inquirerSelect({ message, choices })
        context.spinner.start()
        return result
      } catch (_e) {
        throw new UserCancelledError()
      }
    }
    case 'writeToFile': {
      const { path, content } = toolCall.input
      // generate parent directories if they don't exist
      await mkdir(dirname(path), { recursive: true })
      await fs.writeFile(path, content)
      return {}
    }
    case 'readFile': {
      const { path } = toolCall.input
      try {
        const content = await fs.readFile(path, 'utf8')
        return content
      } catch {
        // return null if file doesn't exist or can't be read
      }
      return null
    }
    case 'executeCommand': {
      const { command, shell, pipe } = toolCall.input
      return new Promise((resolve, reject) => {
        const child =
          shell === true
            ? spawn(command, { shell: true, stdio: 'pipe' })
            : spawn(command, toolCall.input.args, {
                shell: false,
                stdio: 'pipe',
              })

        let stdout = ''
        let stderr = ''
        let stdoutEnded = !child.stdout
        let stderrEnded = !child.stderr
        let closeEventFired = false
        let exitCode: number | null = null

        const checkAndResolve = () => {
          if (stdoutEnded && stderrEnded && closeEventFired) {
            resolve({ exitCode: exitCode ?? -1, stdout, stderr })
          }
        }

        if (child.stdout) {
          child.stdout.setEncoding('utf8')
          child.stdout.on('data', (data: string) => {
            if (pipe) {
              process.stdout.write(data)
            }
            stdout += data
          })
          child.stdout.on('end', () => {
            stdoutEnded = true
            checkAndResolve()
          })
        }

        if (child.stderr) {
          child.stderr.setEncoding('utf8')
          child.stderr.on('data', (data: string) => {
            if (pipe) {
              process.stderr.write(data)
            }
            stderr += data
          })
          child.stderr.on('end', () => {
            stderrEnded = true
            checkAndResolve()
          })
        }

        child.on('close', (code: number | null) => {
          exitCode = code
          closeEventFired = true
          checkAndResolve()
        })

        child.on('error', (err: Error) => {
          reject(err)
        })
      })
    }
    case 'generateText': {
      context.spinner.stop()
      const { model, agentCallback } = context
      if (!model) {
        throw new Error('Model not found in context')
      }
      const { messages, tools } = toolCall.input

      const { retryCount = 5, requestTimeoutSeconds = 90 } = context.parameters

      for (let i = 0; i < retryCount; i++) {
        const abortController = new AbortController()
        const timeout = setTimeout(() => abortController.abort(), requestTimeoutSeconds * 1000)

        try {
          const stream = streamText({
            model,
            temperature: 0,
            messages: messages.map(fromJsonModelMessage),
            tools,
            async onChunk({ chunk }) {
              switch (chunk.type) {
                case 'text-delta':
                  agentCallback?.({
                    kind: TaskEventKind.Text,
                    newText: chunk.text,
                  })
                  break
                case 'reasoning-delta':
                  agentCallback?.({
                    kind: TaskEventKind.Reasoning,
                    newText: chunk.text,
                  })
                  break
              }
            },
            onFinish(result) {
              agentCallback?.({
                kind: TaskEventKind.Usage,
                usage: result.usage,
              })
            },
            providerOptions: context.parameters.providerOptions,
            abortSignal: abortController.signal,
          })

          await stream.consumeStream({
            onError: (error) => {
              console.error('Error in stream:', error)
            },
          })

          const resp = await stream.response
          return resp.messages
        } catch (error: any) {
          if (error.name === 'AbortError') {
            // This is a timeout
            continue
          }
          if ('response' in error) {
            const response: Response = error.response
            if (response.status === 429) {
              const backoff = computeRateLimitBackoffSeconds(i)
              await new Promise((resolve) => setTimeout(resolve, backoff * 1000))
              continue
            }
          }
          throw error
        } finally {
          clearTimeout(timeout)
          context.spinner.start()
        }
      }
      throw new Error(`Failed to get a response from the model after ${retryCount} retries.`)
    }
    case 'invokeTool': {
      const { toolName, input } = toolCall.input
      const tool = toolHandlers.get(toolName as any)
      if (!tool) {
        return {
          type: ToolResponseType.Error,
          error: `Tool not found: ${toolName}`,
        }
      }
      try {
        const result = await tool.handler(context.toolProvider, input)
        return result
      } catch (error: any) {
        return {
          type: ToolResponseType.Error,
          error: error.message,
        }
      }
    }
    case 'taskEvent': {
      const event = toolCall.input
      await context.agentCallback?.(event)

      return
    }
  }
  throw new Error(`Unknown tool: ${(toolCall as any).tool}`)
}
