// Unit tests for MCP server
// generated by polka.codes

import { beforeEach, describe, expect, test } from 'bun:test'
import { McpServer } from './server'
import type { McpServerTransport } from './transport'

// Mock logger
const mockLogger = {
  debug: () => {},
  info: () => {},
  warn: () => {},
  error: () => {},
}

describe('McpServer', () => {
  describe('Initialization', () => {
    test('should initialize with default config', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      expect(server.getToolsCount()).toBe(0)
      expect(server.getResourcesCount()).toBe(0)
      expect(server.isInitialized()).toBe(false)
    })

    test('should have correct protocol version in config', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      const serverState = server.getState() as any
      expect(serverState?.config?.serverInfo?.name).toBe('test-server')
      expect(serverState?.config?.serverInfo?.version).toBe('1.0.0')
    })
  })

  describe('Tool Registration', () => {
    test('should register tools', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      server.registerTool({
        name: 'test_tool',
        description: 'A test tool',
        inputSchema: {
          type: 'object',
          properties: {
            arg1: { type: 'string' },
          },
        },
        handler: async (args) => {
          return { result: args }
        },
      })

      expect(server.getToolsCount()).toBe(1)
    })

    test('should register multiple tools', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      server.registerTools([
        {
          name: 'tool1',
          description: 'Tool 1',
          inputSchema: {},
          handler: async () => ({}),
        },
        {
          name: 'tool2',
          description: 'Tool 2',
          inputSchema: {},
          handler: async () => ({}),
        },
      ])

      expect(server.getToolsCount()).toBe(2)
    })

    test('should overwrite tool with same name', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      server.registerTool({
        name: 'tool',
        description: 'First version',
        inputSchema: {},
        handler: async () => ({ v: 1 }),
      })

      server.registerTool({
        name: 'tool',
        description: 'Second version',
        inputSchema: {},
        handler: async () => ({ v: 2 }),
      })

      expect(server.getToolsCount()).toBe(1)
    })
  })

  describe('Resource Registration', () => {
    test('should register resources', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            resources: true,
          },
        },
        mockLogger,
      )

      server.registerResource({
        uri: 'file:///test.txt',
        name: 'Test File',
        description: 'A test file',
        mimeType: 'text/plain',
        handler: async () => 'content',
      })

      expect(server.getResourcesCount()).toBe(1)
    })

    test('should register multiple resources', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            resources: true,
          },
        },
        mockLogger,
      )

      server.registerResources([
        {
          uri: 'file:///test1.txt',
          name: 'Test 1',
          handler: async () => 'content1',
        },
        {
          uri: 'file:///test2.txt',
          name: 'Test 2',
          handler: async () => 'content2',
        },
      ])

      expect(server.getResourcesCount()).toBe(2)
    })

    test('should overwrite resource with same URI', () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            resources: true,
          },
        },
        mockLogger,
      )

      server.registerResource({
        uri: 'file:///test.txt',
        name: 'Test 1',
        handler: async () => 'content1',
      })

      server.registerResource({
        uri: 'file:///test.txt',
        name: 'Test 2',
        handler: async () => 'content2',
      })

      expect(server.getResourcesCount()).toBe(1)
    })
  })

  describe('Message Handling', () => {
    let server: McpServer
    let mockTransport: McpServerTransport
    let sentMessages: any[] = []

    beforeEach(() => {
      sentMessages = []
      server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
            resources: true,
          },
        },
        mockLogger,
      )

      // Register a test tool
      server.registerTool({
        name: 'echo',
        description: 'Echo back arguments',
        inputSchema: {
          type: 'object',
          properties: {
            message: { type: 'string' },
          },
          required: ['message'],
        },
        handler: async (args) => {
          return { echoed: args.message }
        },
      })

      // Mock transport to capture sent messages
      const serverState = server.getState() as any
      mockTransport = serverState.transport
      const originalSend = mockTransport.sendMessage.bind(mockTransport)
      mockTransport.sendMessage = (msg: any) => {
        sentMessages.push(msg)
        return originalSend(msg)
      }

      // Start server
      server.start()
    })

    test('should handle initialize request correctly', async () => {
      const initializeRequest = {
        jsonrpc: '2.0' as const,
        id: 1,
        method: 'initialize' as const,
        params: {
          protocolVersion: '2024-11-05',
          capabilities: {},
          clientInfo: {
            name: 'test-client',
            version: '1.0.0',
          },
        },
      }

      await server['handleRequest'](initializeRequest.id, initializeRequest.method, initializeRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(1)
      expect(response.result).toBeDefined()
      expect(response.result.protocolVersion).toBe('2024-11-05')
      expect(response.result.capabilities).toBeDefined()
      expect(response.result.serverInfo).toEqual({
        name: 'test-server',
        version: '1.0.0',
      })
    })

    test('should set initialized flag after initialized notification', async () => {
      expect(server.isInitialized()).toBe(false)

      // Send initialize request
      await server['handleRequest'](1, 'initialize', {
        protocolVersion: '2024-11-05',
        capabilities: {},
        clientInfo: { name: 'test', version: '1.0.0' },
      })

      expect(server.isInitialized()).toBe(false)

      // Send initialized notification
      await server['handleNotification']('notifications/initialized', {})

      expect(server.isInitialized()).toBe(true)
    })

    test('should handle tools/list request', async () => {
      const listRequest = {
        jsonrpc: '2.0' as const,
        id: 2,
        method: 'tools/list' as const,
        params: {},
      }

      await server['handleRequest'](listRequest.id, listRequest.method, listRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(2)
      expect(response.result.tools).toBeDefined()
      expect(Array.isArray(response.result.tools)).toBe(true)
      expect(response.result.tools.length).toBe(1)
      expect(response.result.tools[0]).toEqual({
        name: 'echo',
        description: 'Echo back arguments',
        inputSchema: {
          type: 'object',
          properties: {
            message: { type: 'string' },
          },
          required: ['message'],
        },
      })
    })

    test('should handle tools/call request successfully', async () => {
      const callRequest = {
        jsonrpc: '2.0' as const,
        id: 3,
        method: 'tools/call' as const,
        params: {
          name: 'echo',
          arguments: {
            message: 'hello',
          },
        },
      }

      await server['handleRequest'](callRequest.id, callRequest.method, callRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(3)
      expect(response.result).toBeDefined()
      expect(response.result.content).toBeDefined()
      expect(Array.isArray(response.result.content)).toBe(true)
      expect(response.result.isError).toBeUndefined()
    })

    test('should return error for unknown tool', async () => {
      const callRequest = {
        jsonrpc: '2.0' as const,
        id: 4,
        method: 'tools/call' as const,
        params: {
          name: 'unknown_tool',
          arguments: {},
        },
      }

      await server['handleRequest'](callRequest.id, callRequest.method, callRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(4)
      expect(response.error).toBeDefined()
      expect(response.error.code).toBe(-32602) // Invalid params
      expect(response.error.message).toContain('Tool not found')
    })

    test('should return error for invalid tool name', async () => {
      const callRequest = {
        jsonrpc: '2.0' as const,
        id: 5,
        method: 'tools/call' as const,
        params: {
          name: null,
          arguments: {},
        },
      }

      await server['handleRequest'](callRequest.id, callRequest.method, callRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.error).toBeDefined()
      expect(response.error.code).toBe(-32602)
    })

    test('should return error for invalid arguments format', async () => {
      const callRequest = {
        jsonrpc: '2.0' as const,
        id: 6,
        method: 'tools/call' as const,
        params: {
          name: 'echo',
          arguments: 'invalid',
        },
      }

      await server['handleRequest'](callRequest.id, callRequest.method, callRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.error).toBeDefined()
      expect(response.error.code).toBe(-32602)
    })

    test('should handle tool execution error with isError flag', async () => {
      server.registerTool({
        name: 'failing_tool',
        description: 'A tool that fails',
        inputSchema: {},
        handler: async () => {
          throw new Error('Tool execution failed')
        },
      })

      const callRequest = {
        jsonrpc: '2.0' as const,
        id: 7,
        method: 'tools/call' as const,
        params: {
          name: 'failing_tool',
          arguments: {},
        },
      }

      await server['handleRequest'](callRequest.id, callRequest.method, callRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(7)
      expect(response.result).toBeDefined()
      expect(response.result.isError).toBe(true)
      expect(response.result.content).toBeDefined()
      expect(response.result.content[0].text).toBe('Tool execution failed')
    })

    test('should handle resources/list request', async () => {
      server.registerResource({
        uri: 'file:///test.txt',
        name: 'Test File',
        description: 'A test file',
        mimeType: 'text/plain',
        handler: async () => 'content',
      })

      const listRequest = {
        jsonrpc: '2.0' as const,
        id: 8,
        method: 'resources/list' as const,
        params: {},
      }

      await server['handleRequest'](listRequest.id, listRequest.method, listRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(8)
      expect(response.result.resources).toBeDefined()
      expect(Array.isArray(response.result.resources)).toBe(true)
      expect(response.result.resources.length).toBe(1)
      expect(response.result.resources[0]).toEqual({
        uri: 'file:///test.txt',
        name: 'Test File',
        description: 'A test file',
        mimeType: 'text/plain',
      })
    })

    test('should handle resources/read request successfully', async () => {
      server.registerResource({
        uri: 'file:///test.txt',
        name: 'Test File',
        handler: async () => 'file content',
      })

      const readRequest = {
        jsonrpc: '2.0' as const,
        id: 9,
        method: 'resources/read' as const,
        params: {
          uri: 'file:///test.txt',
        },
      }

      await server['handleRequest'](readRequest.id, readRequest.method, readRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(9)
      expect(response.result).toBeDefined()
      expect(response.result.contents).toBeDefined()
      expect(Array.isArray(response.result.contents)).toBe(true)
      expect(response.result.contents[0].uri).toBe('file:///test.txt')
      expect(response.result.contents[0].text).toBe('file content')
    })

    test('should return error for unknown resource', async () => {
      const readRequest = {
        jsonrpc: '2.0' as const,
        id: 10,
        method: 'resources/read' as const,
        params: {
          uri: 'file:///unknown.txt',
        },
      }

      await server['handleRequest'](readRequest.id, readRequest.method, readRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(10)
      expect(response.error).toBeDefined()
      expect(response.error.code).toBe(-32602)
      expect(response.error.message).toContain('Resource not found')
    })

    test('should handle prompts/list request (empty array)', async () => {
      const listRequest = {
        jsonrpc: '2.0' as const,
        id: 11,
        method: 'prompts/list' as const,
        params: {},
      }

      await server['handleRequest'](listRequest.id, listRequest.method, listRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(11)
      expect(response.result.prompts).toEqual([])
    })

    test('should return method not found error for unknown method', async () => {
      const unknownRequest = {
        jsonrpc: '2.0' as const,
        id: 12,
        method: 'unknown/method' as any,
        params: {},
      }

      await server['handleRequest'](unknownRequest.id, unknownRequest.method, unknownRequest.params)

      expect(sentMessages.length).toBe(1)
      const response = sentMessages[0]

      expect(response.jsonrpc).toBe('2.0')
      expect(response.id).toBe(12)
      expect(response.error).toBeDefined()
      expect(response.error.code).toBe(-32601) // Method not found
      expect(response.error.message).toContain('Method not found')
    })
  })

  describe('Rate Limiting', () => {
    test('should enforce rate limit after threshold', async () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      server.registerTool({
        name: 'test',
        description: 'Test',
        inputSchema: {},
        handler: async () => ({}),
      })

      const serverState = server.getState() as any
      const originalCheckRateLimit = server['checkRateLimit'].bind(server)

      // Mock time to simulate rate limit window
      const currentTime = Date.now()
      global.Date.now = () => currentTime

      // Make 60 requests (should all pass)
      for (let i = 0; i < 60; i++) {
        const result = originalCheckRateLimit('default')
        expect(result).toBe(true)
      }

      // 61st request should be rate limited
      const result = originalCheckRateLimit('default')
      expect(result).toBe(false)
    })

    test('should reset rate limit after window expires', async () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      const serverState = server.getState() as any
      const originalCheckRateLimit = server['checkRateLimit'].bind(server)

      // Mock time
      let currentTime = Date.now()
      global.Date.now = () => currentTime

      // Make 60 requests
      for (let i = 0; i < 60; i++) {
        originalCheckRateLimit('default')
      }

      // Next request should fail
      expect(originalCheckRateLimit('default')).toBe(false)

      // Advance time by 61 seconds (past window)
      currentTime += 61 * 1000

      // Should now be allowed again
      expect(originalCheckRateLimit('default')).toBe(true)
    })
  })

  describe('Lifecycle', () => {
    test('should start and stop server', async () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      await server.start()
      // Server should be running

      await server.stop()
      // Server should be stopped
    })

    test('should handle notifications/cancelled', async () => {
      const server = new McpServer(
        {
          serverInfo: {
            name: 'test-server',
            version: '1.0.0',
          },
          capabilities: {
            tools: true,
          },
        },
        mockLogger,
      )

      // Should not throw
      await server['handleNotification']('notifications/cancelled', {
        reason: 'User cancelled',
      })
    })
  })
})
