// Unit tests for MCP transport layer
// generated by polka.codes

import { describe, expect, test } from 'bun:test'
import { McpServerTransport } from './transport'

describe('McpServerTransport', () => {
  describe('Message Sending', () => {
    test('should send response messages', () => {
      const transport = new McpServerTransport()
      let sentMessage: any = null

      // Mock stdout.write to capture messages
      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        sentMessage = JSON.parse(data.trim())
        return true
      }) as any

      transport.sendResponse(1, { status: 'ok' })

      expect(sentMessage).toBeDefined()
      expect(sentMessage.jsonrpc).toBe('2.0')
      expect(sentMessage.id).toBe(1)
      expect(sentMessage.result).toEqual({ status: 'ok' })

      // Restore stdout.write
      process.stdout.write = originalWrite
    })

    test('should send error messages', () => {
      const transport = new McpServerTransport()
      let sentMessage: any = null

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        sentMessage = JSON.parse(data.trim())
        return true
      }) as any

      transport.sendError(1, -32601, 'Method not found', { details: 'test' })

      expect(sentMessage).toBeDefined()
      expect(sentMessage.jsonrpc).toBe('2.0')
      expect(sentMessage.id).toBe(1)
      expect(sentMessage.error).toBeDefined()
      expect(sentMessage.error.code).toBe(-32601)
      expect(sentMessage.error.message).toBe('Method not found')
      expect(sentMessage.error.data).toEqual({ details: 'test' })

      process.stdout.write = originalWrite
    })

    test('should send notifications', () => {
      const transport = new McpServerTransport()
      let sentMessage: any = null

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        sentMessage = JSON.parse(data.trim())
        return true
      }) as any

      transport.sendNotification('test/notification', { data: 'value' })

      expect(sentMessage).toBeDefined()
      expect(sentMessage.jsonrpc).toBe('2.0')
      expect(sentMessage.method).toBe('test/notification')
      expect(sentMessage.params).toEqual({ data: 'value' })

      process.stdout.write = originalWrite
    })
  })

  describe('Message Parsing', () => {
    test('should parse JSON-RPC messages', (done) => {
      const transport = new McpServerTransport()

      transport.on('message', (message: any) => {
        expect(message.jsonrpc).toBe('2.0')
        expect(message.id).toBe(1)
        expect(message.method).toBe('test/method')
        expect(message.params).toEqual({ arg: 'value' })
        done()
      })

      // Simulate stdin data
      transport['handleData']('{"jsonrpc":"2.0","id":1,"method":"test/method","params":{"arg":"value"}}\n')
    })

    test('should handle Content-Length framed messages', (done) => {
      const transport = new McpServerTransport()

      transport.on('message', (message: any) => {
        expect(message.jsonrpc).toBe('2.0')
        expect(message.method).toBe('test/method')
        done()
      })

      const message = JSON.stringify({ jsonrpc: '2.0', method: 'test/method', params: {} })
      const framedMessage = `Content-Length: ${message.length}\r\n\r\n${message}`

      transport['handleData'](framedMessage)
    })

    test('should handle multiple messages in buffer', (done) => {
      const transport = new McpServerTransport()
      let messageCount = 0

      transport.on('message', (message: any) => {
        messageCount++
        if (messageCount === 2) {
          expect(messageCount).toBe(2)
          done()
        }
      })

      const msg1 = JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'method1', params: {} })
      const msg2 = JSON.stringify({ jsonrpc: '2.0', id: 2, method: 'method2', params: {} })

      transport['handleData'](`${msg1}\n${msg2}\n`)
    })

    test('should handle incomplete messages', (done) => {
      const transport = new McpServerTransport()
      let receivedMessage = false

      transport.on('message', (message: any) => {
        receivedMessage = true
        expect(message.method).toBe('test/method')
        done()
      })

      // Send incomplete message
      transport['handleData']('{"jsonrpc":"2.0","method":"test/')

      // Send rest of message
      setTimeout(() => {
        transport['handleData']('method","params":{}}\n')
        if (!receivedMessage) {
          done(new Error('Message not received'))
        }
      }, 10)
    })

    test('should emit error for invalid JSON', (done) => {
      const transport = new McpServerTransport()

      transport.on('error', (error: Error) => {
        expect(error).toBeDefined()
        expect(error.message).toContain('Failed to parse')
        done()
      })

      transport['handleData']('invalid json\n')
    })

    test('should reject messages larger than MAX_MESSAGE_SIZE', (done) => {
      const transport = new McpServerTransport()

      transport.on('error', (error: Error) => {
        expect(error).toBeDefined()
        expect(error.message).toContain('exceeds maximum')
        done()
      })

      // Create a message with Content-Length header claiming size > MAX_MESSAGE_SIZE
      const framedMessage = `Content-Length: ${10 * 1024 * 1024 + 1}\r\n\r\n{"jsonrpc":"2.0","method":"test"}`

      transport['handleData'](framedMessage)
    })

    test('should prevent buffer overflow', (done) => {
      const transport = new McpServerTransport()

      transport.on('error', (error: Error) => {
        expect(error).toBeDefined()
        expect(error.message).toContain('Message too large')
        done()
      })

      // Send data larger than MAX_BUFFER_SIZE (10MB + 1 byte)
      const hugeData = 'x'.repeat(10 * 1024 * 1024 + 1)
      transport['handleData'](hugeData)
    })
  })

  describe('Error Handling', () => {
    test('should handle empty messages', () => {
      const transport = new McpServerTransport()
      let messageEmitted = false

      transport.on('message', () => {
        messageEmitted = true
      })

      transport['handleData']('\n\n\n')

      expect(messageEmitted).toBe(false)
    })

    test('should handle messages with extra whitespace', (done) => {
      const transport = new McpServerTransport()

      transport.on('message', (message: any) => {
        expect(message.method).toBe('test')
        done()
      })

      transport['handleData']('  \n  {"jsonrpc":"2.0","method":"test"}  \n  ')
    })
  })

  describe('Lifecycle', () => {
    test('should start listening for messages', () => {
      const transport = new McpServerTransport()

      // Should not throw
      transport.start()

      // Transport should be listening to stdin
      expect(process.stdin.listeners('data').length).toBeGreaterThan(0)
    })

    test('should stop listening for messages', () => {
      const transport = new McpServerTransport()

      transport.start()
      transport.stop()

      // stdin should be paused
      // Note: We can't easily test this without mocking process.stdin
    })
  })

  describe('Protocol Compliance', () => {
    test('should use correct JSON-RPC version', () => {
      const transport = new McpServerTransport()
      let sentMessage: any = null

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        sentMessage = JSON.parse(data.trim())
        return true
      }) as any

      transport.sendResponse(1, {})

      expect(sentMessage.jsonrpc).toBe('2.0')

      process.stdout.write = originalWrite
    })

    test('should include message ID in responses', () => {
      const transport = new McpServerTransport()
      let sentMessage: any = null

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        sentMessage = JSON.parse(data.trim())
        return true
      }) as any

      transport.sendResponse(42, {})

      expect(sentMessage.id).toBe(42)

      process.stdout.write = originalWrite
    })

    test('should handle string and numeric IDs', () => {
      const transport = new McpServerTransport()
      const messages: any[] = []

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        messages.push(JSON.parse(data.trim()))
        return true
      }) as any

      transport.sendResponse(1, {})
      transport.sendResponse('test-id', {})

      expect(messages[0].id).toBe(1)
      expect(messages[1].id).toBe('test-id')

      process.stdout.write = originalWrite
    })

    test('should use standard error codes', () => {
      const transport = new McpServerTransport()
      const messages: any[] = []

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        messages.push(JSON.parse(data.trim()))
        return true
      }) as any

      // Test standard error codes
      transport.sendError(1, -32700, 'Parse error')
      transport.sendError(2, -32600, 'Invalid Request')
      transport.sendError(3, -32601, 'Method not found')
      transport.sendError(4, -32602, 'Invalid params')
      transport.sendError(5, -32603, 'Internal error')

      expect(messages[0].error.code).toBe(-32700)
      expect(messages[1].error.code).toBe(-32600)
      expect(messages[2].error.code).toBe(-32601)
      expect(messages[3].error.code).toBe(-32602)
      expect(messages[4].error.code).toBe(-32603)

      process.stdout.write = originalWrite
    })
  })

  describe('Integration', () => {
    test('should handle complete request-response cycle', (done) => {
      const transport = new McpServerTransport()
      let receivedRequest = false
      let sentResponse = false

      transport.on('message', (message: any) => {
        receivedRequest = true
        expect(message.method).toBe('test/method')
        expect(message.params).toEqual({ arg: 'value' })

        // Send response
        transport.sendResponse(message.id, { result: 'success' })
      })

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        const msg = JSON.parse(data.trim())
        if (msg.result) {
          sentResponse = true
          expect(msg.result).toEqual({ result: 'success' })
          expect(receivedRequest).toBe(true)
          process.stdout.write = originalWrite
          done()
        }
        return true
      }) as any

      transport['handleData']('{"jsonrpc":"2.0","id":1,"method":"test/method","params":{"arg":"value"}}\n')
    })

    test('should handle error response cycle', (done) => {
      const transport = new McpServerTransport()

      transport.on('message', (message: any) => {
        // Send error response
        transport.sendError(message.id, -32601, 'Method not found')
      })

      const originalWrite = process.stdout.write
      process.stdout.write = ((data: string) => {
        const msg = JSON.parse(data.trim())
        if (msg.error) {
          expect(msg.error.code).toBe(-32601)
          expect(msg.error.message).toBe('Method not found')
          process.stdout.write = originalWrite
          done()
        }
        return true
      }) as any

      transport['handleData']('{"jsonrpc":"2.0","id":1,"method":"unknown","params":{}}\n')
    })
  })
})
