// generated by polka.codes

import type { Logger } from '@polka-codes/core'
import { McpServerTransport } from './transport'
import type { McpServerConfig, McpServerResource, McpServerTool } from './types'

/**
 * MCP Server implementation
 * Exposes polka-codes tools and resources via MCP protocol
 */
export class McpServer {
  private transport: McpServerTransport
  private tools = new Map<string, McpServerTool>()
  private resources = new Map<string, McpServerResource>()
  private initialized = false

  constructor(
    private readonly config: McpServerConfig,
    private readonly logger?: Logger,
  ) {
    this.transport = new McpServerTransport()
    this.setupHandlers()
  }

  /**
   * Register a tool with the MCP server
   */
  registerTool(tool: McpServerTool): void {
    this.tools.set(tool.name, tool)
    if (this.logger) {
      this.logger.debug(`Registered MCP tool: ${tool.name}`)
    }
  }

  /**
   * Register multiple tools
   */
  registerTools(tools: McpServerTool[]): void {
    for (const tool of tools) {
      this.registerTool(tool)
    }
  }

  /**
   * Register a resource with the MCP server
   */
  registerResource(resource: McpServerResource): void {
    this.resources.set(resource.uri, resource)
    if (this.logger) {
      this.logger.debug(`Registered MCP resource: ${resource.uri}`)
    }
  }

  /**
   * Register multiple resources
   */
  registerResources(resources: McpServerResource[]): void {
    for (const resource of resources) {
      this.registerResource(resource)
    }
  }

  /**
   * Start the MCP server
   */
  async start(): Promise<void> {
    this.transport.start()

    if (this.logger) {
      this.logger.info(`MCP Server started: ${this.config.serverInfo.name} v${this.config.serverInfo.version}`)
    }
  }

  /**
   * Stop the MCP server
   */
  async stop(): Promise<void> {
    this.transport.stop()

    if (this.logger) {
      this.logger.info('MCP Server stopped')
    }
  }

  /**
   * Setup message handlers
   */
  private setupHandlers(): void {
    this.transport.on('message', async (message: any) => {
      try {
        await this.handleMessage(message)
      } catch (error) {
        if (this.logger) {
          this.logger.error(`Error handling MCP message: ${error}`)
        }
        if (message.id !== undefined) {
          this.transport.sendError(message.id, -32603, 'Internal error', error instanceof Error ? error.message : String(error))
        }
      }
    })

    this.transport.on('error', (error: Error) => {
      if (this.logger) {
        this.logger.error(`MCP transport error: ${error.message}`)
      }
    })
  }

  /**
   * Handle incoming MCP message
   */
  private async handleMessage(message: any): Promise<void> {
    const { id, method, params } = message

    // Handle requests (with id)
    if (id !== undefined) {
      await this.handleRequest(id, method, params)
      return
    }

    // Handle notifications (no id)
    if (method) {
      await this.handleNotification(method, params)
    }
  }

  /**
   * Handle MCP request
   */
  private async handleRequest(id: number | string, method: string, params: any): Promise<void> {
    switch (method) {
      case 'initialize':
        await this.handleInitialize(id, params)
        break

      case 'tools/list':
        await this.handleToolsList(id)
        break

      case 'tools/call':
        await this.handleToolsCall(id, params)
        break

      case 'resources/list':
        await this.handleResourcesList(id)
        break

      case 'resources/read':
        await this.handleResourcesRead(id, params)
        break

      case 'prompts/list':
        await this.handlePromptsList(id)
        break

      default:
        this.transport.sendError(id, -32601, `Method not found: ${method}`)
    }
  }

  /**
   * Handle MCP notification
   */
  private async handleNotification(method: string, _params: any): Promise<void> {
    switch (method) {
      case 'notifications/initialized':
        this.initialized = true
        if (this.logger) {
          this.logger.info('MCP client initialized')
        }
        break

      case 'notifications/cancelled':
        if (this.logger) {
          this.logger.warn('Request cancelled by client')
        }
        break

      default:
        if (this.logger) {
          this.logger.debug(`Unhandled notification: ${method}`)
        }
    }
  }

  /**
   * Handle initialize request
   */
  private async handleInitialize(id: number | string, params: any): Promise<void> {
    const { protocolVersion, clientInfo } = params

    if (this.logger) {
      this.logger.info(`MCP client connected: ${clientInfo?.name} ${clientInfo?.version} (protocol: ${protocolVersion})`)
    }

    this.transport.sendResponse(id, {
      protocolVersion: '2024-11-05',
      capabilities: this.config.capabilities,
      serverInfo: this.config.serverInfo,
    })
  }

  /**
   * Handle tools/list request
   */
  private async handleToolsList(id: number | string): Promise<void> {
    const tools = Array.from(this.tools.values()).map((tool) => ({
      name: tool.name,
      description: tool.description,
      inputSchema: tool.inputSchema,
    }))

    this.transport.sendResponse(id, { tools })
  }

  /**
   * Handle tools/call request
   */
  private async handleToolsCall(id: number | string, params: any): Promise<void> {
    const { name, arguments: args } = params

    const tool = this.tools.get(name)
    if (!tool) {
      this.transport.sendError(id, -32602, `Tool not found: ${name}`)
      return
    }

    try {
      const result = await tool.handler(args || {})

      this.transport.sendResponse(id, {
        content: [
          {
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
          },
        ],
      })
    } catch (error) {
      // Per MCP protocol spec, tool errors should be returned in the response
      // with isError: true, not as JSON-RPC errors. The client checks this flag
      // to determine if the tool execution failed.
      const errorMessage = error instanceof Error ? error.message : String(error)
      this.transport.sendResponse(id, {
        content: [
          {
            type: 'text',
            text: `Error: ${errorMessage}`,
          },
        ],
        isError: true,
      })
    }
  }

  /**
   * Handle resources/list request
   */
  private async handleResourcesList(id: number | string): Promise<void> {
    const resources = Array.from(this.resources.values()).map((resource) => ({
      uri: resource.uri,
      name: resource.name,
      description: resource.description,
      mimeType: resource.mimeType,
    }))

    this.transport.sendResponse(id, { resources })
  }

  /**
   * Handle resources/read request
   */
  private async handleResourcesRead(id: number | string, params: any): Promise<void> {
    const { uri } = params

    const resource = this.resources.get(uri)
    if (!resource) {
      this.transport.sendError(id, -32602, `Resource not found: ${uri}`)
      return
    }

    try {
      const content = await resource.handler()

      this.transport.sendResponse(id, {
        contents: [
          {
            uri,
            mimeType: resource.mimeType || 'text/plain',
            text: content,
          },
        ],
      })
    } catch (error) {
      this.transport.sendError(id, -32603, 'Failed to read resource', error instanceof Error ? error.message : String(error))
    }
  }

  /**
   * Handle prompts/list request
   */
  private async handlePromptsList(id: number | string): Promise<void> {
    // Prompts not yet implemented
    this.transport.sendResponse(id, { prompts: [] })
  }

  /**
   * Get registered tools count
   */
  getToolsCount(): number {
    return this.tools.size
  }

  /**
   * Get registered resources count
   */
  getResourcesCount(): number {
    return this.resources.size
  }

  /**
   * Check if server is initialized
   */
  isInitialized(): boolean {
    return this.initialized
  }
}
