// generated by polka.codes

import type { Logger } from '@polka-codes/core'
import { McpServerTransport } from './transport'
import type { McpServerConfig, McpServerResource, McpServerTool } from './types'

/**
 * Default rate limit: requests per minute per client
 */
const DEFAULT_RATE_LIMIT = 60

/**
 * Rate limit window in milliseconds
 */
const RATE_LIMIT_WINDOW = 60 * 1000 // 1 minute

/**
 * MCP Server implementation
 * Exposes polka-codes tools and resources via MCP protocol
 */
export class McpServer {
  private transport: McpServerTransport
  private tools = new Map<string, McpServerTool>()
  private resources = new Map<string, McpServerResource>()
  private initialized = false
  private requestCounts = new Map<string, { count: number; resetTime: number }>()

  constructor(
    private readonly config: McpServerConfig,
    private readonly logger?: Logger,
  ) {
    this.transport = new McpServerTransport()
    this.setupHandlers()
  }

  /**
   * Register a tool with the MCP server
   */
  registerTool(tool: McpServerTool): void {
    this.tools.set(tool.name, tool)
    if (this.logger) {
      this.logger.debug(`Registered MCP tool: ${tool.name}`)
    }
  }

  /**
   * Register multiple tools
   */
  registerTools(tools: McpServerTool[]): void {
    for (const tool of tools) {
      this.registerTool(tool)
    }
  }

  /**
   * Register a resource with the MCP server
   */
  registerResource(resource: McpServerResource): void {
    this.resources.set(resource.uri, resource)
    if (this.logger) {
      this.logger.debug(`Registered MCP resource: ${resource.uri}`)
    }
  }

  /**
   * Register multiple resources
   */
  registerResources(resources: McpServerResource[]): void {
    for (const resource of resources) {
      this.registerResource(resource)
    }
  }

  /**
   * Start the MCP server
   */
  async start(): Promise<void> {
    this.transport.start()

    if (this.logger) {
      this.logger.info(`MCP Server started: ${this.config.serverInfo.name} v${this.config.serverInfo.version}`)
    }
  }

  /**
   * Stop the MCP server
   */
  async stop(): Promise<void> {
    this.transport.stop()

    if (this.logger) {
      this.logger.info('MCP Server stopped')
    }
  }

  /**
   * Setup message handlers
   */
  private setupHandlers(): void {
    this.transport.on('message', async (message: any) => {
      try {
        await this.handleMessage(message)
      } catch (error) {
        // Log detailed error locally for debugging
        if (this.logger) {
          this.logger.error(`Error handling MCP message: ${error instanceof Error ? error.stack : String(error)}`)
        }
        // Send sanitized error to client (don't leak implementation details)
        if (message.id !== undefined) {
          this.transport.sendError(message.id, -32603, 'Internal error')
        }
      }
    })

    this.transport.on('error', (error: Error) => {
      // Log error locally
      if (this.logger) {
        this.logger.error(`MCP transport error: ${error.message}`)
      }
    })
  }

  /**
   * Check if client has exceeded rate limit
   *
   * Note: Uses Date.now() for rate limit windows which is appropriate for
   * this use case. The rate limit is per-minute wall-clock time, not monotonic time.
   * System time changes could temporarily affect rate limiting but will self-correct.
   */
  private checkRateLimit(clientId: string): boolean {
    const now = Date.now()
    const clientState = this.requestCounts.get(clientId)

    // Reset window if expired
    if (clientState && now > clientState.resetTime) {
      this.requestCounts.set(clientId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
      return true
    }

    // Initialize new client
    if (!clientState) {
      this.requestCounts.set(clientId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
      return true
    }

    // Check limit
    if (clientState.count >= DEFAULT_RATE_LIMIT) {
      if (this.logger) {
        this.logger.warn(`MCP rate limit exceeded for client '${clientId}'`)
      }
      return false
    }

    // Increment counter
    clientState.count++
    return true
  }

  /**
   * Handle incoming MCP message
   */
  private async handleMessage(message: any): Promise<void> {
    const { id, method, params } = message

    // Check rate limit for requests
    // Note: Using 'default' as a global client ID since stdio transport typically serves one client.
    // For transports with multiple clients, consider using client-specific IDs from the transport layer.
    if (id !== undefined && !this.checkRateLimit('default')) {
      this.transport.sendError(id, -32603, 'Rate limit exceeded')
      return
    }

    // Handle requests (with id)
    if (id !== undefined) {
      await this.handleRequest(id, method, params)
      return
    }

    // Handle notifications (no id)
    if (method) {
      await this.handleNotification(method, params)
    }
  }

  /**
   * Handle MCP request
   */
  private async handleRequest(id: number | string, method: string, params: any): Promise<void> {
    switch (method) {
      case 'initialize':
        await this.handleInitialize(id, params)
        break

      case 'tools/list':
        await this.handleToolsList(id)
        break

      case 'tools/call':
        await this.handleToolsCall(id, params)
        break

      case 'resources/list':
        await this.handleResourcesList(id)
        break

      case 'resources/read':
        await this.handleResourcesRead(id, params)
        break

      case 'prompts/list':
        await this.handlePromptsList(id)
        break

      default:
        this.transport.sendError(id, -32601, `Method not found: ${method}`)
    }
  }

  /**
   * Handle MCP notification
   */
  private async handleNotification(method: string, _params: any): Promise<void> {
    switch (method) {
      case 'notifications/initialized':
        this.initialized = true
        if (this.logger) {
          this.logger.info('MCP client initialized')
        }
        break

      case 'notifications/cancelled':
        if (this.logger) {
          this.logger.warn('Request cancelled by client')
        }
        break

      default:
        if (this.logger) {
          this.logger.debug(`Unhandled notification: ${method}`)
        }
    }
  }

  /**
   * Handle initialize request
   */
  private async handleInitialize(id: number | string, params: any): Promise<void> {
    const { protocolVersion, clientInfo } = params

    if (this.logger) {
      this.logger.info(`MCP client connected: ${clientInfo?.name} ${clientInfo?.version} (protocol: ${protocolVersion})`)
    }

    this.transport.sendResponse(id, {
      protocolVersion: '2024-11-05',
      capabilities: this.config.capabilities,
      serverInfo: this.config.serverInfo,
    })
  }

  /**
   * Handle tools/list request
   */
  private async handleToolsList(id: number | string): Promise<void> {
    const tools = Array.from(this.tools.values()).map((tool) => ({
      name: tool.name,
      description: tool.description,
      inputSchema: tool.inputSchema,
    }))

    this.transport.sendResponse(id, { tools })
  }

  /**
   * Handle tools/call request
   */
  private async handleToolsCall(id: number | string, params: any): Promise<void> {
    const { name, arguments: args } = params

    // Validate tool name exists
    if (!name || typeof name !== 'string') {
      this.transport.sendError(id, -32602, 'Invalid tool name')
      return
    }

    const tool = this.tools.get(name)
    if (!tool) {
      this.transport.sendError(id, -32602, 'Tool not found')
      return
    }

    // Validate arguments
    if (args !== undefined && typeof args !== 'object') {
      this.transport.sendError(id, -32602, 'Invalid arguments format')
      return
    }

    try {
      const result = await tool.handler(args || {})

      this.transport.sendResponse(id, {
        content: [
          {
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
          },
        ],
      })
    } catch (error) {
      // Log detailed error locally
      if (this.logger) {
        this.logger.error(`Tool '${name}' execution failed: ${error instanceof Error ? error.stack : String(error)}`)
      }

      // Per MCP protocol spec, tool errors should be returned in the response
      // with isError: true, not as JSON-RPC errors. The client checks this flag
      // to determine if the tool execution failed.
      // Send sanitized error message (don't leak internal details)
      this.transport.sendResponse(id, {
        content: [
          {
            type: 'text',
            text: 'Tool execution failed',
          },
        ],
        isError: true,
      })
    }
  }

  /**
   * Handle resources/list request
   */
  private async handleResourcesList(id: number | string): Promise<void> {
    const resources = Array.from(this.resources.values()).map((resource) => ({
      uri: resource.uri,
      name: resource.name,
      description: resource.description,
      mimeType: resource.mimeType,
    }))

    this.transport.sendResponse(id, { resources })
  }

  /**
   * Handle resources/read request
   */
  private async handleResourcesRead(id: number | string, params: any): Promise<void> {
    const { uri } = params

    const resource = this.resources.get(uri)
    if (!resource) {
      this.transport.sendError(id, -32602, `Resource not found: ${uri}`)
      return
    }

    try {
      const content = await resource.handler()

      this.transport.sendResponse(id, {
        contents: [
          {
            uri,
            mimeType: resource.mimeType || 'text/plain',
            text: content,
          },
        ],
      })
    } catch (error) {
      this.transport.sendError(id, -32603, 'Failed to read resource', error instanceof Error ? error.message : String(error))
    }
  }

  /**
   * Handle prompts/list request
   */
  private async handlePromptsList(id: number | string): Promise<void> {
    // Prompts not yet implemented
    this.transport.sendResponse(id, { prompts: [] })
  }

  /**
   * Get registered tools count
   */
  getToolsCount(): number {
    return this.tools.size
  }

  /**
   * Get registered resources count
   */
  getResourcesCount(): number {
    return this.resources.size
  }

  /**
   * Check if server is initialized
   */
  isInitialized(): boolean {
    return this.initialized
  }

  /**
   * Get server state (for testing)
   */
  getState() {
    return {
      config: this.config,
      transport: this.transport,
      tools: this.tools,
      resources: this.resources,
      initialized: this.initialized,
      requestCounts: this.requestCounts,
    }
  }
}
