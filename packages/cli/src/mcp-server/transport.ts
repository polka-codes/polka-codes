// generated by polka.codes

import { EventEmitter } from 'node:events'

/**
 * Maximum buffer size to prevent memory exhaustion
 */
const MAX_BUFFER_SIZE = 10 * 1024 * 1024 // 10MB

/**
 * Maximum individual message size
 */
const MAX_MESSAGE_SIZE = 10 * 1024 * 1024 // 10MB

/**
 * Server-side transport for MCP protocol (stdio)
 * Handles incoming requests and sends responses
 */
export class McpServerTransport extends EventEmitter {
  private buffer = ''

  constructor() {
    super()
    this.setupStdio()
  }

  /**
   * Setup stdio for communication with MCP client
   */
  private setupStdio(): void {
    // Listen for messages from stdin
    process.stdin.setEncoding('utf-8')
    process.stdin.on('data', (data: string) => {
      this.handleData(data.toString())
    })

    // Handle stdin errors
    process.stdin.on('error', (error: Error) => {
      this.emit('error', error)
    })
  }

  /**
   * Handle incoming data from stdin
   * Supports both Content-Length header framing and newline-delimited messages
   */
  private handleData(data: string): void {
    // Prevent buffer from growing indefinitely
    if (this.buffer.length + data.length > MAX_BUFFER_SIZE) {
      this.emit('error', new Error(`Message too large (exceeds ${MAX_BUFFER_SIZE} bytes)`))
      this.buffer = ''
      return
    }

    this.buffer += data

    // Try to parse messages using Content-Length framing first
    while (this.buffer.length > 0) {
      // Check for Content-Length header format (not anchored to start for robustness)
      const contentLengthMatch = this.buffer.match(/Content-Length:\s*(\d+)\r?\n\r?\n/i)

      if (contentLengthMatch) {
        const contentLength = Number.parseInt(contentLengthMatch[1], 10)

        // Check content length against maximum
        if (contentLength > MAX_MESSAGE_SIZE) {
          this.emit('error', new Error(`Message size ${contentLength} exceeds maximum ${MAX_MESSAGE_SIZE}`))
          this.buffer = ''
          return
        }

        const matchStart = contentLengthMatch.index ?? 0
        const headerEnd = matchStart + contentLengthMatch[0].length
        const totalLength = headerEnd + contentLength

        // If we have enough data, extract the message
        if (this.buffer.length >= totalLength) {
          // Skip any data before the header
          if (matchStart > 0) {
            this.buffer = this.buffer.slice(matchStart)
          }

          const messageData = this.buffer.slice(contentLengthMatch[0].length, contentLengthMatch[0].length + contentLength)
          this.buffer = this.buffer.slice(totalLength - matchStart)

          try {
            const message = JSON.parse(messageData)
            this.emit('message', message)
          } catch (_error) {
            this.emit('error', new Error(`Failed to parse message: ${messageData}`))
          }
          continue
        } else {
          // Need more data
          break
        }
      }

      // Fall back to newline-delimited parsing (for compatibility)
      const newlineIndex = this.buffer.indexOf('\n')
      if (newlineIndex !== -1) {
        const line = this.buffer.slice(0, newlineIndex)
        this.buffer = this.buffer.slice(newlineIndex + 1)

        if (!line.trim()) continue

        try {
          const message = JSON.parse(line)
          this.emit('message', message)
        } catch (_error) {
          this.emit('error', new Error(`Failed to parse message: ${line}`))
        }
        continue
      }

      // No complete message found
      break
    }
  }

  /**
   * Send a response to the client
   */
  sendResponse(id: number | string, result: unknown): void {
    const response = {
      jsonrpc: '2.0',
      id,
      result,
    }
    this.sendMessage(response)
  }

  /**
   * Send an error response to the client
   */
  sendError(id: number | string, code: number, message: string, data?: unknown): void {
    const response = {
      jsonrpc: '2.0',
      id,
      error: {
        code,
        message,
        data,
      },
    }
    this.sendMessage(response)
  }

  /**
   * Send a notification to the client
   */
  sendNotification(method: string, params?: unknown): void {
    const notification = {
      jsonrpc: '2.0',
      method,
      params,
    }
    this.sendMessage(notification)
  }

  /**
   * Send a raw message to stdout
   */
  private sendMessage(message: Record<string, unknown>): void {
    const json = JSON.stringify(message)
    process.stdout.write(`${json}\n`)
  }

  /**
   * Start listening for messages
   */
  start(): void {
    // Already listening via setupStdio
  }

  /**
   * Stop listening for messages
   */
  stop(): void {
    process.stdin.pause()
  }
}
