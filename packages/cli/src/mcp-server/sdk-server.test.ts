// Unit tests for SDK-based MCP server
// generated by polka.codes

import { describe, expect, test } from 'bun:test'
import { z } from 'zod'
import { createPolkaCodesMcpServer } from './sdk-server'
import { createPolkaCodesServerTools } from './tools'
import type { McpServerTool } from './types'

// Mock logger
const mockLogger = {
  debug: () => {},
  info: () => {},
  warn: () => {},
  error: () => {},
}

// Mock tool context
const mockContext = {
  logger: mockLogger,
}

describe('SDK-based McpServer', () => {
  describe('Server Creation', () => {
    test('should create server with SDK', () => {
      const tools: McpServerTool[] = []
      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
      expect(server.isConnected()).toBe(false)
    })

    test('should have correct server info', () => {
      const tools: McpServerTool[] = []
      const server = createPolkaCodesMcpServer(tools, mockLogger)

      // Access underlying server to check info
      expect(server.server).toBeDefined()
    })

    test('should register tools successfully', () => {
      const tools: McpServerTool[] = [
        {
          name: 'test_tool',
          description: 'A test tool',
          inputSchema: z.object({
            arg1: z.string(),
          }),
          handler: async (args, _context) => {
            return { result: args }
          },
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
      expect(server.isConnected()).toBe(false)
    })

    test('should register multiple tools', () => {
      const tools: McpServerTool[] = [
        {
          name: 'tool1',
          description: 'Tool 1',
          inputSchema: z.object({}),
          handler: async (_args, _context) => ({ result: 'tool1' }),
        },
        {
          name: 'tool2',
          description: 'Tool 2',
          inputSchema: z.object({}),
          handler: async (_args, _context) => ({ result: 'tool2' }),
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should handle tool with complex input schema', () => {
      const tools: McpServerTool[] = [
        {
          name: 'complex_tool',
          description: 'Tool with complex schema',
          inputSchema: z.object({
            string: z.string(),
            number: z.number(),
            boolean: z.boolean(),
            array: z.array(z.string()),
            object: z.object({
              nested: z.string(),
            }),
          }),
          handler: async (args, _context) => args,
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })
  })

  describe('Tool Handler Behavior', () => {
    test('should create tool handler that returns valid MCP response', async () => {
      const tools: McpServerTool[] = [
        {
          name: 'echo',
          description: 'Echo back arguments',
          inputSchema: z.object({
            message: z.string(),
          }),
          handler: async (args, _context) => {
            return { echoed: args.message }
          },
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should create tool handler that stringifies object results', async () => {
      const tools: McpServerTool[] = [
        {
          name: 'object_result',
          description: 'Returns object',
          inputSchema: z.object({}),
          handler: async (_args, _context) => {
            return { key: 'value', nested: { prop: 123 } }
          },
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should create tool handler that handles string results', async () => {
      const tools: McpServerTool[] = [
        {
          name: 'string_result',
          description: 'Returns string',
          inputSchema: z.object({}),
          handler: async (_args, _context) => {
            return 'Plain string result'
          },
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should create tool handler that logs errors locally', async () => {
      const testLogger = {
        ...mockLogger,
        error: () => {},
      }

      const tools: McpServerTool[] = [
        {
          name: 'failing_tool',
          description: 'A tool that fails',
          inputSchema: z.object({}),
          handler: async (_args, _context) => {
            throw new Error('Tool execution failed')
          },
        },
      ]

      // Server should be created successfully with logger
      const server = createPolkaCodesMcpServer(tools, testLogger)

      expect(server).toBeDefined()
    })
  })

  describe('Tool Registration Edge Cases', () => {
    test('should handle tool with empty input schema', () => {
      const tools: McpServerTool[] = [
        {
          name: 'no_params',
          description: 'Tool with no parameters',
          inputSchema: z.object({}),
          handler: async (_args, _context) => ({ result: 'ok' }),
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should handle tool with no required parameters', () => {
      const tools: McpServerTool[] = [
        {
          name: 'optional_params',
          description: 'Tool with optional parameters',
          inputSchema: z.object({
            optional1: z.string().optional(),
            optional2: z.number().optional(),
          }),
          handler: async (args, _context) => args,
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should handle tool with nested properties', () => {
      const tools: McpServerTool[] = [
        {
          name: 'nested',
          description: 'Tool with nested properties',
          inputSchema: z.object({
            config: z.object({
              enabled: z.boolean(),
              name: z.string(),
            }),
          }),
          handler: async (args, _context) => args,
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should handle tool with array properties', () => {
      const tools: McpServerTool[] = [
        {
          name: 'array_tool',
          description: 'Tool with array properties',
          inputSchema: z.object({
            items: z.array(
              z.object({
                id: z.string(),
                value: z.number(),
              }),
            ),
          }),
          handler: async (args, _context) => args,
        },
      ]

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })
  })

  describe('Polka-Codes Tools', () => {
    test('should work with polka-codes server tools', () => {
      const tools = createPolkaCodesServerTools(mockLogger)

      expect(tools.length).toBeGreaterThan(0)

      const server = createPolkaCodesMcpServer(tools, mockLogger)

      expect(server).toBeDefined()
    })

    test('should register all polka-codes tools', () => {
      const tools = createPolkaCodesServerTools(mockLogger)

      const toolNames = tools.map((t: McpServerTool) => t.name)

      expect(toolNames).toContain('code')
      expect(toolNames).toContain('review')
      expect(toolNames).toContain('plan')
      expect(toolNames).toContain('fix')
      expect(toolNames).toContain('commit')
    })
  })

  describe('Error Handling', () => {
    test('should warn but not throw for invalid tool name', () => {
      // SDK warns but doesn't throw for empty tool names
      const invalidTool: McpServerTool = {
        name: '', // Invalid: empty name
        description: 'Invalid tool',
        inputSchema: z.object({}),
        handler: async (_args, _context) => ({}),
      }

      expect(() => {
        const server = createPolkaCodesMcpServer([invalidTool], mockLogger)
        expect(server).toBeDefined()
      }).not.toThrow()
    })

    test('should not throw if handler throws during execution', () => {
      const tools: McpServerTool[] = [
        {
          name: 'throws_error',
          description: 'Tool that throws',
          inputSchema: z.object({}),
          handler: async (_args, _context) => {
            throw new Error('Handler error')
          },
        },
      ]

      // Server creation should succeed (handler is not called during registration)
      expect(() => {
        const server = createPolkaCodesMcpServer(tools, mockLogger)
        expect(server).toBeDefined()
      }).not.toThrow()
    })
  })

  describe('Logger Integration', () => {
    test('should work without logger', () => {
      const tools: McpServerTool[] = [
        {
          name: 'test',
          description: 'Test tool',
          inputSchema: z.object({}),
          handler: async (_args, _context) => ({ result: 'ok' }),
        },
      ]

      expect(() => {
        const server = createPolkaCodesMcpServer(tools)
        expect(server).toBeDefined()
      }).not.toThrow()
    })

    test('should use logger for registration debug messages', () => {
      let debugCalled = false
      const testLogger = {
        ...mockLogger,
        debug: () => {
          debugCalled = true
        },
      }

      const tools: McpServerTool[] = [
        {
          name: 'test',
          description: 'Test tool',
          inputSchema: z.object({}),
          handler: async (_args, _context) => ({ result: 'ok' }),
        },
      ]

      createPolkaCodesMcpServer(tools, testLogger)

      expect(debugCalled).toBe(true)
    })

    test('should use logger for error messages', () => {
      let errorCalled = false
      const testLogger = {
        ...mockLogger,
        error: () => {
          errorCalled = true
        },
      }

      const tools: McpServerTool[] = [
        {
          name: 'test',
          description: 'Test tool',
          inputSchema: z.object({}),
          handler: async (_args, _context) => ({ result: 'ok' }),
        },
      ]

      // This should not throw, and error logger should not be called during successful registration
      expect(() => {
        createPolkaCodesMcpServer(tools, testLogger)
      }).not.toThrow()

      expect(errorCalled).toBe(false)
    })
  })

  describe('Provider Override Support', () => {
    test('should create server with default provider config', () => {
      const tools: McpServerTool[] = [
        {
          name: 'test',
          description: 'Test tool',
          inputSchema: z.object({}),
          handler: async (_args, context) => {
            // Context should contain defaultProvider
            expect(context).toBeDefined()
            expect(context.logger).toBeDefined()
            return { result: 'ok' }
          },
        },
      ]

      const defaultProvider = {
        provider: 'anthropic',
        model: 'claude-sonnet-4-5',
      }

      const server = createPolkaCodesMcpServer(tools, mockLogger, defaultProvider)

      expect(server).toBeDefined()
    })

    test('should pass default provider to tool context', () => {
      const tools: McpServerTool[] = [
        {
          name: 'test',
          description: 'Test tool',
          inputSchema: z.object({}),
          handler: async (_args, context) => {
            expect(context.defaultProvider).toBeDefined()
            expect(context.defaultProvider?.provider).toBe('deepseek')
            expect(context.defaultProvider?.model).toBe('deepseek-chat')
            return { result: 'ok' }
          },
        },
      ]

      const defaultProvider = {
        provider: 'deepseek',
        model: 'deepseek-chat',
      }

      const server = createPolkaCodesMcpServer(tools, mockLogger, defaultProvider)

      expect(server).toBeDefined()
    })
  })
})
