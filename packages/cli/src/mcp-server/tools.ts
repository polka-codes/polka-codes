// generated by polka.codes

import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
import type { Logger, WorkflowFn } from '@polka-codes/core'
import { z } from 'zod'
import { commit } from '../api'
import { runWorkflow } from '../runWorkflow'
import type { CliToolRegistry } from '../workflow-tools'
import { codeWorkflow } from '../workflows/code.workflow'
import { fixWorkflow } from '../workflows/fix.workflow'
import { planWorkflow } from '../workflows/plan.workflow'
import { reviewWorkflow } from '../workflows/review.workflow'
import type { BaseWorkflowInput } from '../workflows/workflow.utils'
import type { McpServerTool } from './types'

// Get the project root directory (assuming we're in packages/cli/src/mcp-server)
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '../../../..')

/**
 * Create a minimal execution context for running workflows from MCP server
 */
function createExecutionContext(_logger: Logger) {
  return {
    // Set working directory to project root
    cwd: projectRoot,
    // Default to non-interactive mode for MCP
    yes: true,
    // Verbose logging - default to 0 (can be enhanced if needed)
    verbose: 0,
    // No file specified
    file: undefined,
  }
}

/**
 * Helper to run a workflow and format the result for MCP response
 */
async function executeWorkflow<TInput>(
  workflow: WorkflowFn<TInput & BaseWorkflowInput, unknown, CliToolRegistry>,
  input: TInput,
  commandName: string,
  logger: Logger,
): Promise<string> {
  try {
    const context = createExecutionContext(logger)

    // Add default values for BaseWorkflowInput properties
    const workflowInput = {
      ...input,
      interactive: false,
      additionalTools: {},
    } as TInput & BaseWorkflowInput

    const result = await runWorkflow(workflow, workflowInput, {
      commandName,
      context,
      logger,
      requiresProvider: true,
      interactive: false,
    })

    if (!result) {
      // Result is undefined - this could indicate an internal error in runWorkflow
      // that was caught and not re-thrown, or a workflow that completed with no output
      // Return an error to avoid masking potential failures
      return 'Error: Workflow returned no result (possible internal error or workflow produced no output)'
    }

    // Format the result based on its structure
    if (typeof result === 'string') {
      return result
    } else if (result && typeof result === 'object') {
      // Check if it's a workflow result object
      if ('success' in result) {
        if (result.success === true) {
          // Include summary, summaries, or output if available
          const workflowResult = result as { summary?: string; summaries?: string[]; output?: string }
          return (
            workflowResult.summary || workflowResult.summaries?.join('\n') || workflowResult.output || 'Workflow completed successfully'
          )
        } else {
          // Workflow failed
          const workflowResult = result as { reason?: string; error?: string }
          return `Error: ${workflowResult.reason || workflowResult.error || 'Workflow failed'}`
        }
      }
      // Generic object - stringify it
      return JSON.stringify(result, null, 2)
    }

    return 'Workflow completed'
  } catch (error) {
    logger.error(`Error executing ${commandName} workflow:`, error)
    return `Error: ${error instanceof Error ? error.message : String(error)}`
  }
}

/**
 * Create high-level polka-codes workflow tools for MCP server
 *
 * These tools integrate with the actual polka-codes workflows to enable
 * AI assistants (via MCP) to execute code tasks, reviews, planning, etc.
 */
export function createPolkaCodesServerTools(logger: Logger): McpServerTool[] {
  return [
    {
      name: 'code',
      description: `Execute a coding task using AI with comprehensive codebase analysis and modification capabilities.

The workflow will:
- Analyze the current codebase structure, patterns, and dependencies
- Understand existing conventions and architectural decisions
- Make targeted code changes to accomplish the specified task
- Ensure all changes compile and pass type checking
- Run and fix any failing tests
- Handle complex multi-file changes and refactoring
- Provide a detailed summary of changes made

Best used for implementing new features, refactoring existing code, fixing bugs across multiple files, adding tests, or code modernization.

Parameters:
- task (required): Detailed description of what needs to be implemented or changed`,
      inputSchema: z.object({
        task: z.string().describe('The coding task to execute - be specific about what needs to be done'),
      }),
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        logger.info(`MCP: Executing code workflow - task: "${task}"`)
        return await executeWorkflow(codeWorkflow, { task }, 'code', logger)
      },
    },
    {
      name: 'review',
      description: `Perform comprehensive code review with actionable, structured feedback.

This workflow can review:
- Uncommitted local changes (git diff)
- Branch comparisons (e.g., feature branch vs main)
- Specific git ranges (e.g., HEAD~3..HEAD, origin/main..HEAD)
- Pull requests from GitHub/GitLab by number

The review provides:
- Code quality and style analysis
- Bug identification and potential issues
- Security and performance concerns
- Improvement suggestions with examples
- Best practices compliance feedback
- Documentation review

Output is structured with:
- Categorized feedback (bugs, style, performance, etc.)
- Specific file/line references
- Severity levels (critical, major, minor, nitpick)
- Actionable recommendations

Parameters:
- pr (optional): Pull request number to review
- range (optional): Git range to review (e.g., HEAD~3..HEAD, origin/main..HEAD)
- files (optional): Specific files to review
- context (optional): Additional context about the changes (purpose, constraints, technical background)`,
      inputSchema: z.object({
        pr: z.number().optional().describe('Pull request number to review (optional)'),
        range: z.string().optional().describe('Git range to review (e.g., HEAD~3..HEAD, origin/main..HEAD) (optional)'),
        files: z.array(z.string()).optional().describe('Specific files to review (optional)'),
        context: z
          .string()
          .optional()
          .describe('Additional context for the review - explains the purpose of changes, constraints, or areas of focus (optional)'),
      }),
      handler: async (args: Record<string, unknown>) => {
        const { pr, range, files, context } = args as { pr?: number; range?: string; files?: string[]; context?: string }
        logger.info(`MCP: Executing review workflow${pr ? ` - PR: ${pr}` : ''}${range ? ` - range: ${range}` : ''}`)
        return await executeWorkflow(reviewWorkflow, { pr, range, files, context }, 'review', logger)
      },
    },
    {
      name: 'plan',
      description: `Create a detailed, actionable implementation plan for features or problems.

The workflow will:
- Analyze the current codebase to understand existing architecture
- Identify key files, dependencies, and potential challenges
- Create a step-by-step implementation roadmap
- Consider edge cases, error handling, and validation
- Suggest testing strategies and test cases
- Identify potential risks and mitigation approaches
- Recommend refactoring or preparatory work if needed

The plan includes:
- Overview with recommended approach
- Ordered list of implementation steps
- Files to create or modify (file paths only, no content)
- Dependencies and prerequisites
- Testing strategy
- Risk assessment and mitigations
- Rollback strategy if applicable

Best used for complex features, architecture changes, large refactorings, or migration strategies.

Parameters:
- task (required): Detailed description of what needs to be planned`,
      inputSchema: z.object({
        task: z.string().describe('The task or feature to plan - provide details about requirements, constraints, and goals'),
      }),
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        logger.info(`MCP: Executing plan workflow - task: "${task}"`)

        try {
          const context = createExecutionContext(logger)
          const result = await runWorkflow(
            planWorkflow,
            { task },
            {
              commandName: 'plan',
              context,
              logger,
              requiresProvider: true,
              interactive: false,
            },
          )

          // Format plan result for MCP response
          if (result && typeof result === 'object') {
            const planResult = result as {
              plan?: string
              question?: unknown
              reason?: string
              files?: Array<{ path: string; content: string }>
            }

            // If there's a question, return it
            if (planResult.question) {
              return JSON.stringify({ question: planResult.question }, null, 2)
            }

            // If there's a reason (no plan needed), return it
            if (planResult.reason) {
              return `No plan needed: ${planResult.reason}`
            }

            // Format the plan result with file paths only (no content)
            let output = ''
            if (planResult.plan) {
              output += planResult.plan
            }

            if (planResult.files && planResult.files.length > 0) {
              output += '\n\nFiles to modify:\n'
              // Extract only the file paths, not the content
              output += planResult.files.map((f) => `  - ${f.path}`).join('\n')
            }

            return output || 'Plan created successfully'
          }

          return 'Plan created successfully'
        } catch (error) {
          logger.error(`Error executing plan workflow:`, error)
          return `Error: ${error instanceof Error ? error.message : String(error)}`
        }
      },
    },
    {
      name: 'fix',
      description: `Diagnose and resolve issues, bugs, or test failures systematically.

The workflow will:
- Analyze error messages, stack traces, and failing tests
- Identify root causes through code examination
- Review relevant code and dependencies
- Implement targeted fixes with proper error handling
- Run tests to verify the fix
- Check for regressions in related functionality
- Iterate if the issue persists

Can handle:
- Test failures (unit, integration, e2e)
- Build and compilation errors
- Type checking errors
- Runtime errors and exceptions
- Logic bugs
- Performance issues
- Security vulnerabilities

Process:
1. Thoroughly analyze the failure or error
2. Identify and understand the root cause
3. Implement a minimal, targeted fix
4. Test to verify the fix works
5. Check for regressions
6. Iterate if needed until resolved

Parameters:
- task (required): Description of the issue - include error messages, stack traces, or describe what's not working`,
      inputSchema: z.object({
        task: z.string().describe("Description of the issue to fix - include error messages, stack traces, or describe what's not working"),
      }),
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        logger.info(`MCP: Executing fix workflow - task: "${task}"`)
        return await executeWorkflow(fixWorkflow, { task }, 'fix', logger)
      },
    },
    {
      name: 'commit',
      description: `Create a git commit with an AI-generated, well-formatted commit message.

The workflow will:
- Stage specified files (all files or specific files)
- Analyze the diff to understand what changed
- Generate a clear, descriptive commit message following best practices
- Create the commit with the generated message

Commit message format:
- Clear subject line (50 chars or less)
- Detailed body explaining what changed and why
- References to issues/PRs if applicable
- Conventional commits format when appropriate

Best practices followed:
- Separate subject from body with blank line
- Use imperative mood in subject line (e.g., "Add feature" not "Added feature")
- Explain what and why, not how
- Wrap body lines at 72 characters

Parameters:
- message (optional): Custom commit message. If not provided, AI analyzes changes and generates an appropriate message following best practices
- stageFiles (optional): Files to stage before committing. Use "all" to stage all files, or provide an array of specific file paths to stage`,
      inputSchema: z.object({
        message: z
          .string()
          .optional()
          .describe('Optional commit message - if not provided, AI will analyze changes and generate an appropriate message'),
        stageFiles: z
          .union([z.literal('all'), z.array(z.string())])
          .optional()
          .describe('Files to stage: "all" for all files, or array of specific file paths'),
      }),
      handler: async (args: Record<string, unknown>) => {
        const { message, stageFiles } = args as { message?: string; stageFiles?: 'all' | string[] }
        logger.info(
          `MCP: Executing commit workflow${message ? ` - message: "${message}"` : ''}${stageFiles ? ` - stageFiles: "${JSON.stringify(stageFiles)}"` : ''}`,
        )
        try {
          await commit({
            ...createExecutionContext(logger),
            context: message,
            all: stageFiles === 'all',
            files: Array.isArray(stageFiles) ? stageFiles : undefined,
            interactive: false,
          })
          return 'Commit created successfully'
        } catch (error) {
          return `Error: ${error instanceof Error ? error.message : String(error)}`
        }
      },
    },
  ]
}
