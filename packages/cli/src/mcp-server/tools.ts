// generated by polka.codes

import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
import type { Logger, ToolRegistry } from '@polka-codes/core'
import { commit, epic } from '../api'
import { runWorkflow } from '../runWorkflow'
import { codeWorkflow } from '../workflows/code.workflow'
import { fixWorkflow } from '../workflows/fix.workflow'
import { planWorkflow } from '../workflows/plan.workflow'
import { reviewWorkflow } from '../workflows/review.workflow'
import type { McpServerTool } from './types'

// Get the project root directory (assuming we're in packages/cli/src/mcp-server)
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '../../../..')

/**
 * Create a minimal execution context for running workflows from MCP server
 */
function createExecutionContext(_logger: Logger) {
  return {
    // Set working directory to project root
    cwd: projectRoot,
    // Default to non-interactive mode for MCP
    yes: true,
    // Verbose logging - default to 0 (can be enhanced if needed)
    verbose: 0,
    // No file specified
    file: undefined,
  }
}

/**
 * Helper to run a workflow and format the result for MCP response
 */
async function executeWorkflow<TInput, _TOutput>(workflow: any, input: TInput, commandName: string, logger: Logger): Promise<string> {
  try {
    const context = createExecutionContext(logger)

    const result = await runWorkflow(workflow, input, {
      commandName,
      context,
      logger,
      requiresProvider: true,
      interactive: false,
    })

    if (!result) {
      return 'Workflow completed with no output'
    }

    // Format the result based on its structure
    if (typeof result === 'string') {
      return result
    } else if (result && typeof result === 'object') {
      // Check if it's a workflow result object
      if ('success' in result) {
        if (result.success === true) {
          // Include summary, summaries, or output if available
          const workflowResult = result as any
          return (
            workflowResult.summary || workflowResult.summaries?.join('\n') || workflowResult.output || 'Workflow completed successfully'
          )
        } else {
          // Workflow failed
          const workflowResult = result as any
          return `Error: ${workflowResult.reason || workflowResult.error || 'Workflow failed'}`
        }
      }
      // Generic object - stringify it
      return JSON.stringify(result, null, 2)
    }

    return 'Workflow completed'
  } catch (error) {
    logger.error(`Error executing ${commandName} workflow:`, error)
    return `Error: ${error instanceof Error ? error.message : String(error)}`
  }
}

/**
 * Convert polka-codes tools to MCP server tools
 */
export function createMcpServerTools(tools: ToolRegistry): McpServerTool[] {
  const mcpTools: McpServerTool[] = []

  for (const [name] of Object.entries(tools)) {
    mcpTools.push({
      name,
      description: `Tool: ${name}`,
      inputSchema: {},
      handler: async (args: Record<string, unknown>) => {
        // This will be called when the tool is invoked via MCP
        // We'll need to integrate with the actual tool execution
        return JSON.stringify({ result: `Tool ${name} called with args: ${JSON.stringify(args)}` }, null, 2)
      },
    })
  }

  return mcpTools
}

/**
 * Create high-level polka-codes workflow tools for MCP server
 *
 * These tools integrate with the actual polka-codes workflows to enable
 * AI assistants (via MCP) to execute code tasks, reviews, planning, etc.
 */
export function createPolkaCodesServerTools(logger: Logger): McpServerTool[] {
  return [
    {
      name: 'code',
      description: 'Execute a coding task using AI. Analyzes the codebase, makes changes, and ensures tests pass.',
      inputSchema: {
        type: 'object',
        properties: {
          task: {
            type: 'string',
            description: 'The coding task to execute',
          },
          files: {
            type: 'array',
            items: {
              type: 'string',
            },
            description: 'Specific files to focus on (optional)',
          },
        },
        required: ['task'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { task, files } = args as { task: string; files?: string[] }
        logger.info(`MCP: Executing code workflow - task: "${task}"${files ? `, files: ${files.join(', ')}` : ''}`)
        return await executeWorkflow(codeWorkflow, { task, files }, 'code', logger)
      },
    },
    {
      name: 'review',
      description: 'Review code changes (local changes, branch diff, git range, or pull request)',
      inputSchema: {
        type: 'object',
        properties: {
          pr: {
            type: 'number',
            description: 'Pull request number to review (optional)',
          },
          range: {
            type: 'string',
            description: 'Git range to review (e.g., HEAD~3..HEAD, origin/main..HEAD) (optional)',
          },
          files: {
            type: 'array',
            items: {
              type: 'string',
            },
            description: 'Specific files to review (optional)',
          },
          context: {
            type: 'string',
            description: 'Additional context for the review (optional)',
          },
        },
        required: [],
      },
      handler: async (args: Record<string, unknown>) => {
        const { pr, range, files, context } = args as { pr?: number; range?: string; files?: string[]; context?: string }
        logger.info(`MCP: Executing review workflow${pr ? ` - PR: ${pr}` : ''}${range ? ` - range: ${range}` : ''}`)
        return await executeWorkflow(reviewWorkflow, { pr, range, files, context }, 'review', logger)
      },
    },
    {
      name: 'plan',
      description: 'Create a plan for implementing a feature or solving a problem',
      inputSchema: {
        type: 'object',
        properties: {
          task: {
            type: 'string',
            description: 'The task or feature to plan',
          },
        },
        required: ['task'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        logger.info(`MCP: Executing plan workflow - task: "${task}"`)
        return await executeWorkflow(planWorkflow, { task }, 'plan', logger)
      },
    },
    {
      name: 'fix',
      description: 'Fix issues, bugs, or test failures',
      inputSchema: {
        type: 'object',
        properties: {
          task: {
            type: 'string',
            description: 'Description of the issue to fix',
          },
        },
        required: ['task'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        logger.info(`MCP: Executing fix workflow - task: "${task}"`)
        return await executeWorkflow(fixWorkflow, { task }, 'fix', logger)
      },
    },
    {
      name: 'epic',
      description: 'Break down a large feature into smaller tasks and implement them',
      inputSchema: {
        type: 'object',
        properties: {
          epic: {
            type: 'string',
            description: 'Description of the epic to implement',
          },
        },
        required: ['epic'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { epic: epicTask } = args as { epic: string }
        logger.info(`MCP: Executing epic workflow - epic: "${epicTask}"`)
        try {
          await epic({
            ...createExecutionContext(logger),
            task: epicTask,
            interactive: false,
          })
          return 'Epic workflow completed successfully'
        } catch (error) {
          return `Error: ${error instanceof Error ? error.message : String(error)}`
        }
      },
    },
    {
      name: 'commit',
      description: 'Create a git commit with AI-generated message based on changes',
      inputSchema: {
        type: 'object',
        properties: {
          message: {
            type: 'string',
            description: 'Optional commit message (AI generates if not provided)',
          },
        },
        required: [],
      },
      handler: async (args: Record<string, unknown>) => {
        const { message } = args as { message?: string }
        logger.info(`MCP: Executing commit workflow${message ? ` - message: "${message}"` : ''}`)
        try {
          await commit({
            ...createExecutionContext(logger),
            context: message,
            interactive: false,
          })
          return 'Commit created successfully'
        } catch (error) {
          return `Error: ${error instanceof Error ? error.message : String(error)}`
        }
      },
    },
  ]
}
