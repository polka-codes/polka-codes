// generated by polka.codes

import type { ToolRegistry } from '@polka-codes/core'
import type { McpServerTool } from './types'

/**
 * Convert polka-codes tools to MCP server tools
 */
export function createMcpServerTools(tools: ToolRegistry): McpServerTool[] {
  const mcpTools: McpServerTool[] = []

  for (const [name] of Object.entries(tools)) {
    mcpTools.push({
      name,
      description: `Tool: ${name}`,
      inputSchema: {},
      handler: async (args: Record<string, unknown>) => {
        // This will be called when the tool is invoked via MCP
        // We'll need to integrate with the actual tool execution
        return JSON.stringify({ result: `Tool ${name} called with args: ${JSON.stringify(args)}` }, null, 2)
      },
    })
  }

  return mcpTools
}

/**
 * Create high-level polka-codes workflow tools for MCP server
 */
export function createPolkaCodesServerTools(): McpServerTool[] {
  return [
    {
      name: 'code',
      description: 'Execute a coding task using AI. Analyzes the codebase, makes changes, and ensures tests pass.',
      inputSchema: {
        type: 'object',
        properties: {
          task: {
            type: 'string',
            description: 'The coding task to execute',
          },
          files: {
            type: 'array',
            items: {
              type: 'string',
            },
            description: 'Specific files to focus on (optional)',
          },
        },
        required: ['task'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { task, files } = args as { task: string; files?: string[] }
        // This would integrate with the actual code workflow
        return JSON.stringify({ task, files, status: 'Workflow execution not yet implemented' }, null, 2)
      },
    },
    {
      name: 'review',
      description: 'Review code changes (local changes, branch diff, git range, or pull request)',
      inputSchema: {
        type: 'object',
        properties: {
          pr: {
            type: 'number',
            description: 'Pull request number to review (optional)',
          },
          range: {
            type: 'string',
            description: 'Git range to review (e.g., HEAD~3..HEAD, origin/main..HEAD) (optional)',
          },
          files: {
            type: 'array',
            items: {
              type: 'string',
            },
            description: 'Specific files to review (optional)',
          },
          context: {
            type: 'string',
            description: 'Additional context for the review (optional)',
          },
        },
        required: [],
      },
      handler: async (args: Record<string, unknown>) => {
        const { pr, range, files, context } = args as { pr?: number; range?: string; files?: string[]; context?: string }
        // This would integrate with the actual review workflow
        return JSON.stringify({ pr, range, files, context, status: 'Workflow execution not yet implemented' }, null, 2)
      },
    },
    {
      name: 'plan',
      description: 'Create a plan for implementing a feature or solving a problem',
      inputSchema: {
        type: 'object',
        properties: {
          task: {
            type: 'string',
            description: 'The task or feature to plan',
          },
        },
        required: ['task'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        // This would integrate with the actual plan workflow
        return JSON.stringify({ task, status: 'Workflow execution not yet implemented' }, null, 2)
      },
    },
    {
      name: 'fix',
      description: 'Fix issues, bugs, or test failures',
      inputSchema: {
        type: 'object',
        properties: {
          task: {
            type: 'string',
            description: 'Description of the issue to fix',
          },
        },
        required: ['task'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { task } = args as { task: string }
        // This would integrate with the actual fix workflow
        return JSON.stringify({ task, status: 'Workflow execution not yet implemented' }, null, 2)
      },
    },
    {
      name: 'epic',
      description: 'Break down a large feature into smaller tasks and implement them',
      inputSchema: {
        type: 'object',
        properties: {
          epic: {
            type: 'string',
            description: 'Description of the epic to implement',
          },
        },
        required: ['epic'],
      },
      handler: async (args: Record<string, unknown>) => {
        const { epic } = args as { epic: string }
        // This would integrate with the actual epic workflow
        return JSON.stringify({ epic, status: 'Workflow execution not yet implemented' }, null, 2)
      },
    },
    {
      name: 'commit',
      description: 'Create a git commit with AI-generated message based on changes',
      inputSchema: {
        type: 'object',
        properties: {
          message: {
            type: 'string',
            description: 'Optional commit message (AI generates if not provided)',
          },
        },
        required: [],
      },
      handler: async (args: Record<string, unknown>) => {
        const { message } = args as { message?: string }
        // This would integrate with the actual commit command
        return JSON.stringify({ message, status: 'Command execution not yet implemented' }, null, 2)
      },
    },
  ]
}
