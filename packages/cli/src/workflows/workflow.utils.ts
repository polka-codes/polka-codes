// generated by polka.codes

import { execSync } from 'node:child_process'
import { promises as fs } from 'node:fs'
import path from 'node:path'
import { listFiles, loadConfig, resolveRules } from '@polka-codes/cli-shared'
import type { FullToolInfo, Logger } from '@polka-codes/core'
import { z } from 'zod'
import { ApiProviderConfig } from '../ApiProviderConfig'
import type { CliToolRegistry } from '../workflow-tools'

export type BaseWorkflowInput = {
  interactive: boolean
  additionalTools: {
    search?: FullToolInfo
  }
}

export type FileChange = {
  path: string
  status: string
  insertions?: number
  deletions?: number
}

export function parseGitDiffNameStatus(diffOutput: string): FileChange[] {
  const lines = diffOutput.split('\n').filter((line) => line.trim())
  return lines.map((line) => {
    const [status, ...pathParts] = line.split('\t')
    const path = pathParts.join('\t')
    let statusDescription: string
    switch (status[0]) {
      case 'A':
        statusDescription = 'Added'
        break
      case 'M':
        statusDescription = 'Modified'
        break
      case 'D':
        statusDescription = 'Deleted'
        break
      case 'R':
        statusDescription = 'Renamed'
        break
      case 'C':
        statusDescription = 'Copied'
        break
      case 'T':
        statusDescription = 'Type changed'
        break
      default:
        statusDescription = 'Unknown'
    }
    return { path, status: statusDescription }
  })
}

export function printChangedFiles(logger: Logger, changedFiles: FileChange[]) {
  if (changedFiles.length === 0) {
    return
  }
  logger.info('Changed Files:')
  for (const file of changedFiles) {
    let statString = ''
    if (file.insertions !== undefined || file.deletions !== undefined) {
      const ins = file.insertions ?? 0
      const del = file.deletions ?? 0
      statString = ` (+${ins}/-${del})`
    }
    logger.info(`- ${file.status}: ${file.path}${statString}`)
  }
}

export function parseGitDiffNumStat(output: string): Record<string, { insertions: number; deletions: number }> {
  const stats: Record<string, { insertions: number; deletions: number }> = {}
  const lines = output.split('\n').filter((line) => line.trim())

  for (const line of lines) {
    const parts = line.split('\t')
    if (parts.length >= 3) {
      const insertions = parts[0] === '-' ? 0 : Number.parseInt(parts[0], 10)
      const deletions = parts[1] === '-' ? 0 : Number.parseInt(parts[1], 10)
      const path = unquotePath(parts.slice(2).join('\t'))

      stats[path] = { insertions, deletions }
    }
  }
  return stats
}

// unquotes path from git status --porcelain
// see: https://git-scm.com/docs/git-status#_changed_track_entries
const unquotePath = (path: string) => {
  if (path.startsWith('"') && path.endsWith('"')) {
    try {
      return JSON.parse(path)
    } catch {
      // if JSON.parse fails, return the original string
      return path
    }
  }
  return path
}

export function parseGitStatus(statusOutput: string): FileChange[] {
  const statusLines = statusOutput.split('\n').filter((line) => line)
  const files: FileChange[] = []

  for (const line of statusLines) {
    const indexStatus = line[0]
    const workingTreeStatus = line[1]
    const path = line.length > 3 ? unquotePath(line.slice(3)) : line

    const statuses = []
    if (indexStatus !== ' ' && indexStatus !== '?') {
      switch (indexStatus) {
        case 'A':
          statuses.push('Added (staged)')
          break
        case 'M':
          statuses.push('Modified (staged)')
          break
        case 'D':
          statuses.push('Deleted (staged)')
          break
        case 'R':
          statuses.push('Renamed (staged)')
          break
        case 'C':
          statuses.push('Copied (staged)')
          break
        default:
          statuses.push('Changed (staged)')
      }
    }
    if (workingTreeStatus !== ' ') {
      switch (workingTreeStatus) {
        case 'M':
          statuses.push('Modified (unstaged)')
          break
        case 'D':
          statuses.push('Deleted (unstaged)')
          break
        case '?':
          statuses.push('Untracked')
          break
        default:
          statuses.push('Changed (unstaged)')
      }
    }

    if (statuses.length > 0) {
      files.push({ path, status: statuses.join(', ') })
    }
  }

  return files
}

export function getLocalChanges() {
  const statusOutput = execSync('git status --porcelain=v1', {
    encoding: 'utf-8',
  })
  const allFiles = parseGitStatus(statusOutput)

  let stagedStats: Record<string, { insertions: number; deletions: number }> = {}
  try {
    const stagedDiffOutput = execSync('git diff --staged --numstat --no-color', { encoding: 'utf-8' })
    stagedStats = parseGitDiffNumStat(stagedDiffOutput)
  } catch {
    // Ignore error
  }

  let unstagedStats: Record<string, { insertions: number; deletions: number }> = {}
  try {
    const unstagedDiffOutput = execSync('git diff --numstat --no-color', { encoding: 'utf-8' })
    unstagedStats = parseGitDiffNumStat(unstagedDiffOutput)
  } catch {
    // Ignore error
  }

  const stagedFiles: FileChange[] = []
  const unstagedFiles: FileChange[] = []

  for (const file of allFiles) {
    let totalInsertions = 0
    let totalDeletions = 0

    if (file.status.includes('(staged)')) {
      const stats = stagedStats[file.path]
      const stagedFile = { ...file }
      if (stats) {
        stagedFile.insertions = stats.insertions
        stagedFile.deletions = stats.deletions
        totalInsertions += stats.insertions
        totalDeletions += stats.deletions
      }
      stagedFiles.push(stagedFile)
    }

    if (file.status.includes('(unstaged)')) {
      const stats = unstagedStats[file.path]
      const unstagedFile = { ...file }
      if (stats) {
        unstagedFile.insertions = stats.insertions
        unstagedFile.deletions = stats.deletions
        totalInsertions += stats.insertions
        totalDeletions += stats.deletions
      }
      unstagedFiles.push(unstagedFile)
    } else if (file.status.includes('Untracked')) {
      unstagedFiles.push(file)
    }

    if (totalInsertions > 0 || totalDeletions > 0) {
      file.insertions = totalInsertions
      file.deletions = totalDeletions
    }
  }

  return { stagedFiles, unstagedFiles, allFiles }
}

export function createFileStatusPrompt(changedFiles: FileChange[]): string {
  if (changedFiles.length === 0) {
    return ''
  }
  const fileList = changedFiles
    .map((file) => {
      let statString = ''
      if (file.insertions !== undefined || file.deletions !== undefined) {
        const ins = file.insertions ?? 0
        const del = file.deletions ?? 0
        statString = ` (+${ins}/-${del})`
      }
      return `${file.status}: ${file.path}${statString}`
    })
    .join('\n')
  return `<file_status>\n${fileList}\n</file_status>`
}

export const specificReviewSchema = z.object({
  file: z.string(),
  lines: z.string(),
  review: z.string(),
})

export const reviewOutputSchema = z.object({
  overview: z.string(),
  specificReviews: z.array(specificReviewSchema).optional(),
})

export type ReviewResult = z.infer<typeof reviewOutputSchema>

export function formatReviewForConsole(output: ReviewResult): string {
  let formatted = `### Overview\n\n${output.overview}`

  if (output.specificReviews && output.specificReviews.length > 0) {
    formatted += '\n\n### File-specific feedback\n'
    for (const item of output.specificReviews) {
      formatted += `\n- ${item.file}#${item.lines}\n\n${item.review}\n`
    }
  }
  return formatted
}

type ExecuteCommandFn = (input: CliToolRegistry['executeCommand']['input']) => Promise<CliToolRegistry['executeCommand']['output']>

export const checkGhInstalled = async (executeCommand: ExecuteCommandFn) => {
  const result = await executeCommand({ command: 'gh', args: ['--version'] })
  if (result.exitCode !== 0) {
    throw new Error('GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
  }
}

export const getDefaultBranch = async (executeCommand: ExecuteCommandFn): Promise<string | undefined> => {
  const branchResult = await executeCommand({
    command: 'gh',
    args: ['repo', 'view', '--json', 'defaultBranchRef', '--jq', '.defaultBranchRef.name'],
  })
  if (branchResult.exitCode === 0) {
    const branch = branchResult.stdout.trim()
    if (branch) {
      return branch
    }
  }

  const defaultBranches = ['master', 'main', 'develop']
  for (const branch of defaultBranches) {
    const result = await executeCommand({
      command: 'git',
      args: ['show-ref', '--verify', '--quiet', `refs/heads/${branch}`],
    })
    if (result.exitCode === 0) {
      return branch
    }
  }

  const remoteResult = await executeCommand({ command: 'git', args: ['remote', 'show', 'origin'] })
  if (remoteResult.exitCode === 0) {
    const match = remoteResult.stdout.match(/HEAD branch: (.*)/)
    if (match?.[1]) {
      return match[1]
    }
  }

  return undefined
}

/**
 * Formats elapsed time in milliseconds to a human-readable string
 * @param ms - Time in milliseconds
 * @returns Formatted time string (e.g., "1.5s", "2m 30s", "1h 15m")
 */
export function formatElapsedTime(ms: number): string {
  const seconds = ms / 1000
  if (seconds < 60) {
    return `${seconds.toFixed(1)}s`
  }

  const minutes = Math.floor(seconds / 60)
  const remainingSeconds = Math.floor(seconds % 60)

  if (minutes < 60) {
    return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`
  }

  const hours = Math.floor(minutes / 60)
  const remainingMinutes = minutes % 60

  return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`
}

export async function getDefaultContext(commandName?: string): Promise<string> {
  const config = await loadConfig()
  const cwd = process.cwd()
  const [files, truncated] = await listFiles(cwd, true, 2000, cwd, config?.excludeFiles ?? [])
  const fileList = files.join('\n')

  const now = new Date()
  const formattedDate = `${now.getUTCFullYear()}-${String(now.getUTCMonth() + 1).padStart(2, '0')}-${String(now.getUTCDate()).padStart(2, '0')}`

  const contextParts: string[] = [
    `<file_list truncated="${truncated}">
${fileList}
</file_list>`,
    `<now_date>${formattedDate}</now_date>`,
  ]

  try {
    const agentsMdContent = await fs.readFile(path.join(cwd, 'AGENTS.md'), 'utf-8')
    contextParts.push(`<agents_instructions>\n${agentsMdContent}\n</agents_instructions>`)
  } catch {
    // Ignore error
  }

  let rules = await resolveRules(config?.rules)

  if (commandName && config) {
    const apiConfig = new ApiProviderConfig(config)
    const commandConfig = apiConfig.getConfigForCommand(commandName)
    if (commandConfig?.rules) {
      const commandRules = await resolveRules(commandConfig.rules)
      if (commandRules) {
        rules = rules ? `${rules}\n\n${commandRules}` : commandRules
      }
    }
  }

  if (rules) {
    contextParts.push(`<rules>\n${rules}\n</rules>`)
  }

  if (config?.scripts) {
    const scripts = Object.entries(config.scripts)
      .map(([name, script]) => {
        if (typeof script === 'string') {
          return `${name}: ${script}`
        }
        return `${name}: ${script.command}${script.description ? ` # ${script.description}` : ''}`
      })
      .join('\n')
    if (scripts.length > 0) {
      contextParts.push(`<scripts>\n${scripts}\n</scripts>`)
    }
  }

  return contextParts.join('\n')
}
