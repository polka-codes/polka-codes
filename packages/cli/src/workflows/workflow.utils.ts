// generated by polka.codes

import { execSync } from 'node:child_process'
import type { Logger } from '@polka-codes/workflow'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'

type FileChange = {
  path: string
  status: string
}

export function parseGitDiffNameStatus(diffOutput: string): FileChange[] {
  const lines = diffOutput.split('\n').filter((line) => line.trim())
  return lines.map((line) => {
    const [status, ...pathParts] = line.split('\t')
    const path = pathParts.join('\t')
    let statusDescription: string
    switch (status[0]) {
      case 'A':
        statusDescription = 'Added'
        break
      case 'M':
        statusDescription = 'Modified'
        break
      case 'D':
        statusDescription = 'Deleted'
        break
      case 'R':
        statusDescription = 'Renamed'
        break
      case 'C':
        statusDescription = 'Copied'
        break
      case 'T':
        statusDescription = 'Type changed'
        break
      default:
        statusDescription = 'Unknown'
    }
    return { path, status: statusDescription }
  })
}

export function printChangedFiles(logger: Logger, changedFiles: FileChange[]) {
  if (changedFiles.length === 0) {
    return
  }
  logger.info('Changed Files:')
  for (const file of changedFiles) {
    logger.info(`- ${file.status}: ${file.path}`)
  }
}

// unquotes path from git status --porcelain
// see: https://git-scm.com/docs/git-status#_changed_track_entries
const unquotePath = (path: string) => {
  if (path.startsWith('"') && path.endsWith('"')) {
    try {
      return JSON.parse(path)
    } catch {
      // if JSON.parse fails, return the original string without quotes
      return path.substring(1, path.length - 1)
    }
  }
  return path
}

export function parseGitStatus(statusOutput: string): FileChange[] {
  const statusLines = statusOutput.split('\n').filter((line) => line)
  const files: FileChange[] = []

  for (const line of statusLines) {
    const indexStatus = line[0]
    const workingTreeStatus = line[1]
    const path = line.length > 3 ? unquotePath(line.slice(3)) : line

    const statuses = []
    if (indexStatus !== ' ' && indexStatus !== '?') {
      switch (indexStatus) {
        case 'A':
          statuses.push('Added (staged)')
          break
        case 'M':
          statuses.push('Modified (staged)')
          break
        case 'D':
          statuses.push('Deleted (staged)')
          break
        case 'R':
          statuses.push('Renamed (staged)')
          break
        case 'C':
          statuses.push('Copied (staged)')
          break
        default:
          statuses.push('Changed (staged)')
      }
    }
    if (workingTreeStatus !== ' ') {
      switch (workingTreeStatus) {
        case 'M':
          statuses.push('Modified (unstaged)')
          break
        case 'D':
          statuses.push('Deleted (unstaged)')
          break
        case '?':
          statuses.push('Untracked')
          break
        default:
          statuses.push('Changed (unstaged)')
      }
    }

    if (statuses.length > 0) {
      files.push({ path, status: statuses.join(', ') })
    }
  }

  return files
}

export function getLocalChanges() {
  const statusOutput = execSync('git status --porcelain=v1', {
    encoding: 'utf-8',
  })
  const allFiles = parseGitStatus(statusOutput)
  const stagedFiles: FileChange[] = []
  const unstagedFiles: FileChange[] = []

  for (const file of allFiles) {
    if (file.status.includes('(staged)')) {
      stagedFiles.push(file)
    }
    if (file.status.includes('(unstaged)') || file.status.includes('Untracked')) {
      unstagedFiles.push(file)
    }
  }

  return { stagedFiles, unstagedFiles, allFiles }
}

export function createFileStatusPrompt(changedFiles: FileChange[]): string {
  if (changedFiles.length === 0) {
    return ''
  }
  const fileList = changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
  return `<file_status>\n${fileList}\n</file_status>`
}

export const specificReviewSchema = z.object({
  file: z.string(),
  lines: z.string(),
  review: z.string(),
})

export const reviewOutputSchema = z.object({
  overview: z.string(),
  specificReviews: z.array(specificReviewSchema).optional(),
})

export type ReviewResult = z.infer<typeof reviewOutputSchema>

export function formatReviewForConsole(output: ReviewResult): string {
  let formatted = `### Overview\n\n${output.overview}`

  if (output.specificReviews && output.specificReviews.length > 0) {
    formatted += '\n\n### File-specific feedback\n'
    for (const item of output.specificReviews) {
      formatted += `\n- ${item.file}#${item.lines}\n\n${item.review}\n`
    }
  }
  return formatted
}

type ExecuteCommandFn = (input: CliToolRegistry['executeCommand']['input']) => Promise<CliToolRegistry['executeCommand']['output']>

export const checkGhInstalled = async (executeCommand: ExecuteCommandFn) => {
  const result = await executeCommand({ command: 'gh', args: ['--version'] })
  if (result.exitCode !== 0) {
    throw new Error('GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
  }
}

export const getDefaultBranch = async (executeCommand: ExecuteCommandFn): Promise<string | undefined> => {
  const branchResult = await executeCommand({
    command: 'gh',
    args: ['repo', 'view', '--json', 'defaultBranchRef', '--jq', '.defaultBranchRef.name'],
  })
  if (branchResult.exitCode === 0) {
    const branch = branchResult.stdout.trim()
    if (branch) {
      return branch
    }
  }

  const defaultBranches = ['master', 'main', 'develop']
  for (const branch of defaultBranches) {
    const result = await executeCommand({
      command: 'git',
      args: ['show-ref', '--verify', '--quiet', `refs/heads/${branch}`],
    })
    if (result.exitCode === 0) {
      return branch
    }
  }

  const remoteResult = await executeCommand({ command: 'git', args: ['remote', 'show', 'origin'] })
  if (remoteResult.exitCode === 0) {
    const match = remoteResult.stdout.match(/HEAD branch: (.*)/)
    if (match?.[1]) {
      return match[1]
    }
  }

  return undefined
}
