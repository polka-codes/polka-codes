// generated by polka.codes

import { execSync } from 'node:child_process'
import { z } from 'zod'

type FileChange = {
  path: string
  status: string
}

export function parseGitDiffNameStatus(diffOutput: string): FileChange[] {
  const lines = diffOutput.split('\n').filter((line) => line.trim())
  return lines.map((line) => {
    const [status, ...pathParts] = line.split('\t')
    const path = pathParts.join('\t')
    let statusDescription: string
    switch (status[0]) {
      case 'A':
        statusDescription = 'Added'
        break
      case 'M':
        statusDescription = 'Modified'
        break
      case 'D':
        statusDescription = 'Deleted'
        break
      case 'R':
        statusDescription = 'Renamed'
        break
      case 'C':
        statusDescription = 'Copied'
        break
      case 'T':
        statusDescription = 'Type changed'
        break
      default:
        statusDescription = 'Unknown'
    }
    return { path, status: statusDescription }
  })
}

export function printChangedFiles(title: string, changedFiles: FileChange[]) {
  if (changedFiles.length === 0) {
    return
  }
  console.log(title)
  for (const file of changedFiles) {
    console.log(`- ${file.status}: ${file.path}`)
  }
}

export function checkGhInstalled() {
  try {
    execSync('gh --version', { stdio: 'ignore' })
  } catch {
    throw new Error('GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
  }
}

export function getDefaultBranch(): string | undefined {
  const defaultBranches = ['master', 'main', 'develop']
  for (const branch of defaultBranches) {
    try {
      execSync(`git show-ref --verify --quiet refs/heads/${branch}`)
      return branch
    } catch {
      // branch does not exist
    }
  }

  try {
    checkGhInstalled()
    const branch = execSync('gh repo view --json defaultBranchRef --jq .defaultBranchRef.name', {
      encoding: 'utf-8',
    }).trim()
    if (branch) {
      return branch
    }
  } catch {
    // gh cli not installed or command failed
  }

  try {
    const output = execSync('git remote show origin', { encoding: 'utf-8' })
    const match = output.match(/HEAD branch: (.*)/)
    if (match?.[1]) {
      return match[1]
    }
  } catch {
    // git remote show origin failed
  }

  return undefined
}

// unquotes path from git status --porcelain
// see: https://git-scm.com/docs/git-status#_changed_track_entries
const unquotePath = (path: string) => {
  if (path.startsWith('"') && path.endsWith('"')) {
    try {
      return JSON.parse(path)
    } catch {
      // if JSON.parse fails, return the original string without quotes
      return path.substring(1, path.length - 1)
    }
  }
  return path
}

export function parseGitStatus(statusOutput: string): FileChange[] {
  const statusLines = statusOutput.split('\n').filter((line) => line)
  const files: FileChange[] = []

  for (const line of statusLines) {
    const indexStatus = line[0]
    const workingTreeStatus = line[1]
    const path = line.length > 3 ? unquotePath(line.slice(3)) : line

    const statuses = []
    if (indexStatus !== ' ' && indexStatus !== '?') {
      switch (indexStatus) {
        case 'A':
          statuses.push('Added (staged)')
          break
        case 'M':
          statuses.push('Modified (staged)')
          break
        case 'D':
          statuses.push('Deleted (staged)')
          break
        case 'R':
          statuses.push('Renamed (staged)')
          break
        case 'C':
          statuses.push('Copied (staged)')
          break
        default:
          statuses.push('Changed (staged)')
      }
    }
    if (workingTreeStatus !== ' ') {
      switch (workingTreeStatus) {
        case 'M':
          statuses.push('Modified (unstaged)')
          break
        case 'D':
          statuses.push('Deleted (unstaged)')
          break
        case '?':
          statuses.push('Untracked')
          break
        default:
          statuses.push('Changed (unstaged)')
      }
    }

    if (statuses.length > 0) {
      files.push({ path, status: statuses.join(', ') })
    }
  }

  return files
}

export function getLocalChanges() {
  const statusOutput = execSync('git status --porcelain=v1', {
    encoding: 'utf-8',
  })
  const allFiles = parseGitStatus(statusOutput)
  const stagedFiles: FileChange[] = []
  const unstagedFiles: FileChange[] = []

  for (const file of allFiles) {
    if (file.status.includes('(staged)')) {
      stagedFiles.push(file)
    }
    if (file.status.includes('(unstaged)') || file.status.includes('Untracked')) {
      unstagedFiles.push(file)
    }
  }

  return { stagedFiles, unstagedFiles, allFiles }
}

export function createFileStatusPrompt(changedFiles: FileChange[]): string {
  if (changedFiles.length === 0) {
    return ''
  }
  const fileList = changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
  return `<file_status>\n${fileList}\n</file_status>`
}

export const specificReviewSchema = z.object({
  file: z.string(),
  lines: z.string(),
  review: z.string(),
})

export const reviewOutputSchema = z.object({
  overview: z.string(),
  specificReviews: z.array(specificReviewSchema),
})

export type ReviewResult = z.infer<typeof reviewOutputSchema>

export function formatReviewForConsole(output: ReviewResult): string {
  let formatted = `### Overview\n\n${output.overview}`

  if (output.specificReviews.length > 0) {
    formatted += `\n\n### File-specific feedback\n`
    for (const item of output.specificReviews) {
      formatted += `\n- ${item.file}#${item.lines}\n\n${item.review}\n`
    }
  }
  return formatted
}
