// generated by polka.codes

import { afterEach, describe, expect, mock, spyOn, test } from 'bun:test'
import * as cliShared from '@polka-codes/cli-shared'
import { z } from 'zod'
import {
  createWorkflowTestContext,
  mockAgentResponse,
  mockCommandAttempts,
  mockFailedCommand,
  mockSuccessfulCommand,
} from '../test/workflow-fixtures'
import { fixWorkflow } from './fix.workflow'
import * as prompts from './prompts'

describe('fixWorkflow', () => {
  const defaultInput = {
    interactive: false,
    additionalTools: {},
  }

  afterEach(() => {
    mock.restore()
  })

  test('should succeed when command passes on first attempt', async () => {
    const { context, tools } = createWorkflowTestContext()
    mockSuccessfulCommand(tools, 'All tests passed')

    const result = await fixWorkflow({ ...defaultInput, command: 'bun test' }, context)

    expect(tools.executeCommand).toHaveBeenCalledWith({ command: 'bun test', shell: true, pipe: true })
    expect(result).toStrictEqual({ success: true, summaries: [] })
  })

  test('should prompt for command when not provided', async () => {
    const { context, tools } = createWorkflowTestContext()
    const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockResolvedValue({
      scripts: {
        check: 'bun typecheck',
        test: 'bun test',
      },
    })

    tools.input.mockResolvedValue('bun typecheck && bun test')
    mockSuccessfulCommand(tools, 'Success')

    await fixWorkflow({ ...defaultInput, interactive: true }, context)

    expect(tools.input).toHaveBeenCalledWith({
      message: 'Please enter the command to run to identify issues:',
      default: 'bun typecheck && bun test',
    })
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'bun typecheck && bun test',
      shell: true,
      pipe: true,
    })

    loadConfigSpy.mockRestore()
  })

  test('should use default command when not interactive', async () => {
    const { context, tools } = createWorkflowTestContext()
    const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockResolvedValue({
      scripts: {
        check: 'bun typecheck',
      },
    })

    mockSuccessfulCommand(tools, '')

    await fixWorkflow({ ...defaultInput, interactive: false }, context)

    expect(tools.executeCommand).toHaveBeenCalledWith({ command: 'bun typecheck', shell: true, pipe: true })

    loadConfigSpy.mockRestore()
  })

  test('should throw error when no command provided and user provides empty input', async () => {
    const { context, tools } = createWorkflowTestContext()
    const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockResolvedValue({})
    tools.input.mockResolvedValue('')

    const promise = fixWorkflow({ ...defaultInput, interactive: true }, context)

    await expect(promise).rejects.toThrow('No command provided. Aborting.')
    loadConfigSpy.mockRestore()
  })

  test('should succeed after agent fixes the issue', async () => {
    const { context, tools } = createWorkflowTestContext()

    mockCommandAttempts(tools, [1, 0])
    mockAgentResponse(tools, 'I did a fix')

    const result = await fixWorkflow({ ...defaultInput, command: 'bun test' }, context)

    expect(tools.executeCommand).toHaveBeenCalledTimes(2)
    expect(tools.generateText).toHaveBeenCalledTimes(1)
    expect(result).toStrictEqual({ success: true, summaries: ['I did a fix'] })
  })

  test('should fail after exhausting all retries', async () => {
    const { context, tools } = createWorkflowTestContext()

    const failedAttempts = Array(10).fill(1)
    mockCommandAttempts(tools, failedAttempts)
    mockAgentResponse(tools, 'I did a fix')

    const result = await fixWorkflow({ ...defaultInput, command: 'bun test' }, context)

    expect(tools.executeCommand).toHaveBeenCalledTimes(10)
    expect(tools.generateText).toHaveBeenCalledTimes(10)
    expect(result).toMatchSnapshot()
  })

  test('should return bailReason when agent cannot fix', async () => {
    const { context, tools } = createWorkflowTestContext()

    mockFailedCommand(tools, 'FAIL', 'Mysterious error')
    mockAgentResponse(tools, null, 'Unable to identify the root cause of the error')

    const result = await fixWorkflow({ ...defaultInput, command: 'bun test' }, context)

    expect(tools.executeCommand).toHaveBeenCalledTimes(1)
    expect(tools.generateText).toHaveBeenCalledTimes(1)
    expect(result).toMatchSnapshot()
  })

  test('should pass task to agent prompt', async () => {
    const { context, tools } = createWorkflowTestContext()
    const getFixUserPromptSpy = spyOn(prompts, 'getFixUserPrompt')

    mockFailedCommand(tools, 'FAIL src/test.ts', 'TypeError: undefined is not a function')
    mockAgentResponse(tools, 'I did a fix')

    mockCommandAttempts(tools, [1, 0])

    await fixWorkflow({ ...defaultInput, command: 'bun test', task: 'My original task was to do this thing.' }, context)

    expect(getFixUserPromptSpy).toHaveBeenCalledTimes(1)
    expect(tools.generateText).toHaveBeenCalledTimes(1)

    const generateTextCall = tools.generateText.mock.calls[0][0] as { messages: { role: string; content: string }[] }
    const userMessage = generateTextCall.messages.find((m: { role: string }) => m.role === 'user')
    expect(userMessage?.content).toContain('My original task was to do this thing.')

    getFixUserPromptSpy.mockRestore()
  })

  test('should pass prompt to agent prompt', async () => {
    const { context, tools } = createWorkflowTestContext()
    const getFixUserPromptSpy = spyOn(prompts, 'getFixUserPrompt')

    mockFailedCommand(tools, 'FAIL src/test.ts', 'TypeError: undefined is not a function')
    mockAgentResponse(tools, 'I did a fix')

    mockCommandAttempts(tools, [1, 0])

    await fixWorkflow({ ...defaultInput, command: 'bun test', prompt: 'Focus on the authentication tests' }, context)

    expect(getFixUserPromptSpy).toHaveBeenCalledTimes(1)
    expect(tools.generateText).toHaveBeenCalledTimes(1)

    const generateTextCall = tools.generateText.mock.calls[0][0] as { messages: { role: string; content: string }[] }
    const userMessage = generateTextCall.messages.find((m: { role: string }) => m.role === 'user')
    expect(userMessage?.content).toContain('Focus on the authentication tests')

    getFixUserPromptSpy.mockRestore()
  })

  test('should pass additional tools to agent workflow', async () => {
    const { context, tools } = createWorkflowTestContext()
    const searchTool = {
      name: 'search',
      description: 'Search the web',
      parameters: z.object({ query: z.string() }),
      handler: async () => ({ type: 'Reply', message: { type: 'text', value: 'result' } }),
    } as any

    mockFailedCommand(tools, 'FAIL', 'Error')
    mockAgentResponse(tools, 'I did a fix')

    await fixWorkflow(
      {
        ...defaultInput,
        command: 'bun test',
        additionalTools: { search: searchTool },
      },
      context,
    )

    const generateTextCall = tools.generateText.mock.calls[0][0] as { tools: any }
    expect(generateTextCall.tools).toHaveProperty('search')
    expect(generateTextCall.tools.search.description).toBe('Search the web')
  })
})
