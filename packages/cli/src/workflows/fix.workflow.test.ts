// generated by polka.codes

import { expect, spyOn, test } from 'bun:test'
import { loadConfig } from '@polka-codes/cli-shared'
import { run } from '@polka-codes/workflow'
import { fixWorkflow } from './fix.workflow'

test('should succeed when command passes on first attempt', async () => {
  const result1 = await run(fixWorkflow, { command: 'bun test' })
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next({
    exitCode: 0,
    stdout: 'All tests passed',
    stderr: '',
  })
  expect(result2).toMatchSnapshot()
})

test('should prompt for command when not provided', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {
      check: 'bun typecheck',
      test: 'bun test',
    },
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('bun typecheck && bun test')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: 'Success',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should use check command as default when only check available', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {
      check: 'bun typecheck',
    },
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('bun typecheck')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should use test command as default when only test available', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {
      test: 'bun test',
    },
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('bun test')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should combine check and test commands when both available', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {
      check: 'eslint .',
      test: 'jest',
    },
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('eslint . && jest')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should handle object-style script config', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {
      check: {
        command: 'tsc --noEmit',
        description: 'Type check',
      },
      test: {
        command: 'vitest',
        description: 'Run tests',
      },
    },
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('tsc --noEmit && vitest')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should handle no default command', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {},
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('npm run build')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should retry and invoke coder agent when command fails', async () => {
  const result1 = await run(fixWorkflow, { command: 'bun test' })
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next({
    exitCode: 1,
    stdout: 'FAIL src/test.ts',
    stderr: 'TypeError: undefined is not a function',
  })
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    output: {},
    messages: [],
  })
  expect(result3).toMatchSnapshot()
  if (result3.status !== 'pending') return

  const result4 = await result3.next({
    exitCode: 0,
    stdout: 'All tests passed',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
})

test('should retry multiple times before succeeding', async () => {
  const result1 = await run(fixWorkflow, { command: 'npm test' })
  if (result1.status !== 'pending') return

  const result2 = await result1.next({
    exitCode: 1,
    stdout: '',
    stderr: 'Error 1',
  })
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    output: {},
    messages: [],
  })
  if (result3.status !== 'pending') return

  const result4 = await result3.next({
    exitCode: 1,
    stdout: '',
    stderr: 'Error 2',
  })
  if (result4.status !== 'pending') return

  const result5 = await result4.next({
    output: {},
    messages: [],
  })
  if (result5.status !== 'pending') return

  const result6 = await result5.next({
    exitCode: 1,
    stdout: '',
    stderr: 'Error 3',
  })
  if (result6.status !== 'pending') return

  const result7 = await result6.next({
    output: {},
    messages: [],
  })
  if (result7.status !== 'pending') return

  const result8 = await result7.next({
    exitCode: 0,
    stdout: 'Success',
    stderr: '',
  })
  expect(result8).toMatchSnapshot()
})

test('should handle command with stdout and stderr', async () => {
  const result1 = await run(fixWorkflow, { command: 'make build' })
  if (result1.status !== 'pending') return

  const result2 = await result1.next({
    exitCode: 2,
    stdout: 'Building...\nCompiling source files',
    stderr: 'Warning: deprecated API\nError: compilation failed',
  })
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    output: {},
    messages: [],
  })
  if (result3.status !== 'pending') return

  const result4 = await result3.next({
    exitCode: 0,
    stdout: 'Build successful',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
})

test('should throw error after 10 failed attempts', async () => {
  const result1 = await run(fixWorkflow, { command: 'failing-command' })
  if (result1.status !== 'pending') return

  const result2 = await result1.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 1' })
  if (result2.status !== 'pending') return
  const result3 = await result2.next({ output: {}, messages: [] })
  if (result3.status !== 'pending') return

  const result4 = await result3.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 2' })
  if (result4.status !== 'pending') return
  const result5 = await result4.next({ output: {}, messages: [] })
  if (result5.status !== 'pending') return

  const result6 = await result5.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 3' })
  if (result6.status !== 'pending') return
  const result7 = await result6.next({ output: {}, messages: [] })
  if (result7.status !== 'pending') return

  const result8 = await result7.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 4' })
  if (result8.status !== 'pending') return
  const result9 = await result8.next({ output: {}, messages: [] })
  if (result9.status !== 'pending') return

  const result10 = await result9.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 5' })
  if (result10.status !== 'pending') return
  const result11 = await result10.next({ output: {}, messages: [] })
  if (result11.status !== 'pending') return

  const result12 = await result11.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 6' })
  if (result12.status !== 'pending') return
  const result13 = await result12.next({ output: {}, messages: [] })
  if (result13.status !== 'pending') return

  const result14 = await result13.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 7' })
  if (result14.status !== 'pending') return
  const result15 = await result14.next({ output: {}, messages: [] })
  if (result15.status !== 'pending') return

  const result16 = await result15.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 8' })
  if (result16.status !== 'pending') return
  const result17 = await result16.next({ output: {}, messages: [] })
  if (result17.status !== 'pending') return

  const result18 = await result17.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 9' })
  if (result18.status !== 'pending') return
  const result19 = await result18.next({ output: {}, messages: [] })
  if (result19.status !== 'pending') return

  const result20 = await result19.next({ exitCode: 1, stdout: '', stderr: 'Error attempt 10' })
  if (result20.status !== 'pending') return
  const result21 = await result20.next({ output: {}, messages: [] })

  if (result21.status === 'failed') {
    expect({
      status: result21.status,
      error: (result21.error as Error)?.message,
    }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed after 10 attempts')
  }
})

test('should throw error when no command provided and user provides empty input', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({})

  const result1 = await run(fixWorkflow, {})
  if (result1.status !== 'pending') return

  const result2 = await result1.next('')

  if (result2.status === 'failed') {
    expect({
      status: result2.status,
      error: (result2.error as Error)?.message,
    }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed with no command error')
  }

  loadConfigSpy.mockRestore()
})

test('should handle command with only stdout', async () => {
  const result1 = await run(fixWorkflow, { command: 'echo test' })
  if (result1.status !== 'pending') return

  const result2 = await result1.next({
    exitCode: 1,
    stdout: 'Some output',
    stderr: '',
  })
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    output: {},
    messages: [],
  })
  if (result3.status !== 'pending') return

  const result4 = await result3.next({
    exitCode: 0,
    stdout: 'test',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
})

test('should handle command with only stderr', async () => {
  const result1 = await run(fixWorkflow, { command: 'test-cmd' })
  if (result1.status !== 'pending') return

  const result2 = await result1.next({
    exitCode: 1,
    stdout: '',
    stderr: 'Error occurred',
  })
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    output: {},
    messages: [],
  })
  if (result3.status !== 'pending') return

  const result4 = await result3.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
})

test('should handle config with undefined scripts', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue(undefined)

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('custom-command')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})

test('should handle mixed script formats', async () => {
  const loadConfigSpy = spyOn({ loadConfig }, 'loadConfig')
  loadConfigSpy.mockReturnValue({
    scripts: {
      check: 'eslint .',
      test: {
        command: 'jest --coverage',
        description: 'Test with coverage',
      },
    },
  })

  const result1 = await run(fixWorkflow, {})
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('eslint . && jest --coverage')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()

  loadConfigSpy.mockRestore()
})
