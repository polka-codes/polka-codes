// generated by polka.codes

import { expect, spyOn, test } from 'bun:test'
import assert from 'node:assert/strict'
import * as cliShared from '@polka-codes/cli-shared'
import { run } from '@polka-codes/workflow'
import { fixWorkflow } from './fix.workflow'
import * as prompts from './prompts'

test('should succeed when command passes on first attempt', async () => {
  let result = await run(fixWorkflow, { command: 'bun test' })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')

  result = await result.next({ exitCode: 0, stdout: 'All tests passed', stderr: '' })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })
})

test('should prompt for command when not provided', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({
    scripts: {
      check: 'bun typecheck',
      test: 'bun test',
    },
  })

  let result = await run(fixWorkflow, { interactive: true })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'input')
  assert.strictEqual(result.tool.input.default, 'bun typecheck && bun test')

  result = await result.next('bun typecheck && bun test')
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')

  result = await result.next({ exitCode: 0, stdout: 'Success', stderr: '' })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })

  loadConfigSpy.mockRestore()
})

test('should use check command as default when only check available', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({
    scripts: {
      check: 'bun typecheck',
    },
  })

  let result = await run(fixWorkflow, { interactive: false })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')
  assert.strictEqual(result.tool.input.command, 'bun typecheck')

  result = await result.next({ exitCode: 0, stdout: '', stderr: '' })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })

  loadConfigSpy.mockRestore()
})

test('should use test command as default when only test available', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({
    scripts: {
      test: 'bun test',
    },
  })

  let result = await run(fixWorkflow, { interactive: false })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')
  assert.strictEqual(result.tool.input.command, 'bun test')

  result = await result.next({ exitCode: 0, stdout: '', stderr: '' })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })

  loadConfigSpy.mockRestore()
})

test('should combine check and test commands when both available', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({
    scripts: {
      check: 'eslint .',
      test: 'jest',
    },
  })

  let result = await run(fixWorkflow, { interactive: false })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')
  assert.strictEqual(result.tool.input.command, 'eslint . && jest')

  result = await result.next({ exitCode: 0, stdout: '', stderr: '' })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })

  loadConfigSpy.mockRestore()
})

test('should handle object-style script config', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({
    scripts: {
      check: {
        command: 'tsc --noEmit',
        description: 'Type check',
      },
      test: {
        command: 'vitest',
        description: 'Run tests',
      },
    },
  })

  let result = await run(fixWorkflow, { interactive: false })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')
  assert.strictEqual(result.tool.input.command, 'tsc --noEmit && vitest')

  result = await result.next({ exitCode: 0, stdout: '', stderr: '' })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })

  loadConfigSpy.mockRestore()
})

test('should handle no default command and no interactive', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({
    scripts: {},
  })

  const result = await run(fixWorkflow, { interactive: false })
  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: [] })

  loadConfigSpy.mockRestore()
})

test('should throw error when no command provided and user provides empty input', async () => {
  const loadConfigSpy = spyOn(cliShared, 'loadConfig').mockReturnValue({})

  let result = await run(fixWorkflow, { interactive: true })
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'input')

  result = await result.next('')
  assert.strictEqual(result.status, 'failed')
  assert.strictEqual(result.error.message, 'No command provided. Aborting.')

  loadConfigSpy.mockRestore()
})

test('should succeed after agent fixes the issue', async () => {
  let result = await run(fixWorkflow, { command: 'bun test' })
  assert.strictEqual(result.tool.tool, 'executeCommand')

  result = await result.next({ exitCode: 1, stdout: 'FAIL', stderr: 'Error' })

  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'taskEvent') // agent started
  result = await result.next() // complete taskEvent

  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'taskEvent') // round started
  result = await result.next() // complete taskEvent

  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'generateText') // agent wants to talk
  // let's pretend agent fixes it and gives summary
  result = await result.next([
    {
      role: 'assistant',
      content: '```json\n{"summary":"I did a fix"}\n```',
    },
  ])

  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'taskEvent') // round ended
  result = await result.next() // complete taskEvent

  // sub-workflow completes, loop continues in fixWorkflow
  assert.strictEqual(result.status, 'pending')
  assert.strictEqual(result.tool.tool, 'executeCommand')

  result = await result.next({ exitCode: 0, stdout: 'PASS', stderr: '' })

  assert.strictEqual(result.status, 'completed')
  assert.deepStrictEqual(result.output, { summaries: ['I did a fix'] })
})

test('should fail after exhausting all retries', async () => {
  let result = await run(fixWorkflow, { command: 'bun test' })

  for (let i = 0; i < 10; i++) {
    assert.strictEqual(result.status, 'pending')
    assert.strictEqual(result.tool.tool, 'executeCommand')
    result = await result.next({ exitCode: 1, stdout: 'FAIL', stderr: 'Error' })

    assert.strictEqual(result.status, 'pending')
    assert.strictEqual(result.tool.tool, 'taskEvent') // agent started
    result = await result.next() // complete taskEvent

    assert.strictEqual(result.status, 'pending')
    assert.strictEqual(result.tool.tool, 'taskEvent') // round started
    result = await result.next() // complete taskEvent

    assert.strictEqual(result.status, 'pending')
    assert.strictEqual(result.tool.tool, 'generateText') // agent wants to talk
    result = await result.next([
      {
        role: 'assistant',
        content: '```json\n{"summary":"I did a fix"}\n```',
      },
    ])

    assert.strictEqual(result.status, 'pending')
    assert.strictEqual(result.tool.tool, 'taskEvent') // round ended
    result = await result.next() // complete taskEvent
  }

  assert.strictEqual(result.status, 'failed')
  assert.strictEqual(result.error.message, 'Failed to fix the issue after 10 attempts.')
})

test('should pass task to agent prompt', async () => {
  const getFixUserPromptSpy = spyOn(prompts, 'getFixUserPrompt')

  let result = await run(fixWorkflow, {
    command: 'bun test',
    task: 'My original task was to do this thing.',
  })
  assert.strictEqual(result.status, 'pending')

  result = await result.next({
    exitCode: 1,
    stdout: 'FAIL src/test.ts',
    stderr: 'TypeError: undefined is not a function',
  })

  expect(getFixUserPromptSpy).toHaveBeenCalledTimes(1)
  expect(getFixUserPromptSpy).toHaveBeenCalledWith(
    'bun test',
    1,
    'FAIL src/test.ts',
    'TypeError: undefined is not a function',
    'My original task was to do this thing.',
  )

  getFixUserPromptSpy.mockRestore()
})
