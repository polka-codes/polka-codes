// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`should generate new plan without questions and save with default path 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Build a REST API
</task>



# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should generate new plan without questions and save with default path 2`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "choices": [
        {
          "name": "Save Plan",
          "value": "save",
        },
        {
          "name": "Execute Plan",
          "value": "execute",
        },
        {
          "name": "Provide Feedback",
          "value": "feedback",
        },
        {
          "name": "Regenerate Plan",
          "value": "regenerate",
        },
        {
          "name": "Exit",
          "value": "exit",
        },
      ],
      "message": "What do you want to do?",
    },
    "tool": "select",
    "type": "tool",
  },
}
`;

exports[`should generate new plan without questions and save with default path 3`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "content": 
"# REST API Plan

1. Setup Express server
2. Define routes
3. Add middleware"
,
      "path": ".plans/plan-2025-10-08.md",
    },
    "tool": "writeToFile",
    "type": "tool",
  },
}
`;

exports[`should generate new plan without questions and save with default path 4`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should generate plan with clarifying question 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Create a web app
</task>



# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should generate plan with clarifying question 2`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "message": "What framework do you want to use?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should generate plan with clarifying question 3`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Create a web app

User feedback: Question: What framework do you want to use?
Answer: React with TypeScript
</task>



# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should generate plan with clarifying question 4`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "choices": [
        {
          "name": "Save Plan",
          "value": "save",
        },
        {
          "name": "Execute Plan",
          "value": "execute",
        },
        {
          "name": "Provide Feedback",
          "value": "feedback",
        },
        {
          "name": "Regenerate Plan",
          "value": "regenerate",
        },
        {
          "name": "Exit",
          "value": "exit",
        },
      ],
      "message": "What do you want to do?",
    },
    "tool": "select",
    "type": "tool",
  },
}
`;

exports[`should generate plan with clarifying question 5`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should update existing plan 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Add authentication
</task>

The content of an existing plan file:
<plan_file>
# API Plan

1. Setup server
2. Add routes
</plan_file>

# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should update existing plan 2`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "choices": [
        {
          "name": "Save Plan",
          "value": "save",
        },
        {
          "name": "Execute Plan",
          "value": "execute",
        },
        {
          "name": "Provide Feedback",
          "value": "feedback",
        },
        {
          "name": "Regenerate Plan",
          "value": "regenerate",
        },
        {
          "name": "Exit",
          "value": "exit",
        },
      ],
      "message": "What do you want to do?",
    },
    "tool": "select",
    "type": "tool",
  },
}
`;

exports[`should update existing plan 3`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle user feedback and regenerate 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "message": "What changes do you want to make?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should handle user feedback and regenerate 2`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Build a mobile app

User feedback: Use React Native instead of native development
</task>

The content of an existing plan file:
<plan_file>
# Mobile App Plan

1. Choose native development
2. Build iOS app
3. Build Android app
</plan_file>

# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should handle user feedback and regenerate 3`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should regenerate plan from scratch 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Create a CLI tool
</task>



# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should regenerate plan from scratch 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should execute plan 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "coder",
      "defaultContext": true,
      "messages": [
        {
          "content": [
            
"# Code Workflow Context

You are participating in a 3-phase development workflow:

1. **Planning Phase** (Architect Agent)
   - Analyzes requirements and creates detailed implementation plan
   - User reviews and approves the plan before implementation begins

2. **Implementation Phase** (Coder Agent)
   - Implements the approved plan from phase 1
   - Makes code changes following the plan and project conventions
   - Can delegate subtasks or hand over to specialized agents

3. **Fixing Phase** (CodeFixer Agent)
   - Runs validation commands (tests, type checks, linting)
   - Fixes any errors that arise during validation
   - Ensures code quality and correctness

**YOU ARE IN PHASE 2: IMPLEMENTATION**

Your task is to implement the plan created and approved in Phase 1.

## Your Plan

<plan>
# Bug Fix Plan

1. Review auth code
2. Fix token validation
3. Add tests
</plan>

## Implementation Guidelines

### 1. Plan Analysis

Before starting implementation:
- Review the plan carefully and understand all requirements
- Identify dependencies between different parts of the plan
- Determine if this is a single cohesive task or multiple independent tasks
- Consider the scope and complexity of the work

### 2. Gather Context

Before making changes:
- **Search for similar existing files** to understand patterns and conventions
- **Read relevant files** to see how similar features are implemented
- Look for existing tests, utilities, or helpers you can leverage
- Understand the project structure and naming conventions
- Verify you have all necessary context to proceed

### 3. Choose Your Approach

**Option A: Single Implementation (use handOver tool)**
- When the plan is a single cohesive task
- When all steps are tightly coupled and interdependent
- When you need to maintain context across all changes
- Implement everything yourself and hand over when complete

**Option B: Delegate Subtasks (use delegate tool)**
- When the plan has multiple independent steps or features
- When tasks can be parallelized or done separately
- When different parts require different expertise
- Break down the plan and delegate each subtask with full context

### 4. Implementation Best Practices

- **Make incremental changes**: Implement one piece at a time
- **Follow existing patterns**: Match the style and structure of similar code
- **Add documentation**: Include comments explaining complex logic
- **Consider edge cases**: Think about error handling and boundary conditions
- **Verify as you go**: Test your changes incrementally if possible

### 5. Code Quality

- Follow the project's existing code style and conventions
- Use appropriate TypeScript types (avoid 'any' unless necessary)
- Add JSDoc comments for public APIs and complex functions
- Ensure proper error handling and validation
- Keep functions focused and maintainable

## Your Task

Implement the plan above following these guidelines. Start by:
1. Analyzing the plan structure
2. Searching for similar existing code patterns
3. Determining whether to implement directly or delegate subtasks
4. Proceeding with implementation

Please implement all the necessary code changes according to this plan."
,
          ],
          "type": "user",
        },
      ],
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should execute plan 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should exit without saving 1`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle multiple clarifying questions 1`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle multiple feedback iterations 1`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should save plan with custom path 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "content": 
"# Microservices Migration

1. Identify service boundaries
2. Extract services
3. Setup API gateway"
,
      "path": "docs/architecture/microservices-plan.md",
    },
    "tool": "writeToFile",
    "type": "tool",
  },
}
`;

exports[`should save plan with custom path 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle plan with both plan and question returned 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "message": "Which CI platform do you prefer: GitHub Actions, GitLab CI, or Jenkins?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should handle plan with both plan and question returned 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle empty task input 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "default": undefined,
      "message": "What is the task you want to plan?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should handle empty task input 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle plan with checklist format 1`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle complex plan with mixed formats 1`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle workflow with question, feedback, and save cycle 1`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should prompt for task when none is provided 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "default": undefined,
      "message": "What is the task you want to plan?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should prompt for task when none is provided 2`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Create a new feature
</task>



# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should prompt for improvement when only a plan is provided 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "default": "Review and improve the plan",
      "message": "How would you like to improve the plan?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should prompt for improvement when only a plan is provided 2`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "agent": "architect",
      "defaultContext": true,
      "messages": [
        {
          "content": 
"
# Role and Objective

You are an expert planner. Your goal is to create a detailed plan for a given task.

# Task Input

The user has provided a task:
<task>
Add more details
</task>

The content of an existing plan file:
<plan_file>
Some existing plan
</plan_file>

# Plan Format Guidelines

When generating your plan, follow these formatting guidelines:

1. Number major sections to provide clear structure:
   a. Use numbers (1., 2., 3., etc.) for top-level sections
   b. Use nested numbering (1.1, 1.2) or letters (a., b., c.) for sub-sections
   c. This makes sections easy to reference and understand
   d. Provides clear hierarchy and organization

   Example section numbering:
   1. Project Setup
      1.1 Initialize repository
      1.2 Configure dependencies
   2. Implementation
      2.1 Core features
      2.2 Tests

2. Use numbered lists when the order of steps matters:
   a. Sequential steps where one depends on the previous
   b. Steps that must be performed in a specific order
   c. Processes with clear progression
   d. When steps need to be referenced by number

   Example numbered list format:
   1. First step that must be completed first
   2. Second step that depends on the first
   3. Third step that follows from the second

3. Use checklist format (markdown checkboxes) when the plan involves:
   a. Multiple independent action items
   b. Trackable items that can be marked as complete
   c. Verifiable completion criteria
   d. Tasks that benefit from progress tracking

   Example checklist format:
   - [ ] First action item
   - [ ] Second action item
   - [ ] Third action item

4. Use narrative or structured text format when the plan involves:
   a. High-level strategies or conceptual approaches
   b. Explanations or background information
   c. Decision-making guidance
   d. Context that doesn't translate well to discrete steps

5. Combine formats when appropriate:
   a. Use numbered sections for overall structure
   b. Use narrative text for context and explanation
   c. Use numbered lists for sequential steps
   d. Use checklist items for trackable actions

   Example combined format:
   1. Phase 1: Setup
      First, we need to configure the environment...
      1. Install dependencies
      2. Configure settings
      3. Verify installation

   2. Phase 2: Implementation
      - [ ] Implement feature A
      - [ ] Implement feature B
      - [ ] Write tests

6. Only include relevant details for AI Agents:
    a. Avoid unnecessary technical jargon or implementation details
    b. Avoid steps requires human intervention or cannot be done by an AI agent

# Your Tasks

1. Analyze the task and the existing plan (if any).
2. If the requirements are clear and you can generate or update the plan:
   a. Provide the plan in the "plan" field
   b. Apply appropriate formatting based on guidelines
3. If the requirements are not clear:
   a. Ask a clarifying question in the "question" field
4. If the task is already implemented or no action is needed:
   a. Do not generate a plan.
   b. Provide a concise reason in the "reason" field.

# Response Format

Respond with a JSON object that matches the following schema:
\`\`\`json
{
  "plan": "The generated or updated plan.",
  "question": "The clarifying question to ask the user.",
  "reason": "If no plan is needed, provide a reason here.",
  "files": ["path/to/file1.ts", "path/to/file2.ts"]
}
\`\`\`
"
,
          "type": "user",
        },
      ],
      "outputSchema": _ {
        "_def": {
          "shape": [native code],
          "type": "object",
        },
        "_zod": {
          "bag": {},
          "constr": [Function: _],
          "def": {
            "shape": [native code],
            "type": "object",
          },
          "deferred": [
            [Function],
            [Function],
          ],
          "parse": [Function],
          "propValues": [native code],
          "run": [Function],
          "traits":           
Set {
            "ZodObject",
            "$ZodObjectJIT",
            "$ZodObject",
            "$ZodType",
            "ZodType",
          }
,
          "version": {
            "major": 4,
            "minor": 1,
            "patch": 12,
          },
        },
        "and": [Function],
        "array": [Function],
        "brand": [Function],
        "catch": [Function],
        "catchall": [Function],
        "check": [Function],
        "clone": [Function],
        "decode": [Function],
        "decodeAsync": [Function: AsyncFunction],
        "def": {
          "shape": [native code],
          "type": "object",
        },
        "default": [Function],
        "describe": [Function],
        "description": [native code],
        "encode": [Function],
        "encodeAsync": [Function: AsyncFunction],
        "extend": [Function],
        "isNullable": [Function],
        "isOptional": [Function],
        "keyof": [Function],
        "loose": [Function],
        "merge": [Function],
        "meta": [Function],
        "nonoptional": [Function],
        "nullable": [Function],
        "nullish": [Function],
        "omit": [Function],
        "optional": [Function],
        "or": [Function],
        "overwrite": [Function],
        "parse": [Function],
        "parseAsync": [Function: AsyncFunction],
        "partial": [Function],
        "passthrough": [Function],
        "pick": [Function],
        "pipe": [Function],
        "prefault": [Function],
        "readonly": [Function],
        "refine": [Function],
        "register": [Function],
        "required": [Function],
        "safeDecode": [Function],
        "safeDecodeAsync": [Function: AsyncFunction],
        "safeEncode": [Function],
        "safeEncodeAsync": [Function: AsyncFunction],
        "safeExtend": [Function],
        "safeParse": [Function],
        "safeParseAsync": [Function: AsyncFunction],
        "shape": [native code],
        "spa": [Function: AsyncFunction],
        "strict": [Function],
        "strip": [Function],
        "superRefine": [Function],
        "transform": [Function],
        "type": "object",
        "~standard": {
          "validate": [Function],
          "vendor": "zod",
          "version": 1,
        },
      },
    },
    "tool": "invokeAgent",
    "type": "tool",
  },
}
`;

exports[`should handle user cancellation of initial task input 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "default": undefined,
      "message": "What is the task you want to plan?",
    },
    "tool": "input",
    "type": "tool",
  },
}
`;

exports[`should handle user cancellation of initial task input 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle user cancellation of feedback input 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "choices": [
        {
          "name": "Save Plan",
          "value": "save",
        },
        {
          "name": "Execute Plan",
          "value": "execute",
        },
        {
          "name": "Provide Feedback",
          "value": "feedback",
        },
        {
          "name": "Regenerate Plan",
          "value": "regenerate",
        },
        {
          "name": "Exit",
          "value": "exit",
        },
      ],
      "message": "What do you want to do?",
    },
    "tool": "select",
    "type": "tool",
  },
}
`;

exports[`should save a new plan directly using a provided filePath 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "content": "My plan",
      "path": "path/to/plan.md",
    },
    "tool": "writeToFile",
    "type": "tool",
  },
}
`;

exports[`should handle user cancellation of save path input 1`] = `
{
  "error": [Error: User cancelled],
  "status": "failed",
}
`;

exports[`should update existing plan with filePath provided 1`] = `
{
  "next": [Function: AsyncFunction],
  "status": "pending",
  "throw": [Function: AsyncFunction],
  "tool": {
    "input": {
      "content": 
"# Security Audit

1. Review authentication
2. Check authorization
3. Audit data encryption
4. Review API security"
,
      "path": "docs/security-audit.md",
    },
    "tool": "writeToFile",
    "type": "tool",
  },
}
`;

exports[`should update existing plan with filePath provided 2`] = `
{
  "output": {},
  "status": "completed",
}
`;

exports[`should handle regenerate after feedback 1`] = `
{
  "output": {},
  "status": "completed",
}
`;
