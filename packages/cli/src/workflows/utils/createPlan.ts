// generated by polka.codes

import type { WorkflowTools } from '@polka-codes/workflow'
import { z } from 'zod'
import type { CliToolRegistry } from '../../workflow-tools'
import type { JsonFilePart, JsonImagePart } from '../code.workflow'
import { PLAN_PROMPT } from '../prompts'

const PlanSchema = z.object({
  plan: z.string().nullish(),
  question: z.string().nullish(),
  reason: z.string().nullish(),
  files: z.array(z.string()).nullish(),
})

export type CreatePlanOutput = {
  plan?: string
  reason?: string
  files?: { path: string; content: string }[]
}

type CreatePlanInput = {
  tools: WorkflowTools<CliToolRegistry>
  task: string
  plan?: string
  userFeedback?: string
  files?: (JsonFilePart | JsonImagePart)[]
}

export async function* createPlan(input: CreatePlanInput): AsyncGenerator<any, CreatePlanOutput, any> {
  const { tools, task, files } = input
  let plan = input.plan || ''
  let userFeedback = input.userFeedback || ''

  while (true) {
    const currentTask = userFeedback ? `${task}\n\nUser feedback: ${userFeedback}` : task
    const planContent = plan ? `The content of an existing plan file:\n<plan_file>\n${plan}\n</plan_file>` : ''
    const prompt = PLAN_PROMPT.replace('{task}', currentTask).replace('{planContent}', planContent)

    const messages: any[] = [{ type: 'user', content: prompt }]
    if (files) {
      messages[0].content = [
        prompt,
        ...files.map((f) => ({
          ...f,
          image: f.type === 'image' ? Buffer.from(f.image, 'base64') : undefined,
          data: f.type === 'file' ? Buffer.from(f.data, 'base64') : undefined,
        })),
      ]
    }

    const { output } = yield* tools.invokeAgent({
      agent: 'architect',
      messages,
      outputSchema: PlanSchema,
      defaultContext: true,
    })

    const { plan: newPlan, question, reason, files: filePaths } = output as z.infer<typeof PlanSchema>

    if (reason) {
      return { reason }
    }

    if (newPlan !== undefined) {
      plan = newPlan || ''
    }

    if (question) {
      const answer = yield* tools.input({ message: question })
      userFeedback = `Question: ${question}\nAnswer: ${answer}`
    } else {
      const files: { path: string; content: string }[] = []
      if (filePaths) {
        for (const path of filePaths) {
          try {
            const content = yield* tools.readFile({ path })
            files.push({ path, content })
          } catch (_e) {
            // ignore file read errors
          }
        }
      }
      return { plan, files }
    }
  }
}
