// generated by polka.codes

import { expect, mock, test } from 'bun:test'
import { createContext } from '@polka-codes/core'
import { createWorkflowTestContext } from '../test/workflow-fixtures'
import { prWorkflow } from './pr.workflow'

const createMockContext = () => {
  const { context: baseContext, tools } = createWorkflowTestContext()

  // Add PR-specific tools
  tools.createPullRequest = mock(async (details) => details)
  tools.createCommit = mock(async () => ({ message: '' }))
  tools.printChangeFile = mock(async () => ({ stagedFiles: [], unstagedFiles: [] }))
  tools.confirm = mock(async () => true)
  tools.input = mock(async () => '')
  tools.select = mock(async () => '')
  tools.writeToFile = mock(async () => {})
  tools.readFile = mock(async () => '')
  tools.invokeTool = mock(async () => ({ success: true, message: { type: 'text', value: '' } }))

  const run = (input: any) => {
    const context = createContext(tools as any)
    const testContext = {
      ...context,
      step: (_name: string, arg2: any, arg3?: any) => {
        const fn = (typeof arg2 === 'function' ? arg2 : arg3) as () => Promise<any>
        return fn()
      },
    }
    return prWorkflow(input, testContext)
  }

  return {
    tools,
    run,
  }
}

test('should create PR with user context', async () => {
  const { tools, run } = createMockContext()

  // Mock the sequence of executeCommand calls
  tools.executeCommand
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'gh version 2.40.0', stderr: '' }) // gh --version
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'feature/add-auth\n', stderr: '' }) // git rev-parse
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref master
    .mockResolvedValueOnce({ exitCode: 0, stdout: '', stderr: '' }) // git show-ref main
    .mockResolvedValueOnce({
      exitCode: 0,
      stdout: 'abc1234 feat: add authentication module\ndef5678 fix: resolve login bug\n',
      stderr: '',
    }) // git log
    .mockResolvedValueOnce({
      exitCode: 0,
      stdout: `--- a/src/auth.ts
+++ b/src/auth.ts
@@ -1,3 +1,5 @@
+export function authenticate() {
+  return true;
}
 export function login() {}`,
      stderr: '',
    }) // git diff

  // Mock agent workflow response
  tools.generateText.mockResolvedValue([
    {
      role: 'assistant',
      content: JSON.stringify({
        title: 'feat: add authentication feature',
        description:
          'This PR implements the authentication feature for the application.\n\n### Changes\n- Added authenticate function\n- Fixed login bug',
      }),
    },
  ])

  const result = await run({ context: 'Implementing new authentication feature' })

  expect(result).toEqual({
    title: 'feat: add authentication feature',
    description:
      'This PR implements the authentication feature for the application.\n\n### Changes\n- Added authenticate function\n- Fixed login bug',
  })

  expect(tools.executeCommand).toHaveBeenCalledTimes(6)
  expect(tools.generateText).toHaveBeenCalledTimes(1)
  expect(tools.createPullRequest).toHaveBeenCalledTimes(1)
})

test('should fail when GitHub CLI is not installed', async () => {
  const { tools, run } = createMockContext()

  tools.executeCommand.mockResolvedValueOnce({
    exitCode: 1,
    stdout: '',
    stderr: 'command not found: gh',
  })

  await expect(run({})).rejects.toThrow('GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
})

test('should fail when unable to determine default branch', async () => {
  const { tools, run } = createMockContext()

  tools.executeCommand
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'gh version 2.40.0', stderr: '' }) // gh --version
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'feature/my-branch\n', stderr: '' }) // git rev-parse
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: 'not a git repository' }) // gh repo view
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref master
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref main
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref develop
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: 'fatal: No remote named origin' }) // git remote show origin

  await expect(run({})).rejects.toThrow('Could not determine default branch name.')
})
