// generated by polka.codes

import { expect, mock, test } from 'bun:test'
import { ToolResponseType } from '@polka-codes/core'
import type { WorkflowContextV2 } from '@polka-codes/workflow'
import { createContext } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { prWorkflow } from './pr.workflow'

const createMockContext = () => {
  const toolHandler = {
    executeCommand: mock(async () => ({ exitCode: 0, stdout: '', stderr: '' })),
    createPullRequest: mock(async (details) => details),
    generateText: mock(async () => {
      return [
        {
          role: 'assistant',
          content: JSON.stringify({
            title: 'feat: add authentication feature',
            description:
              'This PR implements the authentication feature for the application.\n\n### Changes\n- Added authenticate function\n- Fixed login bug',
          }),
        },
      ]
    }),
    taskEvent: mock(async () => {}),
    // Add other necessary mocks from CliToolRegistry here
    invokeAgent: mock(async () => ({ output: {}, messages: [] })),
    createCommit: mock(async () => ({ message: '' })),
    printChangeFile: mock(async () => ({ stagedFiles: [], unstagedFiles: [] })),
    confirm: mock(async () => true),
    input: mock(async () => ''),
    select: mock(async () => ''),
    writeToFile: mock(async () => {}),
    readFile: mock(async () => ''),
    invokeTool: mock(async () => ({ type: ToolResponseType.Reply, message: { type: 'text', value: '' } })),
  }

  const run = (input: any) => {
    const context = createContext<CliToolRegistry>(toolHandler as any)
    const testContext: WorkflowContextV2<CliToolRegistry> = {
      ...context,
      step: (_name, fn) => {
        // In tests, we can simplify the step function to execute immediately
        return fn()
      },
    }
    return prWorkflow(input, testContext)
  }

  return {
    toolHandler,
    run,
  }
}

test('should create PR with user context', async () => {
  const { toolHandler, run } = createMockContext()

  // Mock the sequence of executeCommand calls
  toolHandler.executeCommand
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'gh version 2.40.0', stderr: '' }) // gh --version
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'feature/add-auth\n', stderr: '' }) // git rev-parse
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref master
    .mockResolvedValueOnce({ exitCode: 0, stdout: '', stderr: '' }) // git show-ref main
    .mockResolvedValueOnce({
      exitCode: 0,
      stdout: 'abc1234 feat: add authentication module\ndef5678 fix: resolve login bug\n',
      stderr: '',
    }) // git log
    .mockResolvedValueOnce({
      exitCode: 0,
      stdout: `--- a/src/auth.ts
+++ b/src/auth.ts
@@ -1,3 +1,5 @@
+export function authenticate() {
+  return true;
+}
 export function login() {}`,
      stderr: '',
    }) // git diff

  const result = await run({ context: 'Implementing new authentication feature' })

  expect(result).toEqual({
    title: 'feat: add authentication feature',
    description:
      'This PR implements the authentication feature for the application.\n\n### Changes\n- Added authenticate function\n- Fixed login bug',
  })

  expect(toolHandler.executeCommand).toHaveBeenCalledTimes(6)
  expect(toolHandler.generateText).toHaveBeenCalledTimes(1)
  expect(toolHandler.createPullRequest).toHaveBeenCalledTimes(1)
})

test('should fail when GitHub CLI is not installed', async () => {
  const { toolHandler, run } = createMockContext()

  toolHandler.executeCommand.mockResolvedValueOnce({
    exitCode: 1,
    stdout: '',
    stderr: 'command not found: gh',
  })

  await expect(run({})).rejects.toThrow('GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
})

test('should fail when unable to determine default branch', async () => {
  const { toolHandler, run } = createMockContext()

  toolHandler.executeCommand
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'gh version 2.40.0', stderr: '' }) // gh --version
    .mockResolvedValueOnce({ exitCode: 0, stdout: 'feature/my-branch\n', stderr: '' }) // git rev-parse
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: 'not a git repository' }) // gh repo view
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref master
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref main
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: '' }) // git show-ref develop
    .mockResolvedValueOnce({ exitCode: 1, stdout: '', stderr: 'fatal: No remote named origin' }) // git remote show origin

  await expect(run({})).rejects.toThrow('Could not determine default branch name.')
})
