// generated by polka.codes
import { loadConfig } from '@polka-codes/cli-shared'
import {
  agentWorkflow,
  executeCommand,
  fetchUrl,
  listFiles,
  listMemoryTopics,
  readBinaryFile,
  readFile,
  readMemory,
  removeFile,
  renameFile,
  replaceInFile,
  searchFiles,
  updateMemory,
  type WorkflowFn,
  writeToFile,
} from '@polka-codes/core'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import { FIX_SYSTEM_PROMPT, getFixUserPrompt } from './prompts'
import { getDefaultContext } from './workflow.utils'

export type FixWorkflowInput = {
  command?: string
  task?: string
  interactive?: boolean
}

const FixIterationSummarySchema = z
  .object({
    summary: z.string().nullish(),
    bailReason: z.string().nullish(),
  })
  .refine((data) => (data.summary != null) !== (data.bailReason != null), {
    message: 'Either summary or bailReason must be provided, but not both',
  })

export const fixWorkflow: WorkflowFn<
  FixWorkflowInput,
  { success: true; summaries: string[] } | { success: false; reason: string; summaries: string[] },
  CliToolRegistry
> = async (input, context) => {
  const { tools, logger, step } = context
  const { command: inputCommand, task, interactive = true } = input
  let command = inputCommand
  const summaries: string[] = []
  let formatCommand: string | undefined

  if (!command) {
    const config = loadConfig()
    const check = config?.scripts?.check
    const test = config?.scripts?.test
    const format = config?.scripts?.format

    let checkCommand: string | undefined
    if (typeof check === 'string') {
      checkCommand = check
    } else if (check) {
      checkCommand = check.command
    }

    let testCommand: string | undefined
    if (typeof test === 'string') {
      testCommand = test
    } else if (test) {
      testCommand = test.command
    }

    if (typeof format === 'string') {
      formatCommand = format
    } else if (format) {
      formatCommand = format.command
    }

    let defaultCommand: string | undefined
    if (checkCommand && testCommand) {
      defaultCommand = `${checkCommand} && ${testCommand}`
    } else if (checkCommand) {
      defaultCommand = checkCommand
    } else if (testCommand) {
      defaultCommand = testCommand
    }

    if (interactive) {
      command = await tools.input({
        message: 'Please enter the command to run to identify issues:',
        default: defaultCommand,
      })

      if (!command) {
        throw new Error('No command provided. Aborting.')
      }
    } else {
      command = defaultCommand
    }

    if (!command) {
      logger.info('No command to run.')
      return { success: true, summaries }
    }
  }

  for (let i = 0; i < 10; i++) {
    logger.info(`Running command (attempt ${i + 1}/10): ${command}`)
    if (formatCommand) {
      await tools.executeCommand({ command: formatCommand, shell: true, pipe: true })
    }
    const { exitCode, stdout, stderr } = await tools.executeCommand({
      command,
      shell: true,
      pipe: true,
    })

    if (exitCode === 0) {
      logger.info('Command succeeded!')
      return { success: true, summaries }
    }

    logger.info(`Command failed with exit code ${exitCode}. Asking agent to fix it...`)

    const result = await step(`fix-${i}`, async () => {
      const defaultContext = await getDefaultContext()
      const memoryContext = await tools.getMemoryContext()
      const userPrompt = getFixUserPrompt(command, exitCode, stdout, stderr, task)
      return await agentWorkflow(
        {
          systemPrompt: FIX_SYSTEM_PROMPT,
          userMessage: [
            {
              role: 'user',
              content: `${userPrompt}\n\n${defaultContext}\n${memoryContext}`,
            },
          ],
          tools: [
            readFile,
            writeToFile,
            replaceInFile,
            searchFiles,
            listFiles,
            executeCommand,
            fetchUrl,
            readBinaryFile,
            removeFile,
            renameFile,
            readMemory,
            updateMemory,
            listMemoryTopics,
          ],
          outputSchema: FixIterationSummarySchema,
        },
        context,
      )
    })

    const res = await step(`fix-summary-${i}`, async () => {
      if (result.type === 'Exit' && result.object) {
        const { summary, bailReason } = result.object as z.infer<typeof FixIterationSummarySchema>

        if (bailReason) {
          logger.warn(`Agent bailed: ${bailReason}`)
          return { bailReason }
        }

        if (summary) {
          summaries.push(summary)
          await tools.updateMemory({ operation: 'append', content: `Summary of changes for fix attempt ${i + 1}: ${summary}` })
          logger.info(`Summary of changes: ${summary}`)
        }
      }
    })

    if (res?.bailReason) {
      return { success: false, summaries, reason: res.bailReason }
    }
  }

  logger.error('Failed to fix the issue after maximum attempts.')
  return { success: false, summaries, reason: 'Failed to fix the issue after maximum attempts.' }
}
