// generated by polka.codes

import { execSync } from 'node:child_process'
import { confirm } from '@inquirer/prompts'
import {
  builder,
  type CustomStepSpec,
  parseJsonFromMarkdown,
  type StepRunResult,
  type WorkflowContext,
  type WorkflowSpec,
} from '@polka-codes/core'
import type { Ora } from 'ora'
import { z } from 'zod'
import { gitDiff } from '../tools'

export type HandleResultOutput = {
  shouldRunTask: boolean
  formattedReview?: string
}

type FileChange = {
  path: string
  status: string
}

type ReviewToolInput = {
  pullRequestTitle?: string
  pullRequestDescription?: string
  commitMessages?: string
  commitRange?: string
  staged?: boolean
  changedFiles?: FileChange[]
}

type ReviewWorkflowInput = {
  pr?: string
  json: boolean
}

export interface ReviewWorkflowContext extends WorkflowContext {
  ui: { spinner: Ora }
}

function parseGitStatus(statusOutput: string): FileChange[] {
  const statusLines = statusOutput.split('\n').filter((line) => line)
  const files: FileChange[] = []

  for (const line of statusLines) {
    const indexStatus = line[0]
    const workingTreeStatus = line[1]
    const filepath = line.slice(3)

    const statuses = []
    if (indexStatus !== ' ' && indexStatus !== '?') {
      switch (indexStatus) {
        case 'A':
          statuses.push('Added (staged)')
          break
        case 'M':
          statuses.push('Modified (staged)')
          break
        case 'D':
          statuses.push('Deleted (staged)')
          break
        case 'R':
          statuses.push('Renamed (staged)')
          break
        case 'C':
          statuses.push('Copied (staged)')
          break
        default:
          statuses.push('Changed (staged)')
      }
    }
    if (workingTreeStatus !== ' ') {
      switch (workingTreeStatus) {
        case 'M':
          statuses.push('Modified (unstaged)')
          break
        case 'D':
          statuses.push('Deleted (unstaged)')
          break
        case '?':
          statuses.push('Untracked')
          break
        default:
          statuses.push('Changed (unstaged)')
      }
    }

    if (statuses.length > 0) {
      files.push({ path: filepath, status: statuses.join(', ') })
    }
  }

  return files
}

function parseGitDiffNameStatus(diffOutput: string): FileChange[] {
  const lines = diffOutput.split('\n').filter((line) => line.trim())
  return lines.map((line) => {
    const [status, ...pathParts] = line.split('\t')
    const path = pathParts.join('\t')
    let statusDescription: string
    switch (status[0]) {
      case 'A':
        statusDescription = 'Added'
        break
      case 'M':
        statusDescription = 'Modified'
        break
      case 'D':
        statusDescription = 'Deleted'
        break
      case 'R':
        statusDescription = 'Renamed'
        break
      case 'C':
        statusDescription = 'Copied'
        break
      case 'T':
        statusDescription = 'Type changed'
        break
      default:
        statusDescription = 'Unknown'
    }
    return { path, status: statusDescription }
  })
}

function printChangedFiles(changedFiles: FileChange[], spinner: Ora, isJsonOutput: boolean) {
  if (changedFiles.length === 0) {
    return
  }
  spinner.stop()
  const stream = isJsonOutput ? process.stderr : process.stdout
  const log = (message: string) =>
    stream.write(`${message}
`)
  log('Changed files:')
  for (const file of changedFiles) {
    log(`- ${file.status}: ${file.path}`)
  }
  spinner.start()
}

const specificReviewSchema = z.object({
  file: z.string(),
  lines: z.string(),
  review: z.string(),
})

const reviewOutputSchema = z.object({
  overview: z.string(),
  specificReviews: z.array(specificReviewSchema),
})

type ReviewResult = z.infer<typeof reviewOutputSchema>

function formatReviewForConsole(output: ReviewResult): string {
  let formatted = `### Overview\n\n${output.overview}`

  if (output.specificReviews.length > 0) {
    formatted += `\n\n### File-specific feedback\n`
    for (const item of output.specificReviews) {
      formatted += `\n- ${item.file}#${item.lines}\n\n${item.review}\n`
    }
  }
  return formatted
}

const CODE_REVIEW_PROMPT = `
# Code Review Prompt

You are a senior software engineer reviewing code changes.

## Critical Instructions
- **ONLY review the actual changes shown in the diff.** Do not comment on existing code that wasn't modified.
- **ONLY run git_diff on files that are reviewable source/config files** per the "File Selection for git_diff" rules below. Do not pass excluded files to git_diff.

## File Selection for git_diff
Use <file_status> to decide which files to diff. Include only files likely to contain human-authored source or meaningful configuration.

Include (run git_diff):
- Application/source code
- UI/templates/assets code
- Infra/config that affects behavior

Exclude (do NOT run git_diff; do not review):
- Lockfiles
- Generated/build artifacts & deps
- Test artifacts/snapshots
- Data and fixtures
- Binary/media/minified/maps

## Viewing Changes
- For each included file, **use git_diff** to inspect the actual code changes:
  - **Pull request:** use the provided commit range for the git_diff tool with contextLines: 5 and includeLineNumbers: true, but only surface and review the included files.
  - **Local changes:** diff staged or unstaged included files using git_diff with contextLines: 5 and includeLineNumbers: true.
- The diff will include line number annotations: [Line N] for additions and [Line N removed] for deletions.
- You may receive:
  - <pr_title>
  - <pr_description>
  - <commit_messages>
- A <review_instructions> tag tells you the focus of the review.
- Use <file_status> to understand which files were modified, added, deleted, or renamed and to apply the inclusion/exclusion rules above.

## Line Number Reporting
- Use the line numbers from the annotations in the diff output.
- For additions: use the number from the [Line N] annotation after the + line.
- For deletions: use the number from the [Line N removed] annotation after the - line.
- For modifications: report the line number of the new/current code (from [Line N]).
- Report single lines as "N" and ranges as "N-M".

## Review Guidelines
Focus exclusively on the changed lines (+ additions, - deletions, modified lines):
- **Specific issues:** Point to exact problems in the changed code with accurate line references from the annotations.
- **Actionable fixes:** Provide concrete solutions, not vague suggestions.
- **Clear reasoning:** Explain why each issue matters and how to fix it.
- **Avoid generic advice** unless directly tied to a specific problem visible in the diff.

## What NOT to review
- Files excluded by the "File Selection for git_diff" rules (do not diff or comment on them).
- Existing unchanged code.
- Overall project structure/architecture unless directly impacted by the changes.
- Missing features or functionality not part of this diff.

## Output Format
Do not include praise or positive feedback.
Only include reviews for actual issues found in the changed code.

Return your review as a JSON object in the following format:
\`\`\`json
{
  "overview": "Summary of specific issues found in the diff changes, 'No issues found', or 'No reviewable changes' if all modified files were excluded.",
  "specificReviews": [
    {
      "file": "path/filename.ext",
      "lines": "N or N-M",
      "review": "Specific issue with the changed code and exact actionable fix."
    }
  ]
}
\`\`\`
`

const getChangeInfo: CustomStepSpec<ReviewWorkflowInput, { json: boolean; changeInfo?: ReviewToolInput }> = {
  id: 'get-change-info',
  type: 'custom' as const,
  run: async (
    input,
    context: WorkflowContext,
    _resumedState?: any,
  ): Promise<StepRunResult<{ json: boolean; changeInfo?: ReviewToolInput }>> => {
    const { pr, json } = input
    ;(context as any).json = json
    const {
      ui: { spinner },
    } = context as ReviewWorkflowContext
    let changeInfo: ReviewToolInput

    if (pr) {
      const prNumberMatch = pr.match(/\d+$/)
      if (!prNumberMatch) {
        throw new Error('Invalid PR number or URL.')
      }
      const prNumber = prNumberMatch[0]

      try {
        execSync('gh --version', { stdio: 'ignore' })
      } catch {
        throw new Error('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
      }

      try {
        spinner.text = `Checking out PR #${prNumber}...`
        execSync(`gh pr checkout ${prNumber}`, { stdio: 'pipe' })
      } catch (error) {
        console.error(error)
        throw new Error(`Error checking out PR #${prNumber}. Make sure the PR number is correct and you have access to the repository.`)
      }

      spinner.text = 'Fetching pull request details...'
      const prDetails = JSON.parse(
        execSync(`gh pr view ${prNumber} --json title,body,commits,baseRefName,baseRefOid`, {
          encoding: 'utf-8',
        }),
      )
      const commitMessages = prDetails.commits.map((c: any) => c.messageBody).join('\n---\n')
      spinner.text = 'Getting file changes...'
      let changedFiles: FileChange[] = []
      try {
        const diffNameStatus = execSync(`git diff --name-status --no-color ${prDetails.baseRefOid}...HEAD`, {
          encoding: 'utf-8',
        })
        changedFiles = parseGitDiffNameStatus(diffNameStatus)
      } catch (_error) {
        console.warn('Warning: Could not retrieve file changes list')
      }

      printChangedFiles(changedFiles, spinner, json)
      changeInfo = {
        commitRange: `${prDetails.baseRefOid}...HEAD`,
        pullRequestTitle: prDetails.title,
        pullRequestDescription: prDetails.body,
        commitMessages,
        changedFiles,
      }
    } else {
      const gitStatus = execSync('git status --porcelain=v1', { encoding: 'utf-8' })
      const statusLines = gitStatus.split('\n').filter((line) => line)
      const hasLocalChanges = statusLines.length > 0

      if (hasLocalChanges) {
        const hasStagedChanges = statusLines.some((line) => line[0] !== ' ' && line[0] !== '?')
        const changedFiles = parseGitStatus(gitStatus)
        printChangedFiles(changedFiles, spinner, json)
        changeInfo = {
          staged: hasStagedChanges,
          changedFiles,
        }
      } else {
        spinner.text = 'No local changes detected. Falling back to branch diff...'
        spinner.render()

        try {
          execSync('gh --version', { stdio: 'ignore' })
        } catch {
          throw new Error(
            'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
          )
        }

        const defaultBranch = execSync('gh repo view --json defaultBranchRef --jq .defaultBranchRef.name', {
          encoding: 'utf-8',
        }).trim()

        const currentBranch = execSync('git rev-parse --abbrev-ref HEAD', {
          encoding: 'utf-8',
        }).trim()

        if (currentBranch === defaultBranch) {
          spinner.succeed(`No changes to review. You are on the default branch ('${defaultBranch}').`)
          return { type: 'success', output: { json } }
        }

        spinner.text = 'Getting file changes...'
        let branchChangedFiles: FileChange[] = []
        try {
          const diffNameStatus = execSync(`git diff --name-status --no-color ${defaultBranch}...${currentBranch}`, { encoding: 'utf-8' })
          branchChangedFiles = parseGitDiffNameStatus(diffNameStatus)
        } catch (_error) {
          console.warn('Warning: Could not retrieve file changes list')
        }

        printChangedFiles(branchChangedFiles, spinner, json)

        changeInfo = {
          commitRange: `${defaultBranch}...${currentBranch}`,
          changedFiles: branchChangedFiles,
        }
      }
    }
    if (changeInfo) {
      spinner.text = 'Generating review...'
    }

    return { type: 'success', output: { json, changeInfo } }
  },
}

function formatReviewToolInput(params: ReviewToolInput): string {
  const parts = []
  if (params.pullRequestTitle) {
    parts.push(`<pr_title>\n${params.pullRequestTitle}\n</pr_title>`)
  }
  if (params.pullRequestDescription) {
    parts.push(`<pr_description>\n${params.pullRequestDescription}\n</pr_description>`)
  }
  if (params.commitMessages) {
    parts.push(`<commit_messages>\n${params.commitMessages}\n</commit_messages>`)
  }

  if (params.changedFiles && params.changedFiles.length > 0) {
    const fileList = params.changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
    parts.push(`<file_status>\n${fileList}\n</file_status>`)
  }

  let instructions = ''
  if (params.commitRange) {
    instructions = `Review the pull request. Use the git_diff tool with commit range '${params.commitRange}', contextLines: 5, and includeLineNumbers: true to inspect the actual code changes. The diff will include line number annotations to help you report accurate line numbers. File status information is already provided above.`
  } else if (params.staged) {
    instructions =
      'Review the staged changes. Use the git_diff tool with staged: true, contextLines: 5, and includeLineNumbers: true to inspect the actual code changes. The diff will include line number annotations to help you report accurate line numbers. File status information is already provided above.'
  } else {
    instructions =
      'Review the unstaged changes. Use the git_diff tool with contextLines: 5, and includeLineNumbers: true to inspect the actual code changes. The diff will include line number annotations to help you report accurate line numbers. File status information is already provided above.'
  }
  parts.push(`<review_instructions>\n${instructions}\n</review_instructions>`)

  return parts.join('\n')
}

const handleResult: CustomStepSpec<ReviewResult, HandleResultOutput> = {
  id: 'handle-result',
  type: 'custom' as const,
  run: async (input, context, _resumedState) => {
    const { overview, specificReviews } = input
    const json = (context as any).json as boolean
    const {
      ui: { spinner },
    } = context as ReviewWorkflowContext

    const reviewResult = overview && specificReviews ? { overview, specificReviews: specificReviews } : undefined

    if (reviewResult) {
      spinner.succeed('Review generated successfully')
    }

    if (!reviewResult) {
      return { type: 'success', output: { shouldRunTask: false } }
    }
    if (json) {
      console.log(JSON.stringify(reviewResult, null, 2))
      return { type: 'success', output: { shouldRunTask: false } }
    }

    const formatted = formatReviewForConsole(reviewResult)
    console.log(formatted)

    let shouldRunTask = false

    if (process.stdin.isTTY && reviewResult.specificReviews.length > 0) {
      try {
        shouldRunTask = await confirm({
          message: 'Do you wish polka-codes to address the review results?',
          default: false,
        })
      } catch {
        process.exit(130)
      }
    }
    const output: HandleResultOutput = { shouldRunTask }
    if (shouldRunTask) {
      output.formattedReview = formatted
    }
    return {
      type: 'success',
      output,
    }
  },
}

export const reviewWorkflow: WorkflowSpec<ReviewWorkflowInput, HandleResultOutput> = {
  name: 'Code Review',
  description: 'Review code changes in a pull request or local changes using AI.',
  step: builder<ReviewWorkflowInput>()
    .custom(getChangeInfo)
    .agent('generate-review', {
      agent: 'analyzer',
      messages: [
        CODE_REVIEW_PROMPT,
        {
          type: 'function',
          fn: (input) => {
            if (!input.changeInfo) {
              return ''
            }
            return formatReviewToolInput(input.changeInfo)
          },
        },
      ],
      tools: [gitDiff],
      outputSchema: reviewOutputSchema,
      parseOutput: parseJsonFromMarkdown,
    })
    .custom(handleResult)
    .build(),
}
