// generated by polka.codes

import { execSync } from 'node:child_process'
import type { Workflow } from '@polka-codes/workflow'
import { gitDiff } from '../tools'
import type { WorkflowTools } from '../workflow-tools'
import { parseGitDiffNameStatus, parseGitStatus, printChangedFiles, type ReviewResult, reviewOutputSchema } from './workflow.utils'

type FileChange = {
  path: string
  status: string
}

type ReviewToolInput = {
  pullRequestTitle?: string
  pullRequestDescription?: string
  commitMessages?: string
  commitRange?: string
  staged?: boolean
  changedFiles?: FileChange[]
}

export type ReviewWorkflowInput = {
  pr?: string
  json: boolean
}

const CODE_REVIEW_PROMPT = `
# Code Review Prompt

You are a senior software engineer reviewing code changes.

## Critical Instructions
- **ONLY review the actual changes shown in the diff.** Do not comment on existing code that wasn't modified.
- **ONLY run git_diff on files that are reviewable source/config files** per the "File Selection for git_diff" rules below. Do not pass excluded files to git_diff.

## File Selection for git_diff
Use <file_status> to decide which files to diff. Include only files likely to contain human-authored source or meaningful configuration.

Include (run git_diff):
- Application/source code
- UI/templates/assets code
- Infra/config that affects behavior

Exclude (do NOT run git_diff; do not review):
- Lockfiles
- Generated/build artifacts & deps
- Test artifacts/snapshots
- Data and fixtures
- Binary/media/minified/maps

## Viewing Changes
- For each included file, **use git_diff** to inspect the actual code changes:
  - **Pull request:** use the provided commit range for the git_diff tool with contextLines: 5 and includeLineNumbers: true, but only surface and review the included files.
  - **Local changes:** diff staged or unstaged included files using git_diff with contextLines: 5 and includeLineNumbers: true.
- The diff will include line number annotations: [Line N] for additions and [Line N removed] for deletions.
- You may receive:
  - <pr_title>
  - <pr_description>
  - <commit_messages>
- A <review_instructions> tag tells you the focus of the review.
- Use <file_status> to understand which files were modified, added, deleted, or renamed and to apply the inclusion/exclusion rules above.

## Line Number Reporting
- Use the line numbers from the annotations in the diff output.
- For additions: use the number from the [Line N] annotation after the + line.
- For deletions: use the number from the [Line N removed] annotation after the - line.
- For modifications: report the line number of the new/current code (from [Line N]).
- Report single lines as "N" and ranges as "N-M".

## Review Guidelines
Focus exclusively on the changed lines (+ additions, - deletions, modified lines):
- **Specific issues:** Point to exact problems in the changed code with accurate line references from the annotations.
- **Actionable fixes:** Provide concrete solutions, not vague suggestions.
- **Clear reasoning:** Explain why each issue matters and how to fix it.
- **Avoid generic advice** unless directly tied to a specific problem visible in the diff.

## What NOT to review
- Files excluded by the "File Selection for git_diff" rules (do not diff or comment on them).
- Existing unchanged code.
- Overall project structure/architecture unless directly impacted by the changes.
- Missing features or functionality not part of this diff.

## Output Format
Do not include praise or positive feedback.
Only include reviews for actual issues found in the changed code.

Return your review as a JSON object in the following format:
\`\`\`json
{
  "overview": "Summary of specific issues found in the diff changes, 'No issues found', or 'No reviewable changes' if all modified files were excluded.",
  "specificReviews": [
    {
      "file": "path/filename.ext",
      "lines": "N or N-M",
      "review": "Specific issue with the changed code and exact actionable fix."
    }
  ]
}
\`\`\`
`

function formatReviewToolInput(params: ReviewToolInput): string {
  const parts = []
  if (params.pullRequestTitle) {
    parts.push(`<pr_title>\n${params.pullRequestTitle}\n</pr_title>`)
  }
  if (params.pullRequestDescription) {
    parts.push(`<pr_description>\n${params.pullRequestDescription}\n</pr_description>`)
  }
  if (params.commitMessages) {
    parts.push(`<commit_messages>\n${params.commitMessages}\n</commit_messages>`)
  }

  if (params.changedFiles && params.changedFiles.length > 0) {
    const fileList = params.changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
    parts.push(`<file_status>\n${fileList}\n</file_status>`)
  }

  let instructions = ''
  if (params.commitRange) {
    instructions = `Review the pull request. Use the git_diff tool with commit range '${params.commitRange}', contextLines: 5, and includeLineNumbers: true to inspect the actual code changes. The diff will include line number annotations to help you report accurate line numbers. File status information is already provided above.`
  } else if (params.staged) {
    instructions =
      'Review the staged changes. Use the git_diff tool with staged: true, contextLines: 5, and includeLineNumbers: true to inspect the actual code changes. The diff will include line number annotations to help you report accurate line numbers. File status information is already provided above.'
  } else {
    instructions =
      'Review the unstaged changes. Use the git_diff tool with contextLines: 5, and includeLineNumbers: true to inspect the actual code changes. The diff will include line number annotations to help you report accurate line numbers. File status information is already provided above.'
  }
  parts.push(`<review_instructions>\n${instructions}\n</review_instructions>`)

  return parts.join('\n')
}

export const reviewWorkflow: Workflow<ReviewWorkflowInput, ReviewResult, WorkflowTools> = {
  name: 'Code Review',
  description: 'Review code changes in a pull request or local changes using AI.',
  async *fn(input, step, tools) {
    const { pr, json } = input
    let changeInfo: ReviewToolInput | undefined

    if (pr) {
      const prNumberMatch = pr.match(/\d+$/)
      if (!prNumberMatch) {
        throw new Error('Invalid PR number or URL.')
      }
      const prNumber = prNumberMatch[0]

      try {
        execSync('gh --version', { stdio: 'ignore' })
      } catch {
        throw new Error('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
      }

      await step(`Checking out PR #${prNumber}...`, async () => {
        try {
          execSync(`gh pr checkout ${prNumber}`, { stdio: 'pipe' })
        } catch (error) {
          console.error(error)
          throw new Error(`Error checking out PR #${prNumber}. Make sure the PR number is correct and you have access to the repository.`)
        }
      })

      const prDetails = await step('Fetching pull request details...', async () =>
        JSON.parse(
          execSync(`gh pr view ${prNumber} --json title,body,commits,baseRefName,baseRefOid`, {
            encoding: 'utf-8',
          }),
        ),
      )
      const commitMessages = prDetails.commits.map((c: any) => c.messageBody).join('\n---\n')
      const changedFiles: FileChange[] = await step('Getting file changes...', async () => {
        try {
          const diffNameStatus = execSync(`git diff --name-status --no-color ${prDetails.baseRefOid}...HEAD`, {
            encoding: 'utf-8',
          })
          return parseGitDiffNameStatus(diffNameStatus)
        } catch (_error) {
          console.warn('Warning: Could not retrieve file changes list')
          return []
        }
      })

      if (!json) {
        printChangedFiles('Changed files:', changedFiles)
      }
      changeInfo = {
        commitRange: `${prDetails.baseRefOid}...HEAD`,
        pullRequestTitle: prDetails.title,
        pullRequestDescription: prDetails.body,
        commitMessages,
        changedFiles,
      }
    } else {
      const gitStatus = execSync('git status --porcelain=v1', { encoding: 'utf-8' })
      const statusLines = gitStatus.split('\n').filter((line) => line)
      const hasLocalChanges = statusLines.length > 0

      if (hasLocalChanges) {
        const hasStagedChanges = statusLines.some((line) => line[0] !== ' ' && line[0] !== '?')
        const changedFiles = parseGitStatus(gitStatus)
        if (!json) {
          printChangedFiles('Changed files:', changedFiles)
        }
        changeInfo = {
          staged: hasStagedChanges,
          changedFiles,
        }
      } else {
        await step('No local changes detected. Falling back to branch diff...', async () => {})

        try {
          execSync('gh --version', { stdio: 'ignore' })
        } catch {
          throw new Error(
            'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
          )
        }

        const defaultBranch = execSync('gh repo view --json defaultBranchRef --jq .defaultBranchRef.name', {
          encoding: 'utf-8',
        }).trim()

        const currentBranch = execSync('git rev-parse --abbrev-ref HEAD', {
          encoding: 'utf-8',
        }).trim()

        if (currentBranch === defaultBranch) {
          await step(`No changes to review. You are on the default branch ('${defaultBranch}').`, async () => {})
          console.log(`No changes to review. You are on the default branch ('${defaultBranch}').`)
          return {
            overview: `No changes to review. You are on the default branch ('${defaultBranch}').`,
            specificReviews: [],
          }
        }

        const branchChangedFiles = await step('Getting file changes...', async () => {
          try {
            const diffNameStatus = execSync(`git diff --name-status --no-color ${defaultBranch}...${currentBranch}`, {
              encoding: 'utf-8',
            })
            return parseGitDiffNameStatus(diffNameStatus)
          } catch (_error) {
            console.warn('Warning: Could not retrieve file changes list')
            return []
          }
        })

        if (!json) {
          printChangedFiles('Changed files:', branchChangedFiles)
        }

        changeInfo = {
          commitRange: `${defaultBranch}...${currentBranch}`,
          changedFiles: branchChangedFiles,
        }
      }
    }

    if (!changeInfo) {
      return { overview: 'No changes to review.', specificReviews: [] }
    }

    const { output: reviewResult } = yield* tools.invokeAgent({
      agent: 'analyzer',
      messages: [CODE_REVIEW_PROMPT, formatReviewToolInput(changeInfo)],
      outputSchema: reviewOutputSchema,
      tools: [gitDiff],
    })

    if (!reviewResult) {
      return { overview: 'AI agent failed to produce a review.', specificReviews: [] }
    }

    return reviewResult
  },
}
