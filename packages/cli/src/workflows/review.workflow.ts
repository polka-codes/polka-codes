// generated by polka.codes

import { execSync } from 'node:child_process'
import { confirm } from '@inquirer/prompts'
import {
  builder,
  type CustomStepSpec,
  reviewDiff,
  type SharedAgentOptions,
  type StepRunResult,
  type WorkflowContext,
  type WorkflowSpec,
} from '@polka-codes/core'
import type { Ora } from 'ora'

export type ReviewResult = Awaited<ReturnType<typeof reviewDiff>>
export type HandleResultOutput = {
  shouldRunTask: boolean
  formattedReview?: string
}

type FileChange = {
  path: string
  status: string
}

type ReviewWorkflowInput = {
  pr?: string
  json: boolean
}

type ChangeInfo = {
  reviewArgs: Parameters<typeof reviewDiff>[1]
  changedFiles: FileChange[]
}

export interface ReviewWorkflowContext extends WorkflowContext {
  ui: { spinner: Ora }
  agent: { sharedAiOptions: SharedAgentOptions }
}

// Helper functions remain the same
function parseGitStatus(statusOutput: string): FileChange[] {
  const statusLines = statusOutput.split('\n').filter((line) => line)
  const files: FileChange[] = []

  for (const line of statusLines) {
    const indexStatus = line[0]
    const workingTreeStatus = line[1]
    const filepath = line.slice(3)

    const statuses = []
    if (indexStatus !== ' ' && indexStatus !== '?') {
      switch (indexStatus) {
        case 'A':
          statuses.push('Added (staged)')
          break
        case 'M':
          statuses.push('Modified (staged)')
          break
        case 'D':
          statuses.push('Deleted (staged)')
          break
        case 'R':
          statuses.push('Renamed (staged)')
          break
        case 'C':
          statuses.push('Copied (staged)')
          break
        default:
          statuses.push('Changed (staged)')
      }
    }
    if (workingTreeStatus !== ' ') {
      switch (workingTreeStatus) {
        case 'M':
          statuses.push('Modified (unstaged)')
          break
        case 'D':
          statuses.push('Deleted (unstaged)')
          break
        case '?':
          statuses.push('Untracked')
          break
        default:
          statuses.push('Changed (unstaged)')
      }
    }

    if (statuses.length > 0) {
      files.push({ path: filepath, status: statuses.join(', ') })
    }
  }

  return files
}

function parseGitDiffNameStatus(diffOutput: string): FileChange[] {
  const lines = diffOutput.split('\n').filter((line) => line.trim())
  return lines.map((line) => {
    const [status, ...pathParts] = line.split('\t')
    const path = pathParts.join('\t')
    let statusDescription: string
    switch (status[0]) {
      case 'A':
        statusDescription = 'Added'
        break
      case 'M':
        statusDescription = 'Modified'
        break
      case 'D':
        statusDescription = 'Deleted'
        break
      case 'R':
        statusDescription = 'Renamed'
        break
      case 'C':
        statusDescription = 'Copied'
        break
      case 'T':
        statusDescription = 'Type changed'
        break
      default:
        statusDescription = 'Unknown'
    }
    return { path, status: statusDescription }
  })
}

function printChangedFiles(changedFiles: FileChange[], spinner: Ora, isJsonOutput: boolean) {
  if (changedFiles.length === 0) {
    return
  }
  spinner.stop()
  const stream = isJsonOutput ? process.stderr : process.stdout
  const log = (message: string) =>
    stream.write(`${message}
`)
  log('Changed files:')
  for (const file of changedFiles) {
    log(`- ${file.status}: ${file.path}`)
  }
  spinner.start()
}

function formatReviewForConsole(output: { overview: string; specificReviews: { file: string; lines: string; review: string }[] }): string {
  let formatted = `### Overview\n\n${output.overview}`

  if (output.specificReviews.length > 0) {
    formatted += `\n\n### File-specific feedback\n`
    for (const item of output.specificReviews) {
      formatted += `\n- ${item.file}#${item.lines}\n\n${item.review}\n`
    }
  }
  return formatted
}

const getChangeInfo: CustomStepSpec<ReviewWorkflowInput, ReviewWorkflowInput & { changeInfo?: ChangeInfo }> = {
  id: 'get-change-info',
  type: 'custom' as const,
  run: async (
    input,
    context: WorkflowContext,
    _resumedState?: any,
  ): Promise<StepRunResult<ReviewWorkflowInput & { changeInfo?: ChangeInfo }>> => {
    const { pr, json } = input
    const {
      ui: { spinner },
    } = context as ReviewWorkflowContext
    let changeInfo: ChangeInfo

    if (pr) {
      const prNumberMatch = pr.match(/\d+$/)
      if (!prNumberMatch) {
        throw new Error('Invalid PR number or URL.')
      }
      const prNumber = prNumberMatch[0]

      try {
        execSync('gh --version', { stdio: 'ignore' })
      } catch {
        throw new Error('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
      }

      try {
        spinner.text = `Checking out PR #${prNumber}...`
        execSync(`gh pr checkout ${prNumber}`, { stdio: 'pipe' })
      } catch (error) {
        console.error(error)
        throw new Error(`Error checking out PR #${prNumber}. Make sure the PR number is correct and you have access to the repository.`)
      }

      spinner.text = 'Fetching pull request details...'
      const prDetails = JSON.parse(
        execSync(`gh pr view ${prNumber} --json title,body,commits,baseRefName,baseRefOid`, {
          encoding: 'utf-8',
        }),
      )
      const commitMessages = prDetails.commits.map((c: any) => c.messageBody).join('\n---\n')
      spinner.text = 'Getting file changes...'
      let changedFiles: FileChange[] = []
      try {
        const diffNameStatus = execSync(`git diff --name-status --no-color ${prDetails.baseRefOid}...HEAD`, {
          encoding: 'utf-8',
        })
        changedFiles = parseGitDiffNameStatus(diffNameStatus)
      } catch (_error) {
        console.warn('Warning: Could not retrieve file changes list')
      }

      printChangedFiles(changedFiles, spinner, json)
      changeInfo = {
        reviewArgs: {
          commitRange: `${prDetails.baseRefOid}...HEAD`,
          pullRequestTitle: prDetails.title,
          pullRequestDescription: prDetails.body,
          commitMessages,
          changedFiles,
        },
        changedFiles,
      }
    } else {
      const gitStatus = execSync('git status --porcelain=v1', { encoding: 'utf-8' })
      const statusLines = gitStatus.split('\n').filter((line) => line)
      const hasLocalChanges = statusLines.length > 0

      if (hasLocalChanges) {
        spinner.text = 'Generating review for local changes...'
        const changedFiles = parseGitStatus(gitStatus)
        printChangedFiles(changedFiles, spinner, json)
        changeInfo = {
          reviewArgs: {
            changedFiles,
          },
          changedFiles,
        }
      } else {
        spinner.text = 'No local changes detected. Falling back to branch diff...'
        spinner.render()

        try {
          execSync('gh --version', { stdio: 'ignore' })
        } catch {
          throw new Error(
            'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
          )
        }

        const defaultBranch = execSync('gh repo view --json defaultBranchRef --jq .defaultBranchRef.name', {
          encoding: 'utf-8',
        }).trim()

        const currentBranch = execSync('git rev-parse --abbrev-ref HEAD', {
          encoding: 'utf-8',
        }).trim()

        if (currentBranch === defaultBranch) {
          spinner.succeed(`No changes to review. You are on the default branch ('${defaultBranch}').`)
          const { $: _$, ...rest } = input
          return { type: 'success', output: { ...rest } }
        }

        spinner.text = 'Getting file changes...'
        let branchChangedFiles: FileChange[] = []
        try {
          const diffNameStatus = execSync(`git diff --name-status --no-color ${defaultBranch}...${currentBranch}`, { encoding: 'utf-8' })
          branchChangedFiles = parseGitDiffNameStatus(diffNameStatus)
        } catch (_error) {
          console.warn('Warning: Could not retrieve file changes list')
        }

        printChangedFiles(branchChangedFiles, spinner, json)

        spinner.text = `Generating review for changes between '${defaultBranch}' and '${currentBranch}'...`
        changeInfo = {
          reviewArgs: {
            commitRange: `${defaultBranch}...${currentBranch}`,
            changedFiles: branchChangedFiles,
          },
          changedFiles: branchChangedFiles,
        }
      }
    }
    const { $: _$, ...rest } = input
    return { type: 'success', output: { ...rest, changeInfo } }
  },
}

const generateReview: CustomStepSpec<
  ReviewWorkflowInput & { changeInfo?: ChangeInfo },
  ReviewWorkflowInput & { changeInfo?: ChangeInfo; reviewResult?: ReviewResult }
> = {
  id: 'generate-review',
  type: 'custom' as const,
  run: async (
    input,
    context: WorkflowContext,
    _resumedState?: any,
  ): Promise<StepRunResult<ReviewWorkflowInput & { changeInfo?: ChangeInfo; reviewResult?: ReviewResult }>> => {
    const { $: _$, ...rest } = input
    if (!input.changeInfo) {
      return { type: 'success', output: { ...rest } }
    }
    const {
      agent: { sharedAiOptions },
      ui: { spinner },
    } = context as ReviewWorkflowContext
    spinner.text = 'Generating review...'
    const reviewResult = await reviewDiff(sharedAiOptions, input.changeInfo.reviewArgs)
    spinner.succeed('Review generated successfully')
    return { type: 'success', output: { ...rest, reviewResult } }
  },
}

const handleResult: CustomStepSpec<ReviewWorkflowInput & { changeInfo?: ChangeInfo; reviewResult?: ReviewResult }, HandleResultOutput> = {
  id: 'handle-result',
  type: 'custom' as const,
  run: async (input, _context: WorkflowContext, _resumedState?: any): Promise<StepRunResult<HandleResultOutput>> => {
    const { reviewResult, json } = input
    if (!reviewResult) {
      return { type: 'success', output: { shouldRunTask: false } }
    }
    if (json) {
      console.log(JSON.stringify(reviewResult, null, 2))
      return { type: 'success', output: { shouldRunTask: false } }
    }

    const formatted = formatReviewForConsole(reviewResult)
    console.log(formatted)

    let shouldRunTask = false

    if (process.stdin.isTTY && reviewResult.specificReviews.length > 0) {
      try {
        shouldRunTask = await confirm({
          message: 'Do you wish polka-codes to address the review results?',
          default: false,
        })
      } catch {
        process.exit(130)
      }
    }
    const output: HandleResultOutput = { shouldRunTask }
    if (shouldRunTask) {
      output.formattedReview = formatted
    }
    return {
      type: 'success',
      output,
    }
  },
}

export const reviewWorkflow: WorkflowSpec<ReviewWorkflowInput, HandleResultOutput> = {
  name: 'Code Review',
  description: 'Review code changes in a pull request or local changes using AI.',
  step: builder<ReviewWorkflowInput>().custom(getChangeInfo).custom(generateReview).custom(handleResult).build(),
}
