// generated by polka.codes

import { listFiles, readBinaryFile, readFile, searchFiles, ToolResponseType } from '@polka-codes/core'
import { agentWorkflow, type Workflow } from '@polka-codes/workflow'
import { gitDiff } from '../tools'
import type { CliToolRegistry } from '../workflow-tools'
import { CODE_REVIEW_PROMPT, formatReviewToolInput, type ReviewToolInput } from './prompts'
import { parseGitDiffNameStatus, parseGitStatus, printChangedFiles, type ReviewResult, reviewOutputSchema } from './workflow.utils'

type FileChange = {
  path: string
  status: string
}

export type ReviewWorkflowInput = {
  pr?: string
}

export const reviewWorkflow: Workflow<ReviewWorkflowInput, ReviewResult, CliToolRegistry> = {
  name: 'Code Review',
  description: 'Review code changes in a pull request or local changes using AI.',
  async *fn(input, { step, tools, logger, runSubWorkflow }) {
    const { pr } = input
    let changeInfo: ReviewToolInput | undefined

    if (pr) {
      const prNumberMatch = pr.match(/\d+$/)
      if (!prNumberMatch) {
        throw new Error('Invalid PR number or URL.')
      }
      const prNumber = prNumberMatch[0]

      const ghCheckResult = yield* tools.executeCommand({ command: 'gh', args: ['--version'] })
      if (ghCheckResult.exitCode !== 0) {
        throw new Error('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
      }

      yield* step(`Checking out PR #${prNumber}...`, async function* () {
        const checkoutResult = yield* tools.executeCommand({
          command: 'gh',
          args: ['pr', 'checkout', prNumber],
        })
        if (checkoutResult.exitCode !== 0) {
          logger.error(checkoutResult.stderr)
          throw new Error(`Error checking out PR #${prNumber}. Make sure the PR number is correct and you have access to the repository.`)
        }
      })

      const prDetails = yield* step('Fetching pull request details...', async function* () {
        const result = yield* tools.executeCommand({
          command: 'gh',
          args: ['pr', 'view', prNumber, '--json', 'title,body,commits,baseRefName,baseRefOid'],
        })
        return JSON.parse(result.stdout)
      })
      const commitMessages = prDetails.commits.map((c: any) => c.messageBody).join('\n---\n')
      const changedFiles: FileChange[] = yield* step('Getting file changes...', async function* () {
        const diffResult = yield* tools.executeCommand({
          command: 'git',
          args: ['--no-pager', 'diff', '--name-status', '--no-color', `${prDetails.baseRefOid}...HEAD`],
        })
        if (diffResult.exitCode !== 0) {
          logger.warn('Warning: Could not retrieve file changes list')
          return []
        }
        return parseGitDiffNameStatus(diffResult.stdout)
      })

      printChangedFiles(logger, changedFiles)

      changeInfo = {
        commitRange: `${prDetails.baseRefOid}...HEAD`,
        pullRequestTitle: prDetails.title,
        pullRequestDescription: prDetails.body,
        commitMessages,
        changedFiles,
      }
    } else {
      const statusResult = yield* tools.executeCommand({ command: 'git', args: ['status', '--porcelain=v1'] })
      const gitStatus = statusResult.stdout
      const statusLines = gitStatus.split('\n').filter((line: string) => line)
      const hasLocalChanges = statusLines.length > 0

      if (hasLocalChanges) {
        const hasStagedChanges = statusLines.some((line: string) => line[0] !== ' ' && line[0] !== '?')
        const changedFiles = parseGitStatus(gitStatus)

        printChangedFiles(logger, changedFiles)

        changeInfo = {
          staged: hasStagedChanges,
          changedFiles,
        }
      } else {
        yield* step('No local changes detected. Falling back to branch diff...', async function* () {})

        const ghCheckResult = yield* tools.executeCommand({ command: 'gh', args: ['--version'] })
        if (ghCheckResult.exitCode !== 0) {
          throw new Error(
            'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
          )
        }

        const defaultBranchResult = yield* tools.executeCommand({
          command: 'gh',
          args: ['repo', 'view', '--json', 'defaultBranchRef', '--jq', '.defaultBranchRef.name'],
        })
        const defaultBranch = defaultBranchResult.stdout.trim()

        const currentBranchResult = yield* tools.executeCommand({ command: 'git', args: ['rev-parse', '--abbrev-ref', 'HEAD'] })
        const currentBranch = currentBranchResult.stdout.trim()

        if (currentBranch === defaultBranch) {
          yield* step(`No changes to review. You are on the default branch ('${defaultBranch}').`, async function* () {})
          logger.info(`No changes to review. You are on the default branch ('${defaultBranch}').`)
          return {
            overview: `No changes to review. You are on the default branch ('${defaultBranch}').`,
            specificReviews: [],
          }
        }

        const branchChangedFiles = yield* step('Getting file changes...', async function* () {
          const diffResult = yield* tools.executeCommand({
            command: 'git',
            args: ['--no-pager', 'diff', '--name-status', '--no-color', `${defaultBranch}...${currentBranch}`],
          })
          if (diffResult.exitCode !== 0) {
            logger.warn('Warning: Could not retrieve file changes list')
            return []
          }
          return parseGitDiffNameStatus(diffResult.stdout)
        })

        printChangedFiles(logger, branchChangedFiles)

        changeInfo = {
          commitRange: `${defaultBranch}...${currentBranch}`,
          changedFiles: branchChangedFiles,
        }
      }
    }

    if (!changeInfo) {
      return { overview: 'No changes to review.', specificReviews: [] }
    }

    const result = yield* runSubWorkflow(agentWorkflow, {
      systemPrompt: CODE_REVIEW_PROMPT,
      userMessage: [
        {
          role: 'user',
          content: formatReviewToolInput(changeInfo),
        },
      ],
      tools: [readFile, readBinaryFile, searchFiles, listFiles, gitDiff],
      outputSchema: reviewOutputSchema,
    })

    if (result.status !== 'completed') {
      return { overview: 'AI agent failed to produce a review.', specificReviews: [] }
    }

    const { output } = result
    if (output.type !== ToolResponseType.Exit) {
      return { overview: `Agent workflow exited with an unexpected status: ${output.type}`, specificReviews: [] }
    }

    const reviewResult = output.object as ReviewResult

    if (!reviewResult) {
      return { overview: 'AI agent failed to produce a review.', specificReviews: [] }
    }

    return reviewResult
  },
}
