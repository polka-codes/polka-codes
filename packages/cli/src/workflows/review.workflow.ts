// generated by polka.codes

import { agentWorkflow, listFiles, readBinaryFile, readFile, searchFiles, type WorkflowFn } from '@polka-codes/core'
import { gitDiff } from '../tools'
import type { CliToolRegistry } from '../workflow-tools'
import { CODE_REVIEW_SYSTEM_PROMPT, formatReviewToolInput, type ReviewToolInput } from './prompts'
import {
  type BaseWorkflowInput,
  type FileChange,
  getDefaultContext,
  parseGitDiffNameStatus,
  parseGitDiffNumStat,
  parseGitStatus,
  printChangedFiles,
  type ReviewResult,
  reviewOutputSchema,
} from './workflow.utils'

export type ReviewWorkflowInput = {
  pr?: number
  context?: string
}

export const reviewWorkflow: WorkflowFn<ReviewWorkflowInput & BaseWorkflowInput, ReviewResult, CliToolRegistry> = async (
  input,
  context,
) => {
  const { step, tools, logger } = context
  const { pr, context: userContext } = input
  let changeInfo: ReviewToolInput | undefined

  if (pr) {
    const ghCheckResult = await tools.executeCommand({ command: 'gh', args: ['--version'] })
    if (ghCheckResult.exitCode !== 0) {
      throw new Error('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
    }

    await step(`Checking out PR #${pr}...`, async () => {
      const checkoutResult = await tools.executeCommand({
        command: 'gh',
        args: ['pr', 'checkout', pr.toString()],
      })
      if (checkoutResult.exitCode !== 0) {
        logger.error(checkoutResult.stderr)
        throw new Error(`Error checking out PR #${pr}. Make sure the PR number is correct and you have access to the repository.`)
      }
    })

    const prDetails = await step('Fetching pull request details...', async () => {
      const result = await tools.executeCommand({
        command: 'gh',
        args: ['pr', 'view', pr.toString(), '--json', 'title,body,commits,baseRefName,baseRefOid'],
      })
      return JSON.parse(result.stdout)
    })
    const commitMessages = prDetails.commits.map((c: any) => c.messageBody).join('\n---\n')
    const changedFiles: FileChange[] = await step('Getting file changes...', async () => {
      const diffResult = await tools.executeCommand({
        command: 'git',
        args: ['--no-pager', 'diff', '--name-status', '--no-color', `${prDetails.baseRefOid}...HEAD`],
      })
      if (diffResult.exitCode !== 0) {
        logger.warn('Warning: Could not retrieve file changes list')
        return []
      }
      const files = parseGitDiffNameStatus(diffResult.stdout)

      const statResult = await tools.executeCommand({
        command: 'git',
        args: ['--no-pager', 'diff', '--numstat', '--no-color', `${prDetails.baseRefOid}...HEAD`],
      })
      if (statResult.exitCode === 0) {
        const stats = parseGitDiffNumStat(statResult.stdout)
        for (const file of files) {
          if (stats[file.path]) {
            file.insertions = stats[file.path].insertions
            file.deletions = stats[file.path].deletions
          }
        }
      }
      return files
    })

    printChangedFiles(logger, changedFiles)

    changeInfo = {
      commitRange: `${prDetails.baseRefOid}...HEAD`,
      pullRequestTitle: prDetails.title,
      pullRequestDescription: prDetails.body,
      commitMessages,
      changedFiles,
      context: userContext,
    }
  } else {
    const statusResult = await tools.executeCommand({ command: 'git', args: ['status', '--porcelain=v1'] })
    const gitStatus = statusResult.stdout
    const statusLines = gitStatus.split('\n').filter((line: string) => line)
    const hasLocalChanges = statusLines.length > 0

    if (hasLocalChanges) {
      const hasStagedChanges = statusLines.some((line: string) => line[0] !== ' ' && line[0] !== '?')
      const changedFiles = parseGitStatus(gitStatus)

      const unstagedStatResult = await tools.executeCommand({
        command: 'git',
        args: ['diff', '--numstat', '--no-color'],
      })
      const unstagedStats = unstagedStatResult.exitCode === 0 ? parseGitDiffNumStat(unstagedStatResult.stdout) : {}

      const stagedStatResult = await tools.executeCommand({
        command: 'git',
        args: ['diff', '--numstat', '--cached', '--no-color'],
      })
      const stagedStats = stagedStatResult.exitCode === 0 ? parseGitDiffNumStat(stagedStatResult.stdout) : {}

      for (const file of changedFiles) {
        const unstaged = unstagedStats[file.path] || { insertions: 0, deletions: 0 }
        const staged = stagedStats[file.path] || { insertions: 0, deletions: 0 }

        if (unstaged.insertions > 0 || unstaged.deletions > 0 || staged.insertions > 0 || staged.deletions > 0) {
          file.insertions = unstaged.insertions + staged.insertions
          file.deletions = unstaged.deletions + staged.deletions
        }
      }

      printChangedFiles(logger, changedFiles)

      changeInfo = {
        staged: hasStagedChanges,
        changedFiles,
        context: userContext,
      }
    } else {
      await step('No local changes detected. Falling back to branch diff...', async () => {})

      const ghCheckResult = await tools.executeCommand({ command: 'gh', args: ['--version'] })
      if (ghCheckResult.exitCode !== 0) {
        throw new Error(
          'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
        )
      }

      const defaultBranchResult = await tools.executeCommand({
        command: 'gh',
        args: ['repo', 'view', '--json', 'defaultBranchRef', '--jq', '.defaultBranchRef.name'],
      })
      const defaultBranch = defaultBranchResult.stdout.trim()

      const currentBranchResult = await tools.executeCommand({ command: 'git', args: ['rev-parse', '--abbrev-ref', 'HEAD'] })
      const currentBranch = currentBranchResult.stdout.trim()

      if (currentBranch === defaultBranch) {
        await step(`No changes to review. You are on the default branch ('${defaultBranch}').`, async () => {})
        logger.info(`No changes to review. You are on the default branch ('${defaultBranch}').`)
        return {
          overview: `No changes to review. You are on the default branch ('${defaultBranch}').`,
          specificReviews: [],
        }
      }

      const branchChangedFiles = await step('Getting file changes...', async () => {
        const diffResult = await tools.executeCommand({
          command: 'git',
          args: ['--no-pager', 'diff', '--name-status', '--no-color', `${defaultBranch}...${currentBranch}`],
        })
        if (diffResult.exitCode !== 0) {
          logger.warn('Warning: Could not retrieve file changes list')
          return []
        }
        const files = parseGitDiffNameStatus(diffResult.stdout)

        const statResult = await tools.executeCommand({
          command: 'git',
          args: ['--no-pager', 'diff', '--numstat', '--no-color', `${defaultBranch}...${currentBranch}`],
        })
        if (statResult.exitCode === 0) {
          const stats = parseGitDiffNumStat(statResult.stdout)
          for (const file of files) {
            if (stats[file.path]) {
              file.insertions = stats[file.path].insertions
              file.deletions = stats[file.path].deletions
            }
          }
        }
        return files
      })

      printChangedFiles(logger, branchChangedFiles)

      changeInfo = {
        commitRange: `${defaultBranch}...${currentBranch}`,
        changedFiles: branchChangedFiles,
        context: userContext,
      }
    }
  }

  if (!changeInfo) {
    return { overview: 'No changes to review.', specificReviews: [] }
  }

  const result = await step('review', async () => {
    const defaultContext = await getDefaultContext()
    const memoryContext = await tools.getMemoryContext()
    const reviewInput = formatReviewToolInput(changeInfo)
    const fullContent = `${reviewInput}\n\n${defaultContext}\n${memoryContext}`

    return await agentWorkflow(
      {
        systemPrompt: CODE_REVIEW_SYSTEM_PROMPT,
        userMessage: [
          {
            role: 'user',
            content: fullContent,
          },
        ],
        tools: [readFile, readBinaryFile, searchFiles, listFiles, gitDiff],
        outputSchema: reviewOutputSchema,
      },
      context,
    )
  })

  if (result.type === 'Exit') {
    const reviewResult = result.object as ReviewResult

    if (!reviewResult) {
      return { overview: 'AI agent failed to produce a review.', specificReviews: [] }
    }

    return reviewResult
  }

  return { overview: `Agent workflow exited with an unexpected status: ${result.type}`, specificReviews: [] }
}
