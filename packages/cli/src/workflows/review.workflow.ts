// generated by polka.codes

import path from 'node:path'
import { agentWorkflow, listFiles, readBinaryFile, readFile, searchFiles, type WorkflowFn } from '@polka-codes/core'
import { gitDiff } from '../tools'
import type { CliToolRegistry } from '../workflow-tools'
import { createGitAwareDiff, createGitAwareTools, extractTargetCommit } from './git-file-tools'
import { CODE_REVIEW_SYSTEM_PROMPT, formatReviewToolInput, type ReviewToolInput } from './prompts'
import {
  type BaseWorkflowInput,
  type FileChange,
  getDefaultContext,
  parseGitDiffNameStatus,
  parseGitDiffNumStat,
  parseGitStatus,
  printChangedFiles,
  type ReviewResult,
  reviewOutputSchema,
} from './workflow.utils'

export type ReviewWorkflowInput = {
  pr?: number
  range?: string
  context?: string
  files?: string[]
}

export const reviewWorkflow: WorkflowFn<ReviewWorkflowInput & BaseWorkflowInput, ReviewResult, CliToolRegistry> = async (
  input,
  context,
) => {
  const { step, tools, logger } = context
  const { pr, range, context: userContext, files } = input
  let changeInfo: ReviewToolInput | undefined

  // Get git root to normalize file paths
  const gitRootResult = await tools.executeCommand({ command: 'git', args: ['rev-parse', '--show-toplevel'] })
  if (gitRootResult.exitCode !== 0) {
    throw new Error('Failed to determine git repository root. Ensure you are in a git repository.')
  }
  const gitRoot = gitRootResult.stdout.trim()

  // Helper function to normalize file paths relative to git root
  const normalizeFilePath = (filePath: string): string => {
    // Resolve to absolute path from current working directory
    const absolutePath = path.resolve(process.cwd(), filePath)
    // Convert to path relative to git root
    const relativePath = path.relative(gitRoot, absolutePath)
    // Ensure forward slashes for git compatibility
    return relativePath.split(path.sep).join('/')
  }

  // Normalize input file paths
  const normalizedFiles = files?.map(normalizeFilePath)

  // Helper function to filter files if specific files are requested
  const filterFiles = (changedFiles: FileChange[]): FileChange[] => {
    if (!normalizedFiles || normalizedFiles.length === 0) {
      return changedFiles
    }
    // Filter to only include files that match the provided file list
    return changedFiles.filter((file) => normalizedFiles.includes(file.path))
  }

  const filterAndWarn = (changedFiles: FileChange[], source: string): FileChange[] => {
    const filteredFiles = filterFiles(changedFiles)

    if (normalizedFiles && normalizedFiles.length > 0) {
      const foundFiles = new Set(filteredFiles.map((f) => f.path))
      const missingFiles = normalizedFiles.filter((f) => !foundFiles.has(f))
      if (missingFiles.length > 0) {
        if (filteredFiles.length === 0) {
          logger.warn(`Warning: None of the specified files were found in ${source}: ${missingFiles.join(', ')}`)
        } else {
          logger.warn(`Warning: Some files not found in ${source}: ${missingFiles.join(', ')}`)
        }
      }
    }
    return filteredFiles
  }

  if (pr) {
    const ghCheckResult = await tools.executeCommand({ command: 'gh', args: ['--version'] })
    if (ghCheckResult.exitCode !== 0) {
      throw new Error('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
    }

    await step(`Checking out PR #${pr}...`, async () => {
      const checkoutResult = await tools.executeCommand({
        command: 'gh',
        args: ['pr', 'checkout', pr.toString()],
      })
      if (checkoutResult.exitCode !== 0) {
        logger.error(checkoutResult.stderr)
        throw new Error(`Error checking out PR #${pr}. Make sure the PR number is correct and you have access to the repository.`)
      }
    })

    const prDetails = await step('Fetching pull request details...', async () => {
      const result = await tools.executeCommand({
        command: 'gh',
        args: ['pr', 'view', pr.toString(), '--json', 'title,body,commits,baseRefName,baseRefOid'],
      })
      try {
        return JSON.parse(result.stdout)
      } catch (error) {
        throw new Error(`Failed to parse PR details from GitHub CLI: ${error instanceof Error ? error.message : String(error)}`)
      }
    })
    const prCommitRange = `${prDetails.baseRefOid}...HEAD`
    logger.info(`Reviewing PR #${pr} (commit range: ${prCommitRange})`)

    // Type for PR commit objects from GitHub CLI
    interface PRCommit {
      messageBody: string
      messageHeadline?: string
      oid?: string
    }

    const commitMessages = prDetails.commits.map((c: PRCommit) => c.messageBody).join('\n---\n')
    const allChangedFiles: FileChange[] = await step('Getting file changes...', async () => {
      const diffResult = await tools.executeCommand({
        command: 'git',
        args: ['--no-pager', 'diff', '--name-status', '--no-color', prCommitRange],
      })
      if (diffResult.exitCode !== 0) {
        logger.warn('Warning: Could not retrieve file changes list')
        return []
      }
      const files = parseGitDiffNameStatus(diffResult.stdout)

      const statResult = await tools.executeCommand({
        command: 'git',
        args: ['--no-pager', 'diff', '--numstat', '--no-color', prCommitRange],
      })
      if (statResult.exitCode === 0) {
        const stats = parseGitDiffNumStat(statResult.stdout)
        for (const file of files) {
          if (stats[file.path]) {
            file.insertions = stats[file.path].insertions
            file.deletions = stats[file.path].deletions
          }
        }
      }
      return files
    })

    const changedFiles = filterAndWarn(allChangedFiles, `PR #${pr}`)

    printChangedFiles(logger, changedFiles)

    // If no files remain after filtering, return early
    if (changedFiles.length === 0) {
      return {
        overview: normalizedFiles
          ? `No changes to review. The specified file(s) were not found in PR #${pr}: ${normalizedFiles.join(', ')}`
          : `No changes to review in PR #${pr}.`,
        specificReviews: [],
      }
    }

    changeInfo = {
      commitRange: prCommitRange,
      pullRequestTitle: prDetails.title,
      pullRequestDescription: prDetails.body,
      commitMessages,
      changedFiles,
      context: userContext,
    }
  } else if (range) {
    await step(`Reviewing git range '${range}'...`, async () => {})
    logger.info(`Reviewing commit range: ${range}`)

    const allRangeChangedFiles = await step('Getting file changes...', async () => {
      const diffResult = await tools.executeCommand({
        command: 'git',
        args: ['--no-pager', 'diff', '--name-status', '--no-color', range],
      })
      if (diffResult.exitCode !== 0) {
        logger.warn('Warning: Could not retrieve file changes list')
        return []
      }
      const files = parseGitDiffNameStatus(diffResult.stdout)

      const statResult = await tools.executeCommand({
        command: 'git',
        args: ['--no-pager', 'diff', '--numstat', '--no-color', range],
      })
      if (statResult.exitCode === 0) {
        const stats = parseGitDiffNumStat(statResult.stdout)
        for (const file of files) {
          if (stats[file.path]) {
            file.insertions = stats[file.path].insertions
            file.deletions = stats[file.path].deletions
          }
        }
      }
      return files
    })

    const rangeChangedFiles = filterAndWarn(allRangeChangedFiles, `range '${range}'`)

    printChangedFiles(logger, rangeChangedFiles)

    // If no files remain after filtering, return early
    if (rangeChangedFiles.length === 0) {
      return {
        overview: normalizedFiles
          ? `No changes to review. The specified file(s) were not found in range '${range}': ${normalizedFiles.join(', ')}`
          : `No changes to review in range '${range}'.`,
        specificReviews: [],
      }
    }

    // Get commit messages for the range
    const logResult = await tools.executeCommand({
      command: 'git',
      args: ['log', '--format=%B', range],
    })
    const commitMessages = logResult.exitCode === 0 ? logResult.stdout.trim() : ''

    changeInfo = {
      commitRange: range,
      changedFiles: rangeChangedFiles,
      commitMessages,
      context: userContext,
    }
  } else {
    const statusResult = await tools.executeCommand({ command: 'git', args: ['status', '--porcelain=v1'] })
    const gitStatus = statusResult.stdout
    const statusLines = gitStatus.split('\n').filter((line: string) => line)
    const hasLocalChanges = statusLines.length > 0

    if (hasLocalChanges) {
      const hasStagedChanges = statusLines.some((line: string) => line[0] !== ' ' && line[0] !== '?')
      const hasUnstagedChanges = statusLines.some((line: string) => line[1] !== ' ' && line[1] !== '?')
      const hasUntrackedChanges = statusLines.some((line: string) => line.startsWith('??'))
      const reviewTargets: string[] = []
      if (hasStagedChanges) {
        reviewTargets.push('staged files')
      }
      if (hasUnstagedChanges) {
        reviewTargets.push('unstaged files')
      }
      if (hasUntrackedChanges) {
        reviewTargets.push('untracked files')
      }
      if (reviewTargets.length > 0) {
        logger.info(`Reviewing local changes: ${reviewTargets.join(', ')}.`)
      } else {
        logger.info('Reviewing local changes.')
      }
      const allChangedFiles = parseGitStatus(gitStatus)

      const unstagedStatResult = await tools.executeCommand({
        command: 'git',
        args: ['diff', '--numstat', '--no-color'],
      })
      const unstagedStats = unstagedStatResult.exitCode === 0 ? parseGitDiffNumStat(unstagedStatResult.stdout) : {}

      const stagedStatResult = await tools.executeCommand({
        command: 'git',
        args: ['diff', '--numstat', '--cached', '--no-color'],
      })
      const stagedStats = stagedStatResult.exitCode === 0 ? parseGitDiffNumStat(stagedStatResult.stdout) : {}

      for (const file of allChangedFiles) {
        const unstaged = unstagedStats[file.path] || { insertions: 0, deletions: 0 }
        const staged = stagedStats[file.path] || { insertions: 0, deletions: 0 }

        if (unstaged.insertions > 0 || unstaged.deletions > 0 || staged.insertions > 0 || staged.deletions > 0) {
          file.insertions = unstaged.insertions + staged.insertions
          file.deletions = unstaged.deletions + staged.deletions
        }
      }

      const changedFiles = filterAndWarn(allChangedFiles, 'local changes')

      printChangedFiles(logger, changedFiles)

      // If no files remain after filtering, return early
      if (changedFiles.length === 0) {
        return {
          overview: normalizedFiles
            ? `No changes to review. The specified file(s) were not found in local changes: ${normalizedFiles.join(', ')}`
            : 'No changes to review.',
          specificReviews: [],
        }
      }

      changeInfo = {
        staged: hasStagedChanges,
        changedFiles,
        context: userContext,
      }
    } else {
      await step('No local changes detected. Falling back to branch diff...', async () => {})

      const ghCheckResult = await tools.executeCommand({ command: 'gh', args: ['--version'] })
      if (ghCheckResult.exitCode !== 0) {
        throw new Error(
          'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
        )
      }

      const defaultBranchResult = await tools.executeCommand({
        command: 'gh',
        args: ['repo', 'view', '--json', 'defaultBranchRef', '--jq', '.defaultBranchRef.name'],
      })
      const defaultBranch = defaultBranchResult.stdout.trim()

      const currentBranchResult = await tools.executeCommand({ command: 'git', args: ['rev-parse', '--abbrev-ref', 'HEAD'] })
      const currentBranch = currentBranchResult.stdout.trim()

      if (currentBranch === defaultBranch) {
        await step(`No changes to review. You are on the default branch ('${defaultBranch}').`, async () => {})
        logger.info(`No changes to review. You are on the default branch ('${defaultBranch}').`)
        return {
          overview: `No changes to review. You are on the default branch ('${defaultBranch}').`,
          specificReviews: [],
        }
      }

      const branchCommitRange = `${defaultBranch}...${currentBranch}`
      logger.info(`Reviewing branch changes (commit range: ${branchCommitRange})`)
      const allBranchChangedFiles = await step('Getting file changes...', async () => {
        const diffResult = await tools.executeCommand({
          command: 'git',
          args: ['--no-pager', 'diff', '--name-status', '--no-color', branchCommitRange],
        })
        if (diffResult.exitCode !== 0) {
          logger.warn('Warning: Could not retrieve file changes list')
          return []
        }
        const files = parseGitDiffNameStatus(diffResult.stdout)

        const statResult = await tools.executeCommand({
          command: 'git',
          args: ['--no-pager', 'diff', '--numstat', '--no-color', branchCommitRange],
        })
        if (statResult.exitCode === 0) {
          const stats = parseGitDiffNumStat(statResult.stdout)
          for (const file of files) {
            if (stats[file.path]) {
              file.insertions = stats[file.path].insertions
              file.deletions = stats[file.path].deletions
            }
          }
        }
        return files
      })

      const branchChangedFiles = filterAndWarn(allBranchChangedFiles, 'branch changes')

      printChangedFiles(logger, branchChangedFiles)

      // If no files remain after filtering, return early
      if (branchChangedFiles.length === 0) {
        return {
          overview: normalizedFiles
            ? `No changes to review. The specified file(s) were not found in branch changes: ${normalizedFiles.join(', ')}`
            : `No changes to review. The current branch has no differences from ${defaultBranch}.`,
          specificReviews: [],
        }
      }

      changeInfo = {
        commitRange: branchCommitRange,
        changedFiles: branchChangedFiles,
        context: userContext,
      }
    }
  }

  if (!changeInfo) {
    return { overview: 'No changes to review.', specificReviews: [] }
  }

  // Final safety check: ensure we have files to review
  // Use optional chaining to handle undefined changedFiles
  if (!changeInfo?.changedFiles || changeInfo.changedFiles.length === 0) {
    return { overview: 'No changes to review.', specificReviews: [] }
  }

  // Detect if we're reviewing a specific commit (not HEAD) or a commit range
  // For ranges (e.g., "A..B"), use regular gitDiff which handles ranges correctly
  // Only use git-aware tools for single commits
  const targetCommit = extractTargetCommit(range, pr)
  const isRange = range && range.includes('..')

  // Add targetCommit to changeInfo if present (and not a range)
  const finalChangeInfo = targetCommit && !isRange ? { ...changeInfo, targetCommit } : changeInfo

  // If reviewing a specific commit (single commit, not range), use git-aware tools
  // For ranges or local changes, use regular filesystem tools
  const fileTools = targetCommit && !isRange ? createGitAwareTools(targetCommit) : { readFile, listFiles, readBinaryFile }

  // When reviewing single commits, use git-aware versions of all tools including gitDiff
  // gitDiff for commits uses `git show <commit>` to display changes
  // For ranges or local changes, use regular gitDiff which handles them correctly
  const reviewTools =
    targetCommit && !isRange
      ? [fileTools.readFile, fileTools.readBinaryFile, fileTools.listFiles, createGitAwareDiff(targetCommit)]
      : [readFile, readBinaryFile, searchFiles, listFiles, gitDiff]

  const result = await step('review', async () => {
    const defaultContext = await getDefaultContext('review')
    const memoryContext = await tools.getMemoryContext()
    const reviewInput = formatReviewToolInput(finalChangeInfo)
    const fullContent = `${reviewInput}\n\n${defaultContext}\n${memoryContext}`

    return await agentWorkflow(
      {
        systemPrompt: CODE_REVIEW_SYSTEM_PROMPT,
        userMessage: [
          {
            role: 'user',
            content: fullContent,
          },
        ],
        tools: reviewTools,
        outputSchema: reviewOutputSchema,
      },
      context,
    )
  })

  if (result.type === 'Exit') {
    const reviewResult = result.object as ReviewResult

    if (!reviewResult) {
      return { overview: 'AI agent failed to produce a review.', specificReviews: [] }
    }

    return reviewResult
  }

  return { overview: `Agent workflow exited with an unexpected status: ${result.type}`, specificReviews: [] }
}
