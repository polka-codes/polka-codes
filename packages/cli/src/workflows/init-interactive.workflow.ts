// generated by polka.codes
import { join } from 'node:path'
import { type Config, loadConfigAtPath } from '@polka-codes/cli-shared'
import { agentWorkflow, askFollowupQuestion, listFiles, readFile, searchFiles, type WorkflowFn } from '@polka-codes/core'
import { parse, stringify } from 'yaml'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import { INIT_WORKFLOW_ANALYZE_SYSTEM_PROMPT } from './prompts'
import type { BaseWorkflowInput } from './workflow.utils'

export type InitInteractiveWorkflowInput = {
  configPath: string
  scriptName?: string
  scriptInstructions?: string
  generateScript?: boolean
  skipConfirmation?: boolean
}

type InitInteractiveWorkflowOutput = {
  configPath: string
  scriptPath?: string
  generatedConfig?: Partial<Config>
}

const schemaExample = JSON.stringify(
  {
    plan: 'string - Describe your approach',
    questions: [
      {
        question: 'string - What to ask',
        options: ['array', 'of', 'options'],
        default: 'default value',
      },
    ],
    script: 'string - Generated TypeScript code',
    config: 'object - Additional polka config if needed',
  },
  null,
  2,
)

const scriptGenerationSystemPrompt = `Role: Expert TypeScript Developer and Automation Specialist

Goal: Generate a custom polka script based on user requirements.

You have access to:
- readFile: Read any file in the project
- listFiles: Discover project structure
- searchFiles: Find specific patterns
- askFollowupQuestion: Ask the user for clarification

Your task:
1. Understand the user's automation requirements
2. Analyze the project structure to understand the codebase
3. Ask clarifying questions if requirements are unclear
4. Generate a TypeScript script that combines polka workflows
5. Present the plan to the user and confirm before generating

Script Guidelines:
- Use existing polka workflows: code, fix, review, commit, plan
- Include proper error handling and logging
- Add comments explaining each step
- Make scripts configurable via command-line arguments
- Export a main() function that accepts args: string[]
- Include usage examples in comments

Available Workflows:
- code({ task, interactive }): Implement coding tasks
- fix({ task }): Fix bugs and issues
- review({ range, pr, files, context }): Review code changes
- commit({ message, stageFiles }): Create git commits
- plan({ task }): Create implementation plans

Script Template:
\`\`\`typescript
// Generated by polka.codes
import { code, fix, review, commit } from '@polka-codes/cli'

export interface ScriptOptions {
  // Add your options here
}

export async function main(args: string[]) {
  // Parse arguments if needed
  // Your automation logic here

  console.log('Script completed successfully')
}

// Only run main if this is the entry point
if (import.meta.main) {
  main(process.argv.slice(2))
}
\`\`\`

Response Format:
Return a JSON object with:
- plan: string describing the script approach
- questions: array of questions to ask the user (if needed)
- script: the generated TypeScript code
- config: any additional configuration needed

Example response format:
${schemaExample}`

export const initInteractiveWorkflow: WorkflowFn<
  InitInteractiveWorkflowInput & BaseWorkflowInput,
  InitInteractiveWorkflowOutput,
  CliToolRegistry
> = async (input, context) => {
  const { step, logger, tools } = context
  const { configPath, scriptName, scriptInstructions, generateScript = false, skipConfirmation = false } = input

  let generatedConfig: Partial<Config> = {}
  let generatedScriptPath: string | undefined

  // Step 1: Analyze project and generate config
  const analyzeResult = await step('analyze-project', async () => {
    logger.info('Analyzing project structure and configuration...')

    return await agentWorkflow(
      {
        systemPrompt: INIT_WORKFLOW_ANALYZE_SYSTEM_PROMPT,
        userMessage: [
          {
            role: 'user',
            content: 'Please provide a valid polkacodes YAML configuration for the project.',
          },
        ],
        tools: [readFile, listFiles, searchFiles],
        outputSchema: z.object({ yaml: z.string() }),
      },
      { logger, tools, step },
    )
  })

  if (analyzeResult.type === 'Exit' && analyzeResult.object) {
    const yamlConfig = analyzeResult.object.yaml
    generatedConfig = yamlConfig ? parse(yamlConfig) : {}
  }

  // Step 2: Save generated config
  await step('save-config', async () => {
    const existingConfig = loadConfigAtPath(configPath) ?? {}

    const finalConfig: Config = {
      ...existingConfig,
      ...generatedConfig,
    }

    await tools.writeToFile({ path: configPath, content: stringify(finalConfig) })
    logger.info(`‚úÖ Configuration saved to ${configPath}`)

    // Show what was generated
    if (generatedConfig.scripts) {
      logger.info('\nüìù Generated scripts:')
      Object.entries(generatedConfig.scripts).forEach(([name, scriptConfig]) => {
        if (typeof scriptConfig === 'string') {
          logger.info(`  - ${name}: ${scriptConfig}`)
        } else if (typeof scriptConfig === 'object' && scriptConfig !== null) {
          logger.info(`  - ${name}: ${scriptConfig.description || JSON.stringify(scriptConfig)}`)
        }
      })
    }

    if (generatedConfig.rules) {
      const rules = Array.isArray(generatedConfig.rules) ? generatedConfig.rules : [generatedConfig.rules]
      logger.info('\nüìã Identified project rules:')
      rules.forEach((rule) => {
        if (typeof rule === 'string') {
          logger.info(`  - ${rule}`)
        }
      })
    }
  })

  // Step 3: Generate custom script if requested
  if (generateScript && scriptName && scriptInstructions) {
    const scriptResult = await step('generate-script', async () => {
      logger.info(`\nüîß Generating custom script: ${scriptName}`)
      logger.info(`Requirements: ${scriptInstructions}`)

      // Use agent workflow with askFollowupQuestion tool
      return await agentWorkflow(
        {
          systemPrompt: scriptGenerationSystemPrompt,
          userMessage: [
            {
              role: 'user',
              content: `Generate a polka script with these requirements:
Script name: ${scriptName}

Instructions: ${scriptInstructions}

Please:
1. Ask clarifying questions if needed
2. Analyze the project structure
3. Present your plan before generating the script
4. Generate a complete, working TypeScript script`,
            },
          ],
          tools: [readFile, listFiles, searchFiles, askFollowupQuestion],
          outputSchema: z.object({
            plan: z.string(),
            questions: z
              .array(z.object({ question: z.string(), options: z.array(z.string()).optional(), default: z.string().optional() }))
              .optional(),
            script: z.string(),
            config: z.record(z.string(), z.unknown()).optional(),
          }),
        },
        { logger, tools, step },
      )
    })

    if (scriptResult.type === 'Exit' && scriptResult.object) {
      const { plan, script, config: scriptConfig } = scriptResult.object

      // Show plan if not skipped
      if (!skipConfirmation) {
        logger.info('\nüìã Script Generation Plan:')
        logger.info(plan)
      }

      // Save the script
      const scriptDir = '.polka-scripts'
      const scriptFileName = `${scriptName}.ts`
      const scriptFilePath = join(scriptDir, scriptFileName)

      await step('save-script', async () => {
        await tools.writeToFile({ path: scriptFilePath, content: script })
        logger.info(`\n‚úÖ Script generated: ${scriptFilePath}`)
        logger.info(`\nRun with: bun run polka run ${scriptName}`)

        // Update config if additional config provided
        // Note: We don't merge scriptConfig directly to avoid type safety issues
        // The AI-generated config is untyped and could corrupt the configuration
        if (scriptConfig && Object.keys(scriptConfig).length > 0) {
          logger.warn(`‚ö†Ô∏è AI suggested config updates, but they were not merged for safety:`)
          logger.warn(JSON.stringify(scriptConfig, null, 2))
          logger.warn(`To apply these changes, manually edit ${configPath}`)
        }
      })

      generatedScriptPath = scriptFilePath
    }
  }

  return {
    configPath,
    scriptPath: generatedScriptPath,
    generatedConfig,
  }
}
