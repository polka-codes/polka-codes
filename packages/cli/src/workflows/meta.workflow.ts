// generated by polka.codes

import { agentWorkflow, ToolResponseType, type WorkflowFn } from '@polka-codes/core'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import { codeWorkflow } from './code.workflow'
import { type EpicWorkflowInput, epicWorkflow } from './epic.workflow'
import { META_SYSTEM_PROMPT } from './prompts'
import { taskWorkflow } from './task.workflow'

export type MetaWorkflowInput = EpicWorkflowInput

const DecisionSchema = z.object({
  workflow: z.enum(['code', 'task', 'epic']),
})

export const metaWorkflow: WorkflowFn<MetaWorkflowInput, void, CliToolRegistry> = async (input, context) => {
  const { task } = input
  const { logger } = context

  if (!task) {
    logger.error('Task is not defined in the input for metaWorkflow.')
    return
  }

  logger.info(`\nDeciding which workflow to use for task...\n`)

  const result = await agentWorkflow(
    {
      systemPrompt: META_SYSTEM_PROMPT,
      userMessage: [
        {
          role: 'user',
          content: `<task>${task}</task>`,
        },
      ],
      tools: [],
      outputSchema: DecisionSchema,
    },
    context,
  )

  if (result.type !== ToolResponseType.Exit || !result.object) {
    throw new Error(`Could not decide which workflow to run. Agent exited with reason: ${result.type}`)
  }

  const decision = result.object as z.infer<typeof DecisionSchema>

  if (!decision.workflow) {
    throw new Error('Could not decide which workflow to run.')
  }

  logger.info(`\nDecision: Using '${decision.workflow}' workflow.`)

  switch (decision.workflow) {
    case 'code':
      await codeWorkflow({ task, interactive: input.interactive }, context)
      break
    case 'task':
      await taskWorkflow(
        {
          task,
          interactive: input.interactive,
        },
        context,
      )
      break
    case 'epic':
      await epicWorkflow(input, context)
      break
    default:
      throw new Error(`Unknown workflow: ${decision.workflow}`)
  }
}
