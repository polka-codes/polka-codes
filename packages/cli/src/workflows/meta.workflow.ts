// generated by polka.codes

import type { Workflow } from '@polka-codes/workflow'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import { codeWorkflow } from './code.workflow'
import { getMetaPrompt } from './prompts'
import { runSubWorkflow } from './runSubWorkflow'
import { taskWorkflow } from './task.workflow'

export type MetaWorkflowInput = {
  task: string
}

const DecisionSchema = z.object({
  workflow: z.enum(['code', 'agent']),
  agent: z.string().optional(),
})

export const metaWorkflow: Workflow<MetaWorkflowInput, any, CliToolRegistry> = {
  name: 'Meta Workflow',
  description: "Dynamically chooses and runs a workflow based on the user's task.",
  async *fn(input, _step, tools) {
    const { task } = input

    console.log(`\nðŸ¤” Deciding which workflow to use for task...\n`)

    const { output: decision } = yield* tools.invokeAgent({
      agent: 'architect',
      messages: [getMetaPrompt(task)],
      outputSchema: DecisionSchema,
    })

    if (!decision || !decision.workflow) {
      throw new Error('Could not decide which workflow to run.')
    }

    console.log(`\nâœ… Decision: Using '${decision.workflow}' workflow.`)
    if (decision.agent) {
      console.log(`   Agent: ${decision.agent}`)
    }
    console.log('\n')

    if (decision.workflow === 'code') {
      return yield* runSubWorkflow(tools, codeWorkflow, { task })
    } else if (decision.workflow === 'agent' && decision.agent) {
      return yield* runSubWorkflow(tools, taskWorkflow, {
        task,
        agent: decision.agent,
      })
    } else {
      throw new Error(`Invalid workflow decision: ${JSON.stringify(decision, null, 2)}`)
    }
  },
}
