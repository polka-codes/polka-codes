// generated by polka.codes

import { agentWorkflow, type WorkflowFn } from '@polka-codes/core'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import { codeWorkflow } from './code.workflow'
import { META_SYSTEM_PROMPT } from './prompts'
import { taskWorkflow } from './task.workflow'
import type { BaseWorkflowInput } from './workflow.utils'

export type MetaWorkflowInput = {
  task: string
  interactive?: boolean
  jsonMode?: boolean
  additionalTools?: {
    search?: unknown
    mcpTools?: unknown[]
  }
}

const DecisionSchema = z.object({
  workflow: z.enum(['code', 'task']),
})

// Output schema for JSON mode - ensures structured JSON output
const MetaOutputSchema = z.object({
  workflow: z.enum(['code', 'task']).describe('The workflow that was executed'),
  success: z.boolean().describe('Whether the workflow completed successfully'),
  summary: z.string().optional().describe('Summary of what was done'),
  error: z.string().optional().describe('Error message if the workflow failed'),
})

export type MetaWorkflowOutput = z.infer<typeof MetaOutputSchema>

export const metaWorkflow: WorkflowFn<MetaWorkflowInput & BaseWorkflowInput, MetaWorkflowOutput, CliToolRegistry> = async (
  input,
  context,
) => {
  const { task } = input
  const { logger } = context

  if (!task) {
    logger.error('Task is not defined in the input for metaWorkflow.')
    return {
      workflow: 'task',
      success: false,
      error: 'Task is not defined in the input for metaWorkflow.',
    }
  }

  logger.info(`\nDeciding which workflow to use for task...\n`)

  const result = await agentWorkflow(
    {
      systemPrompt: META_SYSTEM_PROMPT,
      userMessage: [
        {
          role: 'user',
          content: `<task>${task}</task>`,
        },
      ],
      tools: [],
      outputSchema: DecisionSchema,
    },
    context,
  )

  if (result.type !== 'Exit' || !result.object) {
    const errorMsg = `Could not decide which workflow to run. Agent exited with reason: ${result.type}`
    logger.error(errorMsg)
    return {
      workflow: 'task',
      success: false,
      error: errorMsg,
    }
  }

  const decision = result.object as z.infer<typeof DecisionSchema>

  if (!decision.workflow) {
    const errorMsg = 'Could not decide which workflow to run.'
    logger.error(errorMsg)
    return {
      workflow: 'task',
      success: false,
      error: errorMsg,
    }
  }

  logger.info(`\nDecision: Using '${decision.workflow}' workflow.`)

  switch (decision.workflow) {
    case 'code': {
      const codeResult = await codeWorkflow({ task, interactive: input.interactive, additionalTools: input.additionalTools }, context)
      // Return structured output
      return {
        workflow: 'code',
        success: codeResult.success,
        summary: codeResult.summaries?.join('\n'),
        error: codeResult.success === false ? codeResult.reason : undefined,
      }
    }
    case 'task': {
      const taskResult = await taskWorkflow(
        {
          task,
          interactive: input.interactive,
          additionalTools: input.additionalTools,
        },
        context,
      )
      // Convert ExitReason to structured output
      if (taskResult.type === 'Exit') {
        return {
          workflow: 'task',
          success: true,
          summary: taskResult.message,
        }
      } else if (taskResult.type === 'Error') {
        return {
          workflow: 'task',
          success: false,
          error: taskResult.error.message,
        }
      } else {
        // UsageExceeded
        return {
          workflow: 'task',
          success: false,
          error: 'Usage limit exceeded',
        }
      }
    }
    default: {
      const errorMsg = `Unknown workflow: ${decision.workflow}`
      throw new Error(errorMsg)
    }
  }
}
