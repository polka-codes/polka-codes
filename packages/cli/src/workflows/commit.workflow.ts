// generated by polka.codes

import { listFiles, readBinaryFile, readFile, searchFiles, ToolResponseType } from '@polka-codes/core'
import { agentWorkflow, type WorkflowFn } from '@polka-codes/workflow'
import { z } from 'zod'
import { UserCancelledError } from '../errors'
import { gitDiff } from '../tools'
import type { CliToolRegistry } from '../workflow-tools'
import { COMMIT_MESSAGE_SYSTEM_PROMPT } from './prompts'
import { parseGitDiffNameStatus } from './workflow.utils'

export type CommitWorkflowInput = {
  all?: boolean
  context?: string
}

type FileChange = {
  path: string
  status: string
}

export const commitWorkflow: WorkflowFn<CommitWorkflowInput, void, CliToolRegistry> = async (input, context) => {
  const { step, tools, logger } = context
  const { stagedFiles, unstagedFiles } = await tools.printChangeFile()

  let hasStaged = stagedFiles.length > 0
  const hasUnstaged = unstagedFiles.length > 0

  if (!hasStaged) {
    if (input.all) {
      await step('stage-all', async () => {
        await tools.executeCommand({ command: 'git', args: ['add', '.'] })
      })
      hasStaged = true
    } else if (hasUnstaged) {
      const confirmed = await tools.confirm({
        message: 'No staged files found. Stage all files?',
        default: false,
      })
      if (confirmed) {
        await step('stage-all', async () => {
          await tools.executeCommand({
            command: 'git',
            args: ['add', '.'],
          })
        })
        hasStaged = true
      } else {
        throw new UserCancelledError()
      }
    }
  }

  if (!hasStaged) {
    throw new Error('No files to commit. Aborting.')
  }

  const { changedFiles, diff } = await step('get-diff', async () => {
    // List staged changes for visibility
    let changedFiles: FileChange[] = []
    const diffNameStatusResult = await tools.executeCommand({
      command: 'git',
      args: ['diff', '--name-status', '--no-color', '--staged'],
    })
    if (diffNameStatusResult.exitCode === 0) {
      changedFiles = parseGitDiffNameStatus(diffNameStatusResult.stdout)
    }
    const diffResult = await tools.executeCommand({
      command: 'git',
      args: ['diff', '--staged'],
    })
    const diff = diffResult.stdout
    return { changedFiles, diff }
  })

  const fileList = changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
  const fileListPrompt = `<file_status>\n${fileList}\n</file_status>`
  const diffPrompt = `<diff>\n${diff}\n</diff>`
  const contextPrompt = input.context ? `\n<tool_input_context>\n${input.context}\n</tool_input_context>` : ''

  const commitMessageSchema = z.object({
    commitMessage: z.string(),
  })

  const result = await step('generate-commit-message', async () => {
    return await agentWorkflow(
      {
        systemPrompt: COMMIT_MESSAGE_SYSTEM_PROMPT,
        userMessage: [
          {
            role: 'user',
            content: `${fileListPrompt}${diffPrompt}${contextPrompt}`,
          },
        ],
        tools: [readFile, readBinaryFile, searchFiles, listFiles, gitDiff],
        outputSchema: commitMessageSchema,
      },
      context,
    )
  })

  if (result.type === ToolResponseType.Exit && result.object) {
    const { commitMessage } = commitMessageSchema.parse(result.object)
    if (commitMessage) {
      logger.info(`\nCommit message:\n${commitMessage}`)
      await tools.createCommit({ message: commitMessage })
      return
    }
  }

  context.logger.warn('Failed to generate commit message.', result)
}
