// generated by polka.codes

import { listFiles, readBinaryFile, readFile, searchFiles, ToolResponseType } from '@polka-codes/core'
import { agentWorkflow, runSubWorkflow, type Workflow } from '@polka-codes/workflow'
import { z } from 'zod'
import { UserCancelledError } from '../errors'
import { gitDiff } from '../tools'
import type { CliToolRegistry } from '../workflow-tools'
import { COMMIT_MESSAGE_PROMPT } from './prompts'
import { parseGitDiffNameStatus } from './workflow.utils'

export type CommitWorkflowInput = {
  all?: boolean
  context?: string
}

type FileChange = {
  path: string
  status: string
}

export const commitWorkflow: Workflow<CommitWorkflowInput, void, CliToolRegistry> = {
  name: 'Generate Commit Message',
  description: 'Generate a Git commit message based on staged changes',
  async *fn(input, step, tools) {
    const { stagedFiles, unstagedFiles } = yield* tools.printChangeFile()

    let hasStaged = stagedFiles.length > 0
    const hasUnstaged = unstagedFiles.length > 0

    if (!hasStaged) {
      if (input.all) {
        yield* step('stage-all', async function* () {
          yield* tools.executeCommand({ command: 'git', args: ['add', '.'] })
        })
        hasStaged = true
      } else if (hasUnstaged) {
        const confirmed = yield* tools.confirm({ message: 'No staged files found. Stage all files?', default: false })
        if (confirmed) {
          yield* step('stage-all', async function* () {
            yield* tools.executeCommand({ command: 'git', args: ['add', '.'] })
          })
          hasStaged = true
        } else {
          throw new UserCancelledError()
        }
      }
    }

    if (!hasStaged) {
      throw new Error('No files to commit. Aborting.')
    }

    const { changedFiles, diff } = yield* step('get-diff', async function* () {
      // List staged changes for visibility
      let changedFiles: FileChange[] = []
      const diffNameStatusResult = yield* tools.executeCommand({
        command: 'git',
        args: ['diff', '--name-status', '--no-color', '--staged'],
      })
      if (diffNameStatusResult.exitCode === 0) {
        changedFiles = parseGitDiffNameStatus(diffNameStatusResult.stdout)
      }
      const diffResult = yield* tools.executeCommand({ command: 'git', args: ['diff', '--staged'] })
      const diff = diffResult.stdout
      return { changedFiles, diff }
    })

    const fileList = changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
    const fileListPrompt = `<file_status>\n${fileList}\n</file_status>`
    const diffPrompt = `<diff>\n${diff}\n</diff>`
    const contextPrompt = input.context ? `\n<tool_input_context>\n${input.context}\n</tool_input_context>` : ''

    const commitMessageSchema = z.object({
      commitMessage: z.string(),
    })

    const result = yield* runSubWorkflow(tools, agentWorkflow, {
      systemPrompt: COMMIT_MESSAGE_PROMPT,
      userMessage: [
        {
          role: 'user',
          content: `${fileListPrompt}${diffPrompt}${contextPrompt}`,
        },
      ],
      tools: [readFile, readBinaryFile, searchFiles, listFiles, gitDiff],
      outputSchema: commitMessageSchema,
    })

    if (result?.status !== 'completed') {
      throw new Error('Workflow exited unexpectedly')
    }

    const { output } = result
    if (output.type !== ToolResponseType.Exit) {
      throw new Error(`Expected a string commit message, but got ${output.type}`)
    }
    const { commitMessage } = output.object as unknown as z.infer<typeof commitMessageSchema>

    console.log(`\nCommit message:\n${commitMessage}`)

    yield* tools.createCommit({ message: commitMessage })
  },
}
