// generated by polka.codes

import { execSync } from 'node:child_process'
import { confirm } from '@inquirer/prompts'
import {
  builder,
  type CustomStepSpec,
  parseJsonFromMarkdown,
  type StepRunResult,
  type WorkflowContext,
  type WorkflowSpec,
} from '@polka-codes/core'
import type { Ora } from 'ora'
import { z } from 'zod'
import { gitDiff } from '../tools'
import { parseGitDiffNameStatus, printChangedFiles } from './workflow.utils'

export type CommitWorkflowInput = {
  all?: boolean
  context?: string
}

export interface CommitWorkflowContext extends WorkflowContext {
  ui: { spinner: Ora }
}

type FileChange = {
  path: string
  status: string
}

const ensureStaged: CustomStepSpec<CommitWorkflowInput, { context?: string; changedFiles: FileChange[] }> = {
  id: 'ensure-staged',
  type: 'custom' as const,
  run: async (input, context): Promise<StepRunResult<{ context?: string; changedFiles: FileChange[] }>> => {
    const { all, context: userContext } = input
    const logger = context.logger ?? console
    const {
      ui: { spinner },
    } = context as CommitWorkflowContext

    // Check status
    const status = execSync('git status --porcelain=v1', { encoding: 'utf-8' })
    const statusLines = status.split('\n').filter(Boolean)
    const hasStaged = statusLines.some((line) => line[0] !== ' ' && line[0] !== '?')

    if (!hasStaged) {
      if (all) {
        execSync('git add .', { stdio: 'ignore' })
      } else {
        spinner.stop()
        let addAll = false
        try {
          addAll = await confirm({ message: 'No staged files found. Stage all files?' })
        } catch (_err) {
          // User canceled prompt (e.g., Ctrl+C)
          return { type: 'error', error: new Error('User cancelled') }
        }

        if (!addAll) {
          return { type: 'error', error: new Error('No files to commit') }
        }
        spinner.start()
        execSync('git add .', { stdio: 'ignore' })
      }
    }

    // List staged changes for visibility
    let changedFiles: FileChange[] = []
    try {
      const diffNameStatus = execSync('git diff --name-status --no-color --staged', { encoding: 'utf-8' })
      changedFiles = parseGitDiffNameStatus(diffNameStatus)
    } catch {
      // Ignore listing failure; continue to message generation
    }
    printChangedFiles('Staged files:', changedFiles, spinner, logger)

    spinner.text = 'Generating commit message...'
    return { type: 'success', output: { context: userContext, changedFiles } }
  },
}

const COMMIT_MESSAGE_PROMPT = `
You are an expert at writing git commit messages.
Based on the provided list of staged files in <file_status> and optional user context in <tool_input_context>, generate a concise and descriptive commit message.

Use the 'git_diff' tool with 'staged: true' to get the content of the changes.

Follow the conventional commit format.

Respond with a JSON object containing the commit message.
Example format:
\`\`\`json
{
  "commitMessage": "feat: add new feature\\n\\ndescribe the new feature in more detail"
}
\`\`\`
`

const commitMessageSchema = z.object({ commitMessage: z.string() })

const handleCommitResult: CustomStepSpec<{ commitMessage: string }, { commitMessage: string }> = {
  id: 'handle-commit-message',
  type: 'custom' as const,
  run: async (input, context) => {
    const logger = context.logger ?? console
    const {
      ui: { spinner },
    } = context as CommitWorkflowContext

    spinner.succeed('Commit message generated')
    logger.log(`\nCommit message:\n${input.commitMessage}`)

    return { type: 'success', output: { commitMessage: input.commitMessage } }
  },
}

export const commitWorkflow: WorkflowSpec<CommitWorkflowInput, { commitMessage: string }> = {
  name: 'Generate Commit Message',
  description: 'Generate a Git commit message based on staged changes',
  step: builder<CommitWorkflowInput>()
    .custom(ensureStaged)
    .agent('generate-commit-message', {
      agent: 'analyzer',
      tools: [gitDiff],
      messages: [
        COMMIT_MESSAGE_PROMPT,
        {
          type: 'function',
          fn: (input: { changedFiles: FileChange[]; context?: string }) => {
            const fileList = input.changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
            let ret = `<file_status>\n${fileList}\n</file_status>`
            if (input.context) {
              ret += `\n<tool_input_context>\n${input.context}\n</tool_input_context>`
            }
            return ret
          },
        },
      ],
      outputSchema: commitMessageSchema,
      parseOutput: parseJsonFromMarkdown,
    })
    .custom(handleCommitResult)
    .build(),
}
