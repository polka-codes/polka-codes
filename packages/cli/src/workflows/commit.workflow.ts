// generated by polka.codes

import type { Workflow } from '@polka-codes/workflow'
import { z } from 'zod'
import { UserCancelledError } from '../errors'
import type { CliToolRegistry } from '../workflow-tools'
import { COMMIT_MESSAGE_PROMPT } from './prompts'
import { parseGitDiffNameStatus } from './workflow.utils'

export type CommitWorkflowInput = {
  all?: boolean
  context?: string
}

type FileChange = {
  path: string
  status: string
}

const commitMessageSchema = z.object({
  commitMessage: z.string(),
})

export const commitWorkflow: Workflow<CommitWorkflowInput, { commitMessage: string }, CliToolRegistry> = {
  name: 'Generate Commit Message',
  description: 'Generate a Git commit message based on staged changes',
  async *fn(input, step, tools) {
    const { stagedFiles, unstagedFiles } = yield* tools.printChangeFile({})

    let hasStaged = stagedFiles.length > 0
    const hasUnstaged = unstagedFiles.length > 0

    if (!hasStaged) {
      if (input.all) {
        yield* step('stage-all', async function* () {
          yield* tools.executeCommand({ command: 'git', args: ['add', '.'] })
        })
        hasStaged = true
      } else if (hasUnstaged) {
        const confirmed = yield* tools.confirm({ message: 'No staged files found. Stage all files?', default: false })
        if (confirmed) {
          yield* step('stage-all', async function* () {
            yield* tools.executeCommand({ command: 'git', args: ['add', '.'] })
          })
          hasStaged = true
        } else {
          throw new UserCancelledError()
        }
      }
    }

    if (!hasStaged) {
      throw new Error('No files to commit. Aborting.')
    }

    const { changedFiles, diff } = yield* step('get-diff', async function* () {
      // List staged changes for visibility
      let changedFiles: FileChange[] = []
      const diffNameStatusResult = yield* tools.executeCommand({
        command: 'git',
        args: ['diff', '--name-status', '--no-color', '--staged'],
      })
      if (diffNameStatusResult.exitCode === 0) {
        changedFiles = parseGitDiffNameStatus(diffNameStatusResult.stdout)
      }
      const diffResult = yield* tools.executeCommand({ command: 'git', args: ['diff', '--staged'] })
      const diff = diffResult.stdout
      return { changedFiles, diff }
    })

    const fileList = changedFiles.map((file) => `${file.status}: ${file.path}`).join('\n')
    const fileStatusPrompt = `<file_status>\n${fileList}\n</file_status>`
    const diffPrompt = `<diff>\n${diff}\n</diff>`
    const contextPrompt = input.context ? `\n<tool_input_context>\n${input.context}\n</tool_input_context>` : ''

    const { output } = yield* tools.invokeAgent({
      agent: 'analyzer',
      messages: [
        COMMIT_MESSAGE_PROMPT,
        {
          type: 'user',
          content: `${fileStatusPrompt}${diffPrompt}${contextPrompt}`,
        },
      ],
      outputSchema: commitMessageSchema,
      defaultContext: true,
    })
    const { commitMessage } = output as z.infer<typeof commitMessageSchema>

    console.log(`\nCommit message:\n${commitMessage}`)

    yield* tools.createCommit({ message: commitMessage })

    return { commitMessage }
  },
}
