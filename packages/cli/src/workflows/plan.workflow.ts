// generated by polka.codes
import {
  agentWorkflow,
  askFollowupQuestion,
  type FullToolInfo,
  fetchUrl,
  type JsonModelMessage,
  type JsonUserContent,
  listFiles,
  listMemoryTopics,
  readBinaryFile,
  readFile,
  readMemory,
  search,
  searchFiles,
  updateMemory,
  type WorkflowContext,
  type WorkflowFn,
} from '@polka-codes/core'
import { UserCancelledError } from '../errors'
import type { CliToolRegistry } from '../workflow-tools'
import type { JsonFilePart, JsonImagePart } from './code.workflow'
import { getPlanPrompt, PLANNER_SYSTEM_PROMPT, PlanSchema } from './prompts'
import { getDefaultContext } from './workflow.utils'

type CreatePlanInput = {
  task: string
  plan?: string
  userFeedback?: string
  files?: (JsonFilePart | JsonImagePart)[]
  interactive: boolean
  messages?: JsonModelMessage[]
}

async function createPlan(input: CreatePlanInput, context: WorkflowContext<CliToolRegistry>) {
  const { tools, step } = context
  const { task, files, plan: inputPlan, userFeedback, interactive, messages } = input

  const getMessages = async () => {
    if (messages) {
      // continue the thread

      return {
        messages,
        userMessage: [{ role: 'user', content: userFeedback ?? task }],
      } as const
    } else {
      // start a new thread

      const defaultContext = await getDefaultContext()
      const memoryContext = await tools.getMemoryContext()
      const prompt = `${memoryContext}\n${getPlanPrompt(task, inputPlan)}\n\n${defaultContext}`
      const userContent: JsonUserContent = [{ type: 'text', text: prompt }]
      if (files) {
        for (const file of files) {
          if (file.type === 'file') {
            userContent.push({
              type: 'file',
              mediaType: file.mediaType,
              filename: file.filename,
              data: { type: 'base64', value: file.data },
            })
          } else if (file.type === 'image') {
            userContent.push({
              type: 'image',
              mediaType: file.mediaType,
              image: { type: 'base64', value: file.image },
            })
          }
        }
      }

      return {
        systemPrompt: PLANNER_SYSTEM_PROMPT,
        userMessage: [{ role: 'user', content: userContent }],
      } as const
    }
  }

  const agentTools: FullToolInfo[] = [
    readFile,
    listFiles,
    search,
    searchFiles,
    readBinaryFile,
    fetchUrl,
    listMemoryTopics,
    readMemory,
    updateMemory,
  ]
  if (interactive) {
    agentTools.push(askFollowupQuestion)
  }

  const inputMessages = await getMessages()

  const result = await step('plan', async () => {
    return await agentWorkflow(
      {
        ...inputMessages,
        tools: agentTools,
        outputSchema: PlanSchema,
      },
      context,
    )
  })

  if (result.type === 'Exit' && result.object) {
    const { plan, question, reason, files: filePaths } = result.object

    if (reason) {
      return { reason, messages: result.messages }
    }

    if (question) {
      return { plan: plan || inputPlan, question, messages: result.messages }
    }

    const outputFiles: { path: string; content: string }[] = []
    if (filePaths) {
      for (const path of filePaths) {
        const content = await tools.readFile({ path })
        if (content) {
          outputFiles.push({ path, content })
        }
      }
    }
    return { plan: plan || undefined, files: outputFiles, messages: result.messages }
  }

  context.logger.warn('Failed to generate plan.', result)
  throw new Error('Failed to generate plan.')
}

export type PlanWorkflowInput = {
  task?: string
  fileContent?: string
  filePath?: string
  files?: (JsonFilePart | JsonImagePart)[]
  mode?: 'interactive' | 'confirm' | 'noninteractive'
}

export type PlanWorkflowOutput = {
  plan: string
  files: { path: string; content: string }[]
}

type State = 'Generating' | 'Reviewing' | 'Done'

export const planWorkflow: WorkflowFn<PlanWorkflowInput, PlanWorkflowOutput, CliToolRegistry> = async (input, context) => {
  const { tools, logger, step } = context
  const { fileContent, filePath, mode = 'interactive' } = input
  let currentTask = input.task
  let plan = fileContent || ''
  let files: { path: string; content: string }[] = []
  let userFeedback: string | undefined
  let messages: JsonModelMessage[] | undefined
  let state: State = 'Generating'
  let count = 0

  while (state !== 'Done') {
    state = await step(`plan-iteration-${count++}`, async () => {
      switch (state) {
        case 'Generating': {
          if (!currentTask) {
            const message = plan ? 'How would you like to improve the plan?' : 'What is the task you want to plan?'
            const defaultTask = plan ? 'Review and improve the plan' : undefined
            try {
              currentTask = await tools.input({
                message,
                default: defaultTask,
              })
            } catch (_error) {
              return 'Done'
            }
          }

          const planResult = await createPlan(
            {
              task: currentTask,
              plan,
              userFeedback,
              files: input.files,
              interactive: mode === 'interactive' || mode === 'confirm',
              messages,
            },
            context,
          )
          messages = planResult.messages

          if (planResult.reason) {
            logger.info(planResult.reason)
            return 'Done'
          }

          if (planResult.question) {
            try {
              userFeedback = await tools.input({
                message: planResult.question.question,
                default: planResult.question.defaultAnswer || undefined,
              })
              plan = planResult.plan || plan // preserve plan if agent returned one with question
              return 'Generating'
            } catch (error) {
              if (error instanceof UserCancelledError) {
                throw error
              }
              return 'Done'
            }
          }

          plan = planResult.plan || ''
          files = planResult.files || []
          userFeedback = ''
          return 'Reviewing'
        }
        case 'Reviewing': {
          logger.info('\nGenerated Plan:\n')
          logger.info(plan)
          if (files?.length > 0) {
            logger.info('\nFiles:')
            for (const file of files) {
              logger.info(`- ${file.path}`)
            }
          }

          if (mode === 'noninteractive') {
            return 'Done'
          }

          if (mode === 'confirm') {
            try {
              userFeedback = await tools.input({
                message: 'Do you approve this plan and want to proceed with implementation? (leave blank to approve, or enter feedback)',
              })

              if (userFeedback === '') {
                return 'Done'
              } else {
                return 'Generating'
              }
            } catch (error) {
              if (error instanceof UserCancelledError) {
                throw error
              }
              userFeedback = ''
              return 'Reviewing'
            }
          }

          const choices = [
            { name: 'Save Plan', value: 'save' },
            { name: 'Provide Feedback', value: 'feedback' },
            { name: 'Regenerate Plan', value: 'regenerate' },
            { name: 'Exit', value: 'exit' },
          ]

          const choice = await tools.select({
            message: 'What do you want to do?',
            choices,
          })

          switch (choice) {
            case 'save': {
              // Save Plan
              const defaultPath = `.plans/plan-${new Date().toISOString().replace(/:/g, '-')}.md`
              const savePath =
                filePath ||
                (await tools.input({
                  message: 'Where do you want to save the plan?',
                  default: defaultPath,
                }))
              await tools.writeToFile({ path: savePath, content: plan })
              logger.info(`Plan saved to ${savePath}`)
              return 'Done'
            }
            case 'feedback': {
              // Provide Feedback
              try {
                userFeedback = await tools.input({
                  message: 'What changes do you want to make?',
                })
                return 'Generating'
              } catch (_error) {
                userFeedback = ''
                return 'Reviewing'
              }
            }
            case 'regenerate': {
              // Regenerate Plan
              plan = ''
              userFeedback = ''
              messages = undefined
              return 'Generating'
            }
            case 'exit': {
              // Exit
              return 'Done'
            }
            default:
              throw new Error(`Invalid mode: ${mode}`)
          }
        }
        default:
          throw new Error(`Invalid state: ${state}`)
      }
    })
  }

  return { plan, files }
}
