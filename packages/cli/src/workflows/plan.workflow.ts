// generated by polka.codes
import { handOver, listFiles, readFile, searchFiles, ToolResponseType } from '@polka-codes/core'
import { agentWorkflow, type JsonUserContent, type WorkflowContext, type WorkflowFn } from '@polka-codes/workflow'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import type { JsonFilePart, JsonImagePart } from './code.workflow'
import { ARCHITECT_SYSTEM_PROMPT, PLAN_PROMPT } from './prompts'

const PlanSchema = z.object({
  plan: z.string().nullish(),
  question: z.string().nullish(),
  reason: z.string().nullish(),
  files: z.array(z.string()).nullish(),
})

export type CreatePlanOutput = {
  plan?: string
  reason?: string
  files?: { path: string; content: string }[]
  question?: string
}

export type CreatePlanInput = {
  task: string
  plan?: string
  userFeedback?: string
  files?: (JsonFilePart | JsonImagePart)[]
}

async function createPlan(input: CreatePlanInput, context: WorkflowContext<CliToolRegistry>): Promise<CreatePlanOutput> {
  const { tools, step } = context
  const { task, files, plan: inputPlan, userFeedback } = input

  const currentTask = userFeedback ? `${task}\n\nUser feedback: ${userFeedback}` : task
  const planContent = inputPlan ? `The content of an existing plan file:\n<plan_file>\n${inputPlan}\n</plan_file>` : ''
  const prompt = PLAN_PROMPT.replace('{task}', currentTask).replace('{planContent}', planContent)

  const userContent: JsonUserContent = [{ type: 'text', text: prompt }]
  if (files) {
    for (const file of files) {
      if (file.type === 'file') {
        userContent.push({
          type: 'file',
          mediaType: file.mediaType,
          filename: file.filename,
          data: { type: 'base64', value: file.data },
        })
      } else if (file.type === 'image') {
        userContent.push({
          type: 'image',
          mediaType: file.mediaType,
          image: { type: 'base64', value: file.image },
        })
      }
    }
  }

  const result = await step('plan', async () => {
    return await agentWorkflow(
      {
        systemPrompt: ARCHITECT_SYSTEM_PROMPT,
        userMessage: [{ role: 'user', content: userContent }],
        tools: [readFile, listFiles, searchFiles, handOver],
        outputSchema: PlanSchema,
      },
      context,
    )
  })

  if (result.type === ToolResponseType.Exit && result.object) {
    const { plan, question, reason, files: filePaths } = result.object

    if (reason) {
      return { reason }
    }

    if (question) {
      return { plan: plan || inputPlan, question }
    }

    const outputFiles: { path: string; content: string }[] = []
    if (filePaths) {
      for (const path of filePaths) {
        const content = await tools.readFile({ path })
        if (content) {
          outputFiles.push({ path, content })
        }
      }
    }
    return { plan: plan || undefined, files: outputFiles }
  }

  context.logger.warn('Failed to generate plan.', result)
  throw new Error('Failed to generate plan.')
}

export type PlanWorkflowInput = {
  task?: string
  fileContent?: string
  filePath?: string
  files?: (JsonFilePart | JsonImagePart)[]
  mode?: 'interactive' | 'confirm'
}

export type PlanWorkflowOutput = {
  plan: string
  files: CreatePlanOutput['files']
}

type State = 'Generating' | 'Reviewing' | 'Done'

export const planWorkflow: WorkflowFn<PlanWorkflowInput, PlanWorkflowOutput, CliToolRegistry> = async (input, { tools, logger, step }) => {
  const { fileContent, filePath, mode = 'interactive' } = input
  let currentTask = input.task
  let plan = fileContent || ''
  let files: CreatePlanOutput['files'] = []
  let userFeedback = ''
  let state: State = 'Generating'

  while (state !== 'Done') {
    switch (state) {
      case 'Generating': {
        if (!currentTask) {
          const message = plan ? 'How would you like to improve the plan?' : 'What is the task you want to plan?'
          const defaultTask = plan ? 'Review and improve the plan' : undefined
          try {
            currentTask = await tools.input({
              message,
              default: defaultTask,
            })
          } catch (_error) {
            state = 'Done'
            break
          }
        }

        const planResult = await createPlan(
          {
            task: currentTask,
            plan,
            userFeedback,
            files: input.files,
          },
          { tools, logger, step },
        )

        if (planResult.reason) {
          logger.info(planResult.reason)
          state = 'Done'
          break
        }

        if (planResult.question) {
          try {
            userFeedback = await tools.input({ message: planResult.question })
            plan = planResult.plan || plan // preserve plan if agent returned one with question
            state = 'Generating'
          } catch (_error) {
            state = 'Done'
            break
          }
          break
        }

        plan = planResult.plan || ''
        files = planResult.files || []
        userFeedback = ''
        state = 'Reviewing'
        break
      }
      case 'Reviewing': {
        logger.info('\nGenerated Plan:\n')
        logger.info(plan)
        if (files.length > 0) {
          logger.info('\nFiles:')
          for (const file of files) {
            logger.info(`- ${file.path}`)
          }
        }

        if (mode === 'confirm') {
          const approved = await tools.confirm({
            message: 'Do you approve this plan and want to proceed with implementation?',
            default: false,
          })

          if (approved) {
            return { plan, files }
          }

          try {
            userFeedback = await tools.input({
              message: 'What changes would you like to make to the plan?',
            })
            state = 'Generating'
          } catch (_error) {
            userFeedback = ''
            state = 'Reviewing'
          }
          break
        }

        const choices = [
          { name: 'Save Plan', value: 'save' },
          { name: 'Provide Feedback', value: 'feedback' },
          { name: 'Regenerate Plan', value: 'regenerate' },
          { name: 'Exit', value: 'exit' },
        ]

        const choice = await tools.select({
          message: 'What do you want to do?',
          choices,
        })

        switch (choice) {
          case 'save': {
            // Save Plan
            const defaultPath = `.plans/plan-${new Date().toISOString().replace(/:/g, '-')}.md`
            const savePath =
              filePath ||
              (await tools.input({
                message: 'Where do you want to save the plan?',
                default: defaultPath,
              }))
            await tools.writeToFile({ path: savePath, content: plan })
            logger.info(`Plan saved to ${savePath}`)
            state = 'Done'
            break
          }
          case 'feedback': {
            // Provide Feedback
            try {
              userFeedback = await tools.input({
                message: 'What changes do you want to make?',
              })
              state = 'Generating'
            } catch (_error) {
              userFeedback = ''
              state = 'Reviewing'
            }
            break
          }
          case 'regenerate': {
            // Regenerate Plan
            plan = ''
            userFeedback = ''
            state = 'Generating'
            break
          }
          case 'exit': {
            // Exit
            state = 'Done'
            break
          }
          default:
            throw new Error(`Invalid mode: ${mode}`)
        }
        break
      }
      default:
        throw new Error(`Invalid state: ${state}`)
    }
  }

  return { plan, files }
}
