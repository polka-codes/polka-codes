// generated by polka.codes

import { afterEach, describe, expect, mock, spyOn, test } from 'bun:test'
import type { WorkflowContextV2 } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { planWorkflow } from './plan.workflow'
import * as createPlanModule from './utils/createPlan'

const createMockContext = () => {
  const toolHandler = {
    input: mock<any>(),
    select: mock<any>(),
    writeToFile: mock<any>(),
    invokeAgent: mock<any>(),
    readFile: mock<any>(),
  }
  const step = mock(async (_name: string, fn: () => any) => fn())
  const logger = {
    info: mock(() => {}),
    error: mock(() => {}),
    warn: mock(() => {}),
    debug: mock(() => {}),
  }

  const context = {
    toolHandler,
    step,
    logger,
  } as unknown as WorkflowContextV2<CliToolRegistry>

  return { context, toolHandler, step, logger }
}

describe('planWorkflow', () => {
  afterEach(() => {
    mock.restore()
  })

  test('should generate new plan, ask for save path, and save', async () => {
    const { context, toolHandler } = createMockContext()
    const createPlanSpy = spyOn(createPlanModule, 'createPlan').mockResolvedValue({ plan: '# New Plan' })

    toolHandler.select.mockResolvedValue('save')
    toolHandler.input.mockResolvedValue('my-plan.md')

    await planWorkflow({ task: 'Test task' }, context)

    expect(createPlanSpy).toHaveBeenCalledWith({
      toolHandler: context.toolHandler,
      task: 'Test task',
      plan: '',
      userFeedback: '',
    })
    expect(toolHandler.select).toHaveBeenCalled()
    expect(toolHandler.input).toHaveBeenCalledWith({
      message: 'Where do you want to save the plan?',
      default: expect.stringMatching(/^\.plans\/plan-.*\.md$/),
    })
    expect(toolHandler.writeToFile).toHaveBeenCalledWith({ path: 'my-plan.md', content: '# New Plan' })
  })

  test('should execute plan when user chooses execute', async () => {
    const { context, toolHandler } = createMockContext()
    const createPlanSpy = spyOn(createPlanModule, 'createPlan').mockResolvedValue({ plan: '# Execute Plan', files: [] })

    toolHandler.select.mockResolvedValue('execute')

    await planWorkflow({ task: 'Test task' }, context)

    expect(createPlanSpy).toHaveBeenCalledTimes(1)
    expect(toolHandler.select).toHaveBeenCalledTimes(1)
    expect(toolHandler.invokeAgent).toHaveBeenCalledWith({
      agent: 'coder',
      messages: expect.any(Array),
      defaultContext: true,
    })
  })

  test('should gather feedback and regenerate plan', async () => {
    const { context, toolHandler } = createMockContext()
    const createPlanSpy = spyOn(createPlanModule, 'createPlan')

    createPlanSpy.mockResolvedValueOnce({ plan: '# First Plan' })
    toolHandler.select.mockResolvedValueOnce('feedback')
    toolHandler.input.mockResolvedValueOnce('Some feedback')

    // Second iteration
    createPlanSpy.mockResolvedValueOnce({ plan: '# Second Plan' })
    toolHandler.select.mockResolvedValueOnce('exit')

    await planWorkflow({ task: 'Test task' }, context)

    expect(createPlanSpy).toHaveBeenCalledTimes(2)
    expect(createPlanSpy).toHaveBeenCalledWith({
      toolHandler: context.toolHandler,
      task: 'Test task',
      plan: '',
      userFeedback: '',
    })
    expect(createPlanSpy).toHaveBeenCalledWith({
      toolHandler: context.toolHandler,
      task: 'Test task',
      plan: '# First Plan',
      userFeedback: 'Some feedback',
    })
    expect(toolHandler.select).toHaveBeenCalledTimes(2)
    expect(toolHandler.input).toHaveBeenCalledWith({ message: 'What changes do you want to make?' })
  })

  test('should regenerate plan from scratch when user chooses regenerate', async () => {
    const { context, toolHandler } = createMockContext()
    const createPlanSpy = spyOn(createPlanModule, 'createPlan')

    createPlanSpy.mockResolvedValueOnce({ plan: '# First Plan' })
    toolHandler.select.mockResolvedValueOnce('regenerate')

    createPlanSpy.mockResolvedValueOnce({ plan: '# Second Plan' })
    toolHandler.select.mockResolvedValueOnce('exit')

    await planWorkflow({ task: 'Test task' }, context)

    expect(createPlanSpy).toHaveBeenCalledTimes(2)
    expect(createPlanSpy.mock.calls[0][0].plan).toBe('')
    expect(createPlanSpy.mock.calls[1][0].plan).toBe('') // It gets reset
    expect(toolHandler.select).toHaveBeenCalledTimes(2)
  })

  test('should exit when user chooses exit', async () => {
    const { context, toolHandler } = createMockContext()
    const createPlanSpy = spyOn(createPlanModule, 'createPlan').mockResolvedValue({ plan: '# My Plan' })
    toolHandler.select.mockResolvedValue('exit')

    await planWorkflow({ task: 'Test task' }, context)

    expect(createPlanSpy).toHaveBeenCalledTimes(1)
    expect(toolHandler.select).toHaveBeenCalledTimes(1)
    expect(toolHandler.writeToFile).not.toHaveBeenCalled()
    expect(toolHandler.invokeAgent).not.toHaveBeenCalled()
  })

  test('should prompt for task if not provided', async () => {
    const { context, toolHandler } = createMockContext()
    const createPlanSpy = spyOn(createPlanModule, 'createPlan').mockResolvedValue({ plan: '# Plan for new task' })

    toolHandler.input.mockResolvedValueOnce('A new task')
    toolHandler.select.mockResolvedValue('exit')

    await planWorkflow({}, context)

    expect(toolHandler.input).toHaveBeenCalledWith({
      message: 'What is the task you want to plan?',
      default: undefined,
    })
    expect(createPlanSpy).toHaveBeenCalledWith(expect.objectContaining({ task: 'A new task' }))
  })
})
