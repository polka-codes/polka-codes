// generated by polka.codes
import { afterEach, beforeEach, describe, expect, mock, spyOn, test } from 'bun:test'
import { ToolResponseType } from '@polka-codes/core'
import * as workflow from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { planWorkflow } from './plan.workflow'

const createMockContext = () => {
  const tools = {
    confirm: mock<any>(),
    input: mock<any>(),
    select: mock<any>(),
    writeToFile: mock<any>(),
    readFile: mock<any>(),
    getMemoryContext: mock<any>(async () => ''),
  }
  const step = mock(async (_name: string, fn: () => any) => fn())
  const logger = {
    info: mock(() => {}),
    error: mock(() => {}),
    warn: mock(() => {}),
    debug: mock(() => {}),
  }

  const context = {
    tools,
    step,
    logger,
  } as unknown as workflow.WorkflowContext<CliToolRegistry>

  return { context, tools, step, logger }
}

describe('planWorkflow', () => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let agentWorkflowSpy: any

  beforeEach(() => {
    agentWorkflowSpy = spyOn(workflow, 'agentWorkflow')
  })

  afterEach(() => {
    agentWorkflowSpy.mockRestore()
  })

  test('should generate a plan and save it', async () => {
    const { context, tools, logger } = createMockContext()
    const task = 'Create a new component'
    const generatedPlan = '1. Create the component file.'
    const savePath = '.plans/test.md'

    agentWorkflowSpy.mockResolvedValue({
      type: ToolResponseType.Exit,
      object: {
        plan: generatedPlan,
      },
    })

    tools.select.mockResolvedValue('save')
    tools.input.mockResolvedValue(savePath)

    const result = await planWorkflow({ task, mode: 'interactive' }, context)

    expect(agentWorkflowSpy).toHaveBeenCalledTimes(1)
    expect(result.plan).toBe(generatedPlan)
    expect(tools.select).toHaveBeenCalledWith({
      message: 'What do you want to do?',
      choices: [
        { name: 'Save Plan', value: 'save' },
        { name: 'Provide Feedback', value: 'feedback' },
        { name: 'Regenerate Plan', value: 'regenerate' },
        { name: 'Exit', value: 'exit' },
      ],
    })
    expect(tools.input).toHaveBeenCalledWith({
      message: 'Where do you want to save the plan?',
      default: expect.any(String),
    })
    expect(tools.writeToFile).toHaveBeenCalledWith({
      path: savePath,
      content: generatedPlan,
    })
    expect(logger.info).toHaveBeenCalledWith(`Plan saved to ${savePath}`)
  })

  test('should handle user feedback and regenerate plan', async () => {
    const { context, tools } = createMockContext()
    const task = 'Create a new component'
    const initialPlan = '1. Create the component file.'
    const feedback = 'Add a test file.'
    const regeneratedPlan = '1. Create the component file.\n2. Create a test file.'

    agentWorkflowSpy
      .mockResolvedValueOnce({
        type: ToolResponseType.Exit,
        object: {
          plan: initialPlan,
        },
      })
      .mockResolvedValueOnce({
        type: ToolResponseType.Exit,
        object: {
          plan: regeneratedPlan,
        },
      })

    tools.select.mockResolvedValueOnce('feedback').mockResolvedValueOnce('exit')
    tools.input.mockResolvedValueOnce(feedback)

    const result = await planWorkflow({ task, mode: 'interactive' }, context)

    expect(agentWorkflowSpy).toHaveBeenCalledTimes(2)
    expect(result.plan).toBe(regeneratedPlan)
  })

  test('should exit the workflow', async () => {
    const { context, tools } = createMockContext()
    const task = 'Create a new component'
    const generatedPlan = '1. Create the component file.'

    agentWorkflowSpy.mockResolvedValue({
      type: ToolResponseType.Exit,
      object: {
        plan: generatedPlan,
      },
    })

    tools.select.mockResolvedValue('exit')

    const result = await planWorkflow({ task, mode: 'interactive' }, context)
    expect(result.plan).toBe(generatedPlan)
    expect(tools.select).toHaveBeenCalledTimes(1)
  })
})
