// generated by polka.codes

import { expect, test } from 'bun:test'
import assert from 'node:assert/strict'
import { run } from '@polka-codes/workflow'
import { planWorkflow } from './plan.workflow'

test('should generate new plan without questions and save with default path', async () => {
  const result1 = await run(planWorkflow, { task: 'Build a REST API' })
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# REST API Plan\n\n1. Setup Express server\n2. Define routes\n3. Add middleware' },
    messages: [],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  assert(result3.status === 'pending' && result3.tool.tool === 'input')
  expect(result3.tool.input.message).toBe('Where do you want to save the plan?')
  expect(result3.tool.input.default).toMatch(/^\.plans\/plan-.*\.md$/)

  const result4 = await result3.next('.plans/plan-2025-10-08.md')
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  const result5 = await result4.next()
  expect(result5).toMatchSnapshot()
})

test('should generate plan with clarifying question', async () => {
  const result1 = await run(planWorkflow, { task: 'Create a web app' })
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { question: 'What framework do you want to use?' },
    messages: [],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  const result3 = await result2.next('React with TypeScript')
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  const result4 = await result3.next({
    output: { plan: '# Web App Plan\n\n1. Setup React + TypeScript\n2. Configure build tools\n3. Create components' },
    messages: [],
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  const result5 = await result4.next('save')
  assert(result5.status === 'pending')

  const result6 = await result5.next('.plans/webapp-plan.md')
  assert(result6.status === 'pending')

  const result7 = await result6.next()
  expect(result7).toMatchSnapshot()
})

test('should update existing plan', async () => {
  const existingPlan = '# API Plan\n\n1. Setup server\n2. Add routes'
  const result1 = await run(planWorkflow, {
    task: 'Add authentication',
    fileContent: existingPlan,
    filePath: '.plans/api-plan.md',
  })
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: {
      plan: '# API Plan\n\n1. Setup server\n2. Add routes\n3. Implement authentication\n   - JWT tokens\n   - Login/logout endpoints',
    },
    messages: [],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  assert(result3.status === 'pending')

  const result4 = await result3.next()
  expect(result4).toMatchSnapshot()
})

test('should handle user feedback and regenerate', async () => {
  const result1 = await run(planWorkflow, { task: 'Build a mobile app' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# Mobile App Plan\n\n1. Choose native development\n2. Build iOS app\n3. Build Android app' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('feedback')
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  const result4 = await result3.next('Use React Native instead of native development')
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  const result5 = await result4.next({
    output: {
      plan: '# Mobile App Plan\n\n1. Setup React Native\n2. Configure for iOS and Android\n3. Build cross-platform app',
    },
    messages: [],
  })
  assert(result5.status === 'pending')

  const result6 = await result5.next('save')
  assert(result6.status === 'pending')

  const result7 = await result6.next('.plans/mobile-plan.md')
  assert(result7.status === 'pending')

  const result8 = await result7.next()
  expect(result8).toMatchSnapshot()
})

test('should regenerate plan from scratch', async () => {
  const result1 = await run(planWorkflow, { task: 'Create a CLI tool' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# CLI Tool Plan\n\n1. Use Python\n2. Add argparse' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('regenerate')
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  const result4 = await result3.next({
    output: { plan: '# CLI Tool Plan\n\n1. Use Node.js with Commander\n2. Add TypeScript support' },
    messages: [],
  })
  assert(result4.status === 'pending')

  const result5 = await result4.next('exit')
  expect(result5).toMatchSnapshot()
})

test('should execute plan', async () => {
  const result1 = await run(planWorkflow, { task: 'Fix bugs in authentication' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# Bug Fix Plan\n\n1. Review auth code\n2. Fix token validation\n3. Add tests' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('execute')
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  const result4 = await result3.next()
  expect(result4).toMatchSnapshot()
})

test('should exit without saving', async () => {
  const result1 = await run(planWorkflow, { task: 'Design database schema' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# Database Schema\n\n1. Users table\n2. Posts table\n3. Comments table' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('exit')
  expect(result3).toMatchSnapshot()
})

test('should handle multiple clarifying questions', async () => {
  const result1 = await run(planWorkflow, { task: 'Build a data processing pipeline' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { question: 'What is the data source?' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('PostgreSQL database')
  assert(result3.status === 'pending')

  const result4 = await result3.next({
    output: { question: 'What is the target format?' },
    messages: [],
  })
  assert(result4.status === 'pending')

  const result5 = await result4.next('JSON files')
  assert(result5.status === 'pending')

  const result6 = await result5.next({
    output: {
      plan: '# Data Pipeline Plan\n\n1. Connect to PostgreSQL\n2. Extract data\n3. Transform to JSON\n4. Write to files',
    },
    messages: [],
  })
  assert(result6.status === 'pending')

  const result7 = await result6.next('save')
  assert(result7.status === 'pending')

  const result8 = await result7.next('.plans/pipeline-plan.md')
  assert(result8.status === 'pending')

  const result9 = await result8.next()
  expect(result9).toMatchSnapshot()
})

test('should handle multiple feedback iterations', async () => {
  const result1 = await run(planWorkflow, { task: 'Implement caching layer' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# Caching Plan\n\n1. Use in-memory cache' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('feedback')
  assert(result3.status === 'pending')

  const result4 = await result3.next('Add Redis support')
  assert(result4.status === 'pending')

  const result5 = await result4.next({
    output: { plan: '# Caching Plan\n\n1. Setup Redis\n2. Implement cache layer' },
    messages: [],
  })
  assert(result5.status === 'pending')

  const result6 = await result5.next('feedback')
  assert(result6.status === 'pending')

  const result7 = await result6.next('Add cache invalidation strategy')
  assert(result7.status === 'pending')

  const result8 = await result7.next({
    output: { plan: '# Caching Plan\n\n1. Setup Redis\n2. Implement cache layer\n3. Add TTL-based invalidation' },
    messages: [],
  })
  assert(result8.status === 'pending')

  const result9 = await result8.next('save')
  assert(result9.status === 'pending')

  const result10 = await result9.next('.plans/cache-plan.md')
  assert(result10.status === 'pending')

  const result11 = await result10.next()
  expect(result11).toMatchSnapshot()
})

test('should save plan with custom path', async () => {
  const result1 = await run(planWorkflow, { task: 'Migrate to microservices' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: {
      plan: '# Microservices Migration\n\n1. Identify service boundaries\n2. Extract services\n3. Setup API gateway',
    },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  assert(result3.status === 'pending')

  const result4 = await result3.next('docs/architecture/microservices-plan.md')
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  const result5 = await result4.next()
  expect(result5).toMatchSnapshot()
})

test('should handle plan with both plan and question returned', async () => {
  const result1 = await run(planWorkflow, { task: 'Setup CI/CD pipeline' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: {
      plan: '# CI/CD Pipeline\n\n1. Choose CI platform',
      question: 'Which CI platform do you prefer: GitHub Actions, GitLab CI, or Jenkins?',
    },
    messages: [],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  const result3 = await result2.next('GitHub Actions')
  assert(result3.status === 'pending')

  const result4 = await result3.next({
    output: {
      plan: '# CI/CD Pipeline\n\n1. Setup GitHub Actions\n2. Configure workflows\n3. Add deployment steps',
    },
    messages: [],
  })
  assert(result4.status === 'pending')

  const result5 = await result4.next('execute')
  assert(result5.status === 'pending')

  const result6 = await result5.next()
  expect(result6).toMatchSnapshot()
})

test('should handle empty task input', async () => {
  const result1 = await run(planWorkflow, { task: '' })
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  const result2 = await result1.next('Create a landing page')
  assert(result2.status === 'pending')

  const result3 = await result2.next({
    output: { plan: '# Landing Page\n\n1. Design layout\n2. Implement HTML/CSS\n3. Add interactivity' },
    messages: [],
  })
  assert(result3.status === 'pending')

  const result4 = await result3.next('exit')
  expect(result4).toMatchSnapshot()
})

test('should handle plan with checklist format', async () => {
  const result1 = await run(planWorkflow, { task: 'Onboard new team member' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: {
      plan: '# Onboarding Plan\n\n- [ ] Setup dev environment\n- [ ] Grant access to repositories\n- [ ] Review codebase\n- [ ] Assign first task',
    },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  assert(result3.status === 'pending')

  const result4 = await result3.next('.plans/onboarding.md')
  assert(result4.status === 'pending')

  const result5 = await result4.next()
  expect(result5).toMatchSnapshot()
})

test('should handle complex plan with mixed formats', async () => {
  const result1 = await run(planWorkflow, { task: 'Launch new feature' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: {
      plan: `# Feature Launch Plan

1. Development Phase
   - [ ] Implement core functionality
   - [ ] Write unit tests
   - [ ] Code review

2. Testing Phase
   a. QA testing
   b. User acceptance testing
   c. Performance testing

3. Deployment
   1. Deploy to staging
   2. Run smoke tests
   3. Deploy to production
   4. Monitor metrics`,
    },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  assert(result3.status === 'pending')

  const result4 = await result3.next('.plans/feature-launch.md')
  assert(result4.status === 'pending')

  const result5 = await result4.next()
  expect(result5).toMatchSnapshot()
})

test('should handle workflow with question, feedback, and save cycle', async () => {
  const result1 = await run(planWorkflow, { task: 'Optimize application performance' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { question: 'What are the main performance bottlenecks?' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('Slow database queries and large bundle size')
  assert(result3.status === 'pending')

  const result4 = await result3.next({
    output: {
      plan: '# Performance Optimization\n\n1. Optimize database queries\n2. Reduce bundle size',
    },
    messages: [],
  })
  assert(result4.status === 'pending')

  const result5 = await result4.next('feedback')
  assert(result5.status === 'pending')

  const result6 = await result5.next('Add caching strategy')
  assert(result6.status === 'pending')

  const result7 = await result6.next({
    output: {
      plan: '# Performance Optimization\n\n1. Optimize database queries\n2. Reduce bundle size\n3. Implement Redis caching',
    },
    messages: [],
  })
  assert(result7.status === 'pending')

  const result8 = await result7.next('save')
  assert(result8.status === 'pending')

  const result9 = await result8.next('.plans/performance-optimization.md')
  assert(result9.status === 'pending')

  const result10 = await result9.next()
  expect(result10).toMatchSnapshot()
})

test('should prompt for task when none is provided', async () => {
  const result1 = await run(planWorkflow, {})
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  assert(result1.tool.tool === 'input')
  expect(result1.tool.input.message).toBe('What is the task you want to plan?')

  const result2 = await result1.next('Create a new feature')
  expect(result2).toMatchSnapshot()
})

test('should prompt for improvement when only a plan is provided', async () => {
  const result1 = await run(planWorkflow, { fileContent: 'Some existing plan' })
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  assert(result1.tool.tool === 'input')
  expect(result1.tool.input.message).toBe('How would you like to improve the plan?')
  expect(result1.tool.input.default).toBe('Review and improve the plan')

  const result2 = await result1.next('Add more details')
  expect(result2).toMatchSnapshot()
})

test('should handle user cancellation of initial task input', async () => {
  const result1 = await run(planWorkflow, {})
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  const result2 = await result1.throw(new Error('User cancelled'))
  expect(result2).toMatchSnapshot()
  expect(result2.status).toBe('completed')
})

test('should handle user cancellation of feedback input', async () => {
  const result1 = await run(planWorkflow, { task: 'My task' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({ output: { plan: 'My plan' }, messages: [] })
  assert(result2.status === 'pending')

  const result3 = await result2.next('feedback')
  assert(result3.status === 'pending')

  const result4 = await result3.throw(new Error('User cancelled'))
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  assert(result4.tool.tool === 'select')
  expect(result4.tool.input.message).toBe('What do you want to do?')
})

test('should save a new plan directly using a provided filePath', async () => {
  const result1 = await run(planWorkflow, { task: 'My task', filePath: 'path/to/plan.md' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({ output: { plan: 'My plan' }, messages: [] })
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  assert(result3.tool.tool === 'writeToFile')
  expect(result3.tool.input.path).toBe('path/to/plan.md')
  expect(result3.tool.input.content).toBe('My plan')
})

test('should handle user cancellation of save path input', async () => {
  const result1 = await run(planWorkflow, { task: 'My task' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({ output: { plan: 'My plan' }, messages: [] })
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  assert(result3.status === 'pending')

  const result4 = await result3.throw(new Error('User cancelled'))
  expect(result4).toMatchSnapshot()
  // This is not ideal, the workflow should probably go back to the 'Reviewing' state.
  // But for now, we test the current behavior.
  // Based on the implementation, itseems an unhandled error will terminate the workflow.
  expect(result4.status).toBe('failed')
})

test('should update existing plan with filePath provided', async () => {
  const existingPlan = '# Security Audit\n\n1. Review authentication'
  const result1 = await run(planWorkflow, {
    task: 'Add more security checks',
    fileContent: existingPlan,
    filePath: 'docs/security-audit.md',
  })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: {
      plan: '# Security Audit\n\n1. Review authentication\n2. Check authorization\n3. Audit data encryption\n4. Review API security',
    },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('save')
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  const result4 = await result3.next()
  expect(result4).toMatchSnapshot()
})

test('should handle regenerate after feedback', async () => {
  const result1 = await run(planWorkflow, { task: 'Implement search feature' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    output: { plan: '# Search Feature\n\n1. Basic keyword search' },
    messages: [],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next('feedback')
  assert(result3.status === 'pending')

  const result4 = await result3.next('Add full-text search with Elasticsearch')
  assert(result4.status === 'pending')

  const result5 = await result4.next({
    output: { plan: '# Search Feature\n\n1. Setup Elasticsearch\n2. Implement full-text search' },
    messages: [],
  })
  assert(result5.status === 'pending')

  const result6 = await result5.next('regenerate')
  assert(result6.status === 'pending')

  const result7 = await result6.next({
    output: { plan: '# Search Feature\n\n1. Evaluate search solutions\n2. Implement chosen solution\n3. Add filters' },
    messages: [],
  })
  assert(result7.status === 'pending')

  const result8 = await result7.next('save')
  assert(result8.status === 'pending')

  const result9 = await result8.next('.plans/search.md')
  assert(result9.status === 'pending')

  const result10 = await result9.next()
  expect(result10).toMatchSnapshot()
})
