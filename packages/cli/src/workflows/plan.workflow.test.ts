// generated by polka.codes
import { describe, expect, it, vi } from 'bun:test'
import type { WorkflowContextV2 } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { planWorkflow } from './plan.workflow'

// Helper to create a mocked context
const createMockContext = () => {
  const toolHandler: Partial<WorkflowContextV2<CliToolRegistry>['toolHandler']> = {
    invokeAgent: vi.fn(),
    input: vi.fn(),
    confirm: vi.fn(),
    select: vi.fn(),
    writeToFile: vi.fn(),
    readFile: vi.fn(),
  }

  return {
    toolHandler: toolHandler as WorkflowContextV2<CliToolRegistry>['toolHandler'],
    logger: {
      info: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
      debug: vi.fn(),
    },
    step: vi.fn((_name, options) => options.run()),
  }
}

describe('planWorkflow', () => {
  it('Interactive Mode - Save Plan', async () => {
    const mockContext = createMockContext()
    const task = 'Create a new component'
    const plan = '1. Create the component file. 2. Add styles.'
    const savePath = 'my-plan.md'

    vi.spyOn(mockContext.toolHandler, 'input').mockResolvedValueOnce(task).mockResolvedValueOnce(savePath)
    vi.spyOn(mockContext.toolHandler, 'invokeAgent').mockResolvedValue({ output: { plan }, messages: [] })
    vi.spyOn(mockContext.toolHandler, 'select').mockResolvedValue('save')

    await planWorkflow({}, mockContext)

    expect(mockContext.logger.info).toHaveBeenCalledWith('\nGenerated Plan:\n')
    expect(mockContext.logger.info).toHaveBeenCalledWith(plan)
    expect(mockContext.toolHandler.select).toHaveBeenCalled()
    expect(mockContext.toolHandler.writeToFile).toHaveBeenCalledWith({
      path: savePath,
      content: plan,
    })
    expect(mockContext.logger.info).toHaveBeenCalledWith(`Plan saved to ${savePath}`)
  })

  it('Interactive Mode - Provide Feedback', async () => {
    const mockContext = createMockContext()
    const task = 'Initial task'
    const initialPlan = 'Initial plan content'
    const feedback = 'This is my feedback'
    const finalPlan = 'Final plan after feedback'

    const invokeAgentSpy = vi
      .spyOn(mockContext.toolHandler, 'invokeAgent')
      .mockResolvedValueOnce({ output: { plan: initialPlan }, messages: [] })
      .mockResolvedValueOnce({ output: { plan: finalPlan }, messages: [] })

    vi.spyOn(mockContext.toolHandler, 'input').mockResolvedValueOnce(task).mockResolvedValueOnce(feedback)

    vi.spyOn(mockContext.toolHandler, 'select').mockResolvedValueOnce('feedback').mockResolvedValueOnce('exit')

    await planWorkflow({}, mockContext)

    expect(invokeAgentSpy).toHaveBeenCalledTimes(2)
    const secondCall = invokeAgentSpy.mock.calls[1][0]
    expect((secondCall.messages[0] as any).content).toContain(feedback)
    expect(mockContext.logger.info).toHaveBeenCalledWith(finalPlan)
  })

  it('Confirm Mode - Approve', async () => {
    const mockContext = createMockContext()
    const task = 'Confirm mode task'
    const plan = 'Plan to be approved'

    vi.spyOn(mockContext.toolHandler, 'invokeAgent').mockResolvedValue({ output: { plan }, messages: [] })
    vi.spyOn(mockContext.toolHandler, 'confirm').mockResolvedValue(true)

    const result = await planWorkflow({ task, mode: 'confirm' }, mockContext)

    expect(mockContext.toolHandler.invokeAgent).toHaveBeenCalledTimes(1)
    expect(mockContext.logger.info).toHaveBeenCalledWith(plan)
    expect(mockContext.toolHandler.confirm).toHaveBeenCalledWith({
      message: 'Do you approve this plan and want to proceed with implementation?',
      default: false,
    })
    expect(result.plan).toBe(plan)
  })

  it('Confirm Mode - Reject and Feedback', async () => {
    const mockContext = createMockContext()
    const task = 'Confirm mode task'
    const plan = 'Plan to be rejected'
    const feedback = 'Needs more detail'
    const newPlan = 'Reworked plan'

    vi.spyOn(mockContext.toolHandler, 'confirm').mockResolvedValueOnce(false).mockResolvedValueOnce(true)
    vi.spyOn(mockContext.toolHandler, 'input').mockResolvedValue(feedback)
    const invokeAgentSpy = vi
      .spyOn(mockContext.toolHandler, 'invokeAgent')
      .mockResolvedValueOnce({ output: { plan }, messages: [] })
      .mockResolvedValueOnce({ output: { plan: newPlan }, messages: [] })

    await planWorkflow({ task, mode: 'confirm' }, mockContext as any)

    expect(mockContext.toolHandler.confirm).toHaveBeenCalledTimes(2)
    expect(mockContext.toolHandler.input).toHaveBeenCalledWith({
      message: 'What changes would you like to make to the plan?',
    })
    expect(invokeAgentSpy).toHaveBeenCalledTimes(2)
    const secondCall = invokeAgentSpy.mock.calls[1][0]
    expect((secondCall.messages[0] as any).content).toContain(feedback)
  })

  it('Agent Returns a Reason', async () => {
    const mockContext = createMockContext()
    const task = 'A task'
    const reason = 'I cannot fulfill this request because...'

    vi.spyOn(mockContext.toolHandler, 'invokeAgent').mockResolvedValue({ output: { reason }, messages: [] })

    await planWorkflow({ task }, mockContext)

    expect(mockContext.logger.info).toHaveBeenCalledWith(reason)
    expect(mockContext.toolHandler.select).not.toHaveBeenCalled()
  })

  it('Agent Asks a Follow-up Question', async () => {
    const mockContext = createMockContext()
    const task = 'My task'
    const question = 'Which framework do you want to use?'
    const answer = 'React'
    const finalPlan = 'Plan using React'

    const invokeAgentSpy = vi
      .spyOn(mockContext.toolHandler, 'invokeAgent')
      .mockResolvedValueOnce({ output: { question }, messages: [] })
      .mockResolvedValueOnce({ output: { plan: finalPlan }, messages: [] })

    vi.spyOn(mockContext.toolHandler, 'input').mockResolvedValueOnce(task).mockResolvedValueOnce(answer)
    vi.spyOn(mockContext.toolHandler, 'select').mockResolvedValue('exit') // Exit after plan is generated

    await planWorkflow({}, mockContext as any)

    expect(mockContext.toolHandler.input).toHaveBeenCalledWith({ message: question })
    expect(invokeAgentSpy).toHaveBeenCalledTimes(2)
    const secondCall = invokeAgentSpy.mock.calls[1][0]
    expect((secondCall.messages[0] as any).content).toContain(`Question: ${question}\nAnswer: ${answer}`)
    expect(mockContext.logger.info).toHaveBeenCalledWith(finalPlan)
  })

  it('Interactive Mode - Execute Plan', async () => {
    const mockContext = createMockContext()
    const task = 'Implement a feature'
    const plan = '1. Do this. 2. Do that.'

    vi.spyOn(mockContext.toolHandler, 'input').mockResolvedValue(task)
    const invokeAgentSpy = vi
      .spyOn(mockContext.toolHandler, 'invokeAgent')
      .mockResolvedValueOnce({ output: { plan }, messages: [] }) // For createPlan
      .mockResolvedValueOnce({ output: {}, messages: [] }) // For execute

    vi.spyOn(mockContext.toolHandler, 'select').mockResolvedValue('execute')

    await planWorkflow({ task }, mockContext)

    expect(mockContext.toolHandler.select).toHaveBeenCalled()
    expect(invokeAgentSpy).toHaveBeenCalledTimes(2)
    const executeCall = invokeAgentSpy.mock.calls[1][0]
    expect(executeCall.agent).toBe('coder')
    expect(executeCall.messages[0]).toContain(plan)
  })
})
