// generated by polka.codes
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { dirname } from 'node:path'
import { confirm, select } from '@inquirer/prompts'
import { type Config, getGlobalConfigPath, loadConfigAtPath, localConfigFileName } from '@polka-codes/cli-shared'
import type { Workflow } from '@polka-codes/workflow'
import { set } from 'lodash'
import { parse, stringify } from 'yaml'
import { ZodError, z } from 'zod'
import type { ProviderConfig } from '../configPrompt'
import { configPrompt } from '../configPrompt'
import type { AiProvider } from '../getModel'
import { parseOptions } from '../options'
import type { InvokeAgentTool } from '../workflow-tools'

type InitWorkflowInput = {
  global?: boolean
  parentOptions?: Record<string, any>
}

type InitWorkflowOutput = {
  configPath: string
}

type InitWorkflowTools = {
  invokeAgent: InvokeAgentTool
}

const analyzePrompt = `
Role: Analyzer agent
Goal: Produce a valid polkacodes YAML configuration for the project.

Workflow
1. Scan project files to identify the project's characteristics. Start using the "readFile" tool to understand the project's dependencies, scripts, and basic configuration.
   - Package/build tool (npm, bun, pnpm, etc.)
   - Test framework and patterns (snapshot tests, coverage, etc.)
   - Formatter / linter and their rules
   - Folder structure and naming conventions.
   - CI / development workflows (e.g., GitHub Actions in .github/workflows).

2. Build a YAML config with three root keys:

\`\`\`yaml
scripts:          # derive from package.json and CI workflows. Only include scripts that are relevant for development.
  format:        # code formatter
    command: "<formatter cmd>"
    description: "Format code"
  check:         # linter / type checker
    command: "<linter cmd>"
    description: "Static checks"
  test:          # test runner
    command: "<test cmd>"
    description: "Run tests"
  # add any other meaningful project scripts like 'build', 'dev', etc.

rules:            # A bullet list of key conventions, frameworks, and libraries used (e.g., "- React", "- TypeScript", "- Jest"). This helps other agents understand the project.

excludeFiles:     # A list of glob patterns for files that should not be read. Only include files that might contain secrets.
  - ".env"
  - ".env.*"
  - "*.pem"
  - "*.key"
  - ".npmrc"
  # do NOT list build artifacts, lockfiles, or paths already in .gitignore
\`\`\`

3. Return a JSON object with the generated YAML configuration as a string in the 'yaml' property.

\`\`\`json
{
  "yaml": "<yaml_string>"
}
\`\`\`
`

export const initWorkflow: Workflow<InitWorkflowInput, InitWorkflowOutput, InitWorkflowTools> = {
  name: 'Initialize polkacodes',
  description: 'Initialize polkacodes configuration.',
  async *fn(input, step, tools) {
    const { global, configPath, existingConfig } = await step('setup', async () => {
      const globalConfigPath = getGlobalConfigPath()
      let global = input.global ?? false
      let configPath = global ? globalConfigPath : localConfigFileName

      if (existsSync(configPath)) {
        const proceed = await confirm({
          message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
          default: false,
        })
        if (!proceed) {
          throw new Error('User cancelled')
        }
      } else if (!input.global) {
        const isGlobal = await select({
          message: 'No config file found. Do you want to create one?',
          choices: [
            { name: `Create a global config at ${globalConfigPath}`, value: true },
            { name: `Create a local config at ${configPath}`, value: false },
          ],
        })
        if (isGlobal) {
          global = true
          configPath = globalConfigPath
        }
      }

      console.log(`Config file path: ${configPath}`)

      let existingConfig: Config = {}
      try {
        existingConfig = loadConfigAtPath(configPath) ?? {}
      } catch (error) {
        if (error instanceof ZodError) {
          console.error(`Unable to parse config file: ${configPath}`, error)
          process.exit(1)
        }
      }
      return { global, configPath, existingConfig }
    })

    const { providerConfig, provider } = await step('get-provider', async () => {
      const { providerConfig: optionsProviderConfig } = parseOptions(input.parentOptions ?? {})
      const commandConfig = optionsProviderConfig.getConfigForCommand('init')
      let maybeProvider: AiProvider | undefined = commandConfig?.provider
      let model: string | undefined = commandConfig?.model
      let apiKey: string | undefined = commandConfig?.apiKey
      let newConfig: ProviderConfig | undefined

      if (!maybeProvider) {
        newConfig = await configPrompt({})
        maybeProvider = newConfig.provider
        model = newConfig.model
        apiKey = newConfig.apiKey
      }
      const provider = maybeProvider as AiProvider
      return { providerConfig: newConfig, provider, model, apiKey }
    })

    await step('handle-api-key', async () => {
      if (providerConfig?.apiKey && !global) {
        const option = await select({
          message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
          choices: [
            { name: 'Save API key in the local config file', value: 1 },
            { name: 'Save API key in the global config file', value: 2 },
            { name: 'Save API key to .env file', value: 3 },
          ],
        })

        switch (option) {
          case 1:
            break
          case 2: {
            const globalConfigPath = getGlobalConfigPath()
            const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
            set(globalConfig, ['providers', provider, 'apiKey'], providerConfig.apiKey)
            mkdirSync(dirname(globalConfigPath), { recursive: true })
            writeFileSync(globalConfigPath, stringify(globalConfig))
            console.log(`API key saved to global config file: ${globalConfigPath}`)
            providerConfig.apiKey = undefined
            break
          }
          case 3: {
            let envFileContent: string
            if (existsSync('.env')) {
              envFileContent = readFileSync('.env', 'utf8')
              envFileContent += `\n${provider.toUpperCase()}_API_KEY=${providerConfig.apiKey}`
            } else {
              envFileContent = `${provider.toUpperCase()}_API_KEY=${providerConfig.apiKey}`
            }
            writeFileSync('.env', envFileContent)
            console.log('API key saved to .env file')
            providerConfig.apiKey = undefined
            break
          }
        }
      }
      return {}
    })

    const { shouldAnalyze } = await step('confirm-analyze', async () => {
      const shouldAnalyze =
        !global &&
        (await confirm({
          message: 'Would you like to analyze the project to generate recommended configuration?',
          default: true,
        }))
      return { shouldAnalyze }
    })

    let generatedConfig = {}
    if (shouldAnalyze) {
      console.log('Analyzing project files...')
      const response = yield* tools.invokeAgent({
        agent: 'analyzer',
        messages: [analyzePrompt],
        outputSchema: z.object({ yaml: z.string() }),
      })
      generatedConfig = response ? parse((response.output as { yaml: string }).yaml) : {}
    }

    await step('save-config', async () => {
      const finalConfig: Config = {
        ...(existingConfig ?? {}),
        ...generatedConfig,
      }

      if (providerConfig) {
        finalConfig.defaultProvider = providerConfig.provider
        finalConfig.defaultModel = providerConfig.model
        if (providerConfig.apiKey) {
          set(finalConfig, ['providers', providerConfig.provider, 'apiKey'], providerConfig.apiKey)
        }
      }

      mkdirSync(dirname(configPath), { recursive: true })
      writeFileSync(configPath, stringify(finalConfig))
      console.log(`Configuration saved to ${configPath}`)
      return {}
    })

    return { configPath }
  },
}
