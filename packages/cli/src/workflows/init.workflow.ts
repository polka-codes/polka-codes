// generated by polka.codes
import { existsSync, readFileSync } from 'node:fs'
import { type Config, getGlobalConfigPath, loadConfigAtPath, localConfigFileName } from '@polka-codes/cli-shared'
import { listFiles, readFile, searchFiles } from '@polka-codes/core'
import { agentWorkflow, type WorkflowFn } from '@polka-codes/workflow'
import { set } from 'lodash-es'
import { parse, stringify } from 'yaml'
import { ZodError, z } from 'zod'
import type { ProviderConfig } from '../configPrompt'
import { configPrompt } from '../configPrompt'
import { UserCancelledError } from '../errors'
import type { AiProvider } from '../getModel'
import { parseOptions } from '../options'
import type { CliToolRegistry } from '../workflow-tools'
import { INIT_WORKFLOW_ANALYZE_SYSTEM_PROMPT } from './prompts'

type InitWorkflowInput = {
  global?: boolean
  parentOptions?: Record<string, any>
}

type InitWorkflowOutput = {
  configPath: string
}

export const initWorkflow: WorkflowFn<InitWorkflowInput, InitWorkflowOutput, CliToolRegistry> = async (input, context) => {
  const { step, logger, tools } = context
  const { global, configPath, existingConfig } = await step('setup', async () => {
    const globalConfigPath = getGlobalConfigPath()
    let global = input.global ?? false
    let configPath = global ? globalConfigPath : localConfigFileName

    const exists = existsSync(configPath)

    if (exists) {
      const proceed = await tools.confirm({
        message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
        default: false,
      })
      if (!proceed) {
        throw new UserCancelledError('User cancelled')
      }
    } else if (!input.global) {
      const isGlobal = await tools.select({
        message: 'No config file found. Do you want to create one?',
        choices: [
          { name: `Create a global config at ${globalConfigPath}`, value: 'global' },
          { name: `Create a local config at ${configPath}`, value: 'local' },
        ],
      })
      if (isGlobal === 'global') {
        global = true
        configPath = globalConfigPath
      }
    }

    logger.info(`Config file path: ${configPath}`)

    let existingConfig: Config = {}
    try {
      existingConfig = loadConfigAtPath(configPath) ?? {}
    } catch (error) {
      if (error instanceof ZodError) {
        logger.error(`Unable to parse config file: ${configPath}`, error)
        process.exit(1)
      }
    }
    return { global, configPath, existingConfig }
  })

  const { providerConfig, provider } = await step('get-provider', async () => {
    const { providerConfig: optionsProviderConfig } = parseOptions(input.parentOptions ?? {})
    const commandConfig = optionsProviderConfig.getConfigForCommand('init')
    let maybeProvider: AiProvider | undefined = commandConfig?.provider
    let model: string | undefined = commandConfig?.model
    let apiKey: string | undefined = commandConfig?.apiKey
    let newConfig: ProviderConfig | undefined

    if (!maybeProvider) {
      newConfig = await configPrompt({})
      maybeProvider = newConfig.provider
      model = newConfig.model
      apiKey = newConfig.apiKey
    }
    const provider = maybeProvider as AiProvider
    return { providerConfig: newConfig, provider, model, apiKey }
  })

  await step('handle-api-key', async () => {
    if (providerConfig?.apiKey && !global) {
      const option = await tools.select({
        message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
        choices: [
          { name: 'Save API key in the local config file', value: 'local' },
          { name: 'Save API key in the global config file', value: 'global' },
          { name: 'Save API key to .env file', value: 'env' },
        ],
      })

      switch (option) {
        case 'local':
          break
        case 'global': {
          const globalConfigPath = getGlobalConfigPath()
          const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
          set(globalConfig, ['providers', provider, 'apiKey'], providerConfig.apiKey)
          await tools.writeToFile({ path: globalConfigPath, content: stringify(globalConfig) })
          logger.info(`API key saved to global config file: ${globalConfigPath}`)
          if (providerConfig) {
            providerConfig.apiKey = undefined
          }
          break
        }
        case 'env': {
          let envFileContent: string
          const envExists = existsSync('.env')
          if (envExists) {
            envFileContent = readFileSync('.env', 'utf-8')
            envFileContent += `\n${provider.toUpperCase()}_API_KEY=${providerConfig.apiKey}`
          } else {
            envFileContent = `${provider.toUpperCase()}_API_KEY=${providerConfig.apiKey}`
          }
          await tools.writeToFile({ path: '.env', content: envFileContent })
          logger.info('API key saved to .env file')
          if (providerConfig) {
            providerConfig.apiKey = undefined
          }
          break
        }
      }
    }
  })

  const { shouldAnalyze } = await step('confirm-analyze', async () => {
    let shouldAnalyze = false
    if (!global) {
      shouldAnalyze = await tools.confirm({
        message: 'Would you like to analyze the project to generate recommended configuration?',
        default: false,
      })
    }
    return { shouldAnalyze }
  })

  let generatedConfig: any = {}
  if (shouldAnalyze) {
    const result = await step('analyze-project', async () => {
      logger.info('Analyzing project files...')

      return await agentWorkflow(
        {
          systemPrompt: INIT_WORKFLOW_ANALYZE_SYSTEM_PROMPT,
          userMessage: [
            {
              role: 'user',
              content: 'Please provide a valid polkacodes YAML configuration for the project.',
            },
          ],
          tools: [readFile, listFiles, searchFiles],
          outputSchema: z.object({ yaml: z.string() }),
        },
        { logger, tools, step },
      )
    })

    if (result.type === 'Exit' && result.object) {
      const yamlConfig = result.object.yaml
      generatedConfig = yamlConfig ? parse(yamlConfig) : {}
    }
  }

  await step('save-config', async () => {
    const finalConfig: Config = {
      ...(existingConfig ?? {}),
      ...generatedConfig,
    }

    if (providerConfig) {
      finalConfig.defaultProvider = providerConfig.provider
      finalConfig.defaultModel = providerConfig.model
      if (providerConfig.apiKey) {
        set(finalConfig, ['providers', providerConfig.provider, 'apiKey'], providerConfig.apiKey)
      }
    }

    await tools.writeToFile({ path: configPath, content: stringify(finalConfig) })
    logger.info(`Configuration saved to ${configPath}`)
  })

  return { configPath }
}
