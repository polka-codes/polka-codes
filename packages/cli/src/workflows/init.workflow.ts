// generated by polka.codes
import { existsSync, readFileSync } from 'node:fs'
import { type Config, getGlobalConfigPath, loadConfigAtPath, localConfigFileName } from '@polka-codes/cli-shared'
import type { Workflow } from '@polka-codes/workflow'
import { set } from 'lodash-es'
import { parse, stringify } from 'yaml'
import { ZodError, z } from 'zod'
import type { ProviderConfig } from '../configPrompt'
import { configPrompt } from '../configPrompt'
import type { AiProvider } from '../getModel'
import { parseOptions } from '../options'
import type { CliToolRegistry } from '../workflow-tools'
import { INIT_WORKFLOW_ANALYZE_PROMPT } from './prompts'

type InitWorkflowInput = {
  global?: boolean
  parentOptions?: Record<string, any>
}

type InitWorkflowOutput = {
  configPath: string
}

export const initWorkflow: Workflow<InitWorkflowInput, InitWorkflowOutput, CliToolRegistry> = {
  name: 'Initialize polkacodes',
  description: 'Initialize polkacodes configuration.',
  async *fn(input, step, tools) {
    const { global, configPath, existingConfig } = yield* step('setup', async function* () {
      const globalConfigPath = getGlobalConfigPath()
      let global = input.global ?? false
      let configPath = global ? globalConfigPath : localConfigFileName

      const exists = existsSync(configPath)

      if (exists) {
        const proceed = yield* tools.confirm({
          message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
          default: false,
        })
        if (!proceed) {
          throw new Error('User cancelled')
        }
      } else if (!input.global) {
        const isGlobal = yield* tools.select({
          message: 'No config file found. Do you want to create one?',
          choices: [
            { name: `Create a global config at ${globalConfigPath}`, value: 'global' },
            { name: `Create a local config at ${configPath}`, value: 'local' },
          ],
        })
        if (isGlobal === 'global') {
          global = true
          configPath = globalConfigPath
        }
      }

      console.log(`Config file path: ${configPath}`)

      let existingConfig: Config = {}
      try {
        existingConfig = loadConfigAtPath(configPath) ?? {}
      } catch (error) {
        if (error instanceof ZodError) {
          console.error(`Unable to parse config file: ${configPath}`, error)
          process.exit(1)
        }
      }
      return { global, configPath, existingConfig }
    })

    const { providerConfig, provider } = yield* step('get-provider', async function* () {
      const { providerConfig: optionsProviderConfig } = parseOptions(input.parentOptions ?? {})
      const commandConfig = optionsProviderConfig.getConfigForCommand('init')
      let maybeProvider: AiProvider | undefined = commandConfig?.provider
      let model: string | undefined = commandConfig?.model
      let apiKey: string | undefined = commandConfig?.apiKey
      let newConfig: ProviderConfig | undefined

      if (!maybeProvider) {
        newConfig = await configPrompt({})
        maybeProvider = newConfig.provider
        model = newConfig.model
        apiKey = newConfig.apiKey
      }
      const provider = maybeProvider as AiProvider
      return { providerConfig: newConfig, provider, model, apiKey }
    })

    yield* step('handle-api-key', async function* () {
      if (providerConfig?.apiKey && !global) {
        const option = yield* tools.select({
          message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
          choices: [
            { name: 'Save API key in the local config file', value: 'local' },
            { name: 'Save API key in the global config file', value: 'global' },
            { name: 'Save API key to .env file', value: 'env' },
          ],
        })

        switch (option) {
          case 'local':
            break
          case 'global': {
            const globalConfigPath = getGlobalConfigPath()
            const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
            set(globalConfig, ['providers', provider, 'apiKey'], providerConfig.apiKey)
            yield* tools.writeToFile({ path: globalConfigPath, content: stringify(globalConfig) })
            console.log(`API key saved to global config file: ${globalConfigPath}`)
            providerConfig.apiKey = undefined
            break
          }
          case 'env': {
            let envFileContent: string
            const envExists = existsSync('.env')
            if (envExists) {
              envFileContent = readFileSync('.env', 'utf-8')
              envFileContent += `\n${provider.toUpperCase()}_API_KEY=${providerConfig.apiKey}`
            } else {
              envFileContent = `${provider.toUpperCase()}_API_KEY=${providerConfig.apiKey}`
            }
            yield* tools.writeToFile({ path: '.env', content: envFileContent })
            console.log('API key saved to .env file')
            providerConfig.apiKey = undefined
            break
          }
        }
      }
      return {}
    })

    const { shouldAnalyze } = yield* step('confirm-analyze', async function* () {
      let shouldAnalyze = false
      if (!global) {
        shouldAnalyze = yield* tools.confirm({
          message: 'Would you like to analyze the project to generate recommended configuration?',
          default: false,
        })
      }
      return { shouldAnalyze }
    })

    let generatedConfig = {}
    if (shouldAnalyze) {
      console.log('Analyzing project files...')
      const { output: response } = yield* tools.invokeAgent({
        agent: 'analyzer',
        messages: [INIT_WORKFLOW_ANALYZE_PROMPT],
        outputSchema: z.object({ yaml: z.string() }),
        defaultContext: true,
      })
      generatedConfig = response ? parse((response as { yaml: string }).yaml) : {}
    }

    yield* step('save-config', async function* () {
      const finalConfig: Config = {
        ...(existingConfig ?? {}),
        ...generatedConfig,
      }

      if (providerConfig) {
        finalConfig.defaultProvider = providerConfig.provider
        finalConfig.defaultModel = providerConfig.model
        if (providerConfig.apiKey) {
          set(finalConfig, ['providers', providerConfig.provider, 'apiKey'], providerConfig.apiKey)
        }
      }

      yield* tools.writeToFile({ path: configPath, content: stringify(finalConfig) })
      console.log(`Configuration saved to ${configPath}`)
      return {}
    })

    return { configPath }
  },
}
