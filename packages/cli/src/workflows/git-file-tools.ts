// generated by polka.codes

import type { FullToolInfo, ToolHandler, ToolInfo } from '@polka-codes/core'
import type { CommandProvider } from '@polka-codes/core/src/tools/provider'
import { z } from 'zod'
import { quoteForShell } from '../utils/shell'

/**
 * Helper to extract the target commit from a git range
 * For ranges like "A..B", "A...B", or "HEAD~3..HEAD", returns B
 * For single commit, returns the commit
 * For local changes, returns null
 */
export function extractTargetCommit(range?: string, pr?: number): string | null {
  // PR reviews checkout the branch, so working directory is correct
  if (pr) {
    return null
  }

  // No range means local changes, use working directory
  if (!range) {
    return null
  }

  // Parse the range to extract the target commit
  // Supports formats: "A..B", "A...B", "commit", "HEAD~3", etc.
  const parts = range.split(/\.\.\.?/)
  if (parts.length > 1) {
    // Range format: "A..B" or "A...B"
    // The second part is the target commit (B)
    return parts[1].trim() || null
  }

  // Single commit reference
  return range.trim() || null
}

/**
 * Create git-aware version of readFile that reads from a specific commit
 */
export function createGitReadFile(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'readFile',
    description: `Read file contents from git commit ${commit}. Use this to examine files at the specific commit being reviewed.`,
    parameters: z
      .object({
        path: z
          .preprocess((val) => {
            if (!val) return []
            const values = Array.isArray(val) ? val : [val]
            // NOTE: Comma-splitting matches standard readFile tool behavior
            // This prevents reading files with commas in their names, but allows
            // reading multiple files in a single call (e.g., "file1.ts,file2.ts")
            return values.flatMap((i) => (typeof i === 'string' ? i.split(',') : [])).filter((s) => s.length > 0)
          }, z.array(z.string()))
          .describe('The path of the file to read (relative to git root)')
          .meta({ usageValue: 'Comma separated paths here' }),
      })
      .meta({
        examples: [
          {
            description: 'Read the contents of a file at the commit',
            input: {
              path: 'src/main.ts',
            },
          },
        ],
      }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    const { path: paths } = toolInfo.parameters.parse(args)

    const results: string[] = []
    for (const filePath of paths) {
      // SECURITY: Use quoteForShell to prevent command injection
      // Both commit and filePath could contain shell metacharacters
      const quotedCommit = quoteForShell(commit)
      const quotedPath = quoteForShell(filePath)
      const result = await provider.executeCommand(`git show ${quotedCommit}:${quotedPath}`, false)

      if (result.exitCode === 0) {
        results.push(`<read_file_file_content path="${filePath}">${result.stdout}</read_file_file_content>`)
      } else {
        // File not found or doesn't exist at this commit
        results.push(`<read_file_file_content path="${filePath}" file_not_found="true"></read_file_file_content>`)
      }
    }

    return {
      success: true,
      message: {
        type: 'text',
        value: results.join('\n'),
      },
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}

/**
 * Create git-aware version of listFiles that lists files at a specific commit
 */
export function createGitListFiles(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'listFiles',
    description: `List files and directories at git commit ${commit}. Shows the file tree as it existed at that commit.`,
    parameters: z.object({
      path: z
        .string()
        .optional()
        .describe('The path of the directory to list (relative to git root). Default is root.')
        .meta({ usageValue: 'Directory path here (optional)' }),
      maxCount: z.coerce
        .number()
        .optional()
        .default(2000)
        .describe('The maximum number of files to list. Default to 2000')
        .meta({ usageValue: 'Maximum number of files to list (optional)' }),
    }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    // Parse with fallback for empty string to '.'
    const parsed = toolInfo.parameters.parse(args)
    const path = parsed.path || '.'

    // SECURITY: Use quoteForShell to prevent command injection
    const quotedCommit = quoteForShell(commit)
    const quotedPath = quoteForShell(path)
    // Use git ls-tree to list files at the specific commit
    const result = await provider.executeCommand(`git ls-tree -r --name-only ${quotedCommit} ${quotedPath}`, false)

    if (result.exitCode !== 0) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: `Failed to list files at commit ${commit}: ${result.stderr}`,
        },
      }
    }

    const files = result.stdout
      .trim()
      .split('\n')
      .filter((f) => f.length > 0)

    const truncated = files.length > parsed.maxCount
    const displayFiles = truncated ? files.slice(0, parsed.maxCount) : files

    return {
      success: true,
      message: {
        type: 'text',
        value: `<list_files_path>${path}</list_files_path>
<list_files_files>
${displayFiles.join('\n')}
</list_files_files>
<list_files_truncated>${truncated}</list_files_truncated>`,
      },
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}

/**
 * Create git-aware version of readBinaryFile that reads binary files at a specific commit
 */
export function createGitReadBinaryFile(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'readBinaryFile',
    description: `Read binary file contents from git commit ${commit} and return as base64 encoded data. Use for images, fonts, and other binary files.`,
    parameters: z.object({
      url: z.string().describe('The path of the binary file to read (relative to git root)'),
    }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    const { url } = toolInfo.parameters.parse(args)

    // SECURITY: Use quoteForShell to prevent command injection
    const quotedCommit = quoteForShell(commit)
    const quotedUrl = quoteForShell(url)
    // Use git show to read binary file and encode as base64
    const result = await provider.executeCommand(`git show ${quotedCommit}:${quotedUrl} | base64`, false)

    if (result.exitCode === 0) {
      // Return media type for compatibility with multimodal models
      // Match the structure of the standard readBinaryFile tool
      // Remove all newlines from base64 output (base64 may wrap at 76 chars)
      const base64Data = result.stdout.replace(/\n/g, '')
      return {
        success: true,
        message: {
          type: 'content',
          value: [
            {
              type: 'media',
              url,
              data: base64Data,
            },
          ],
        },
      }
    } else {
      return {
        success: true,
        message: {
          type: 'text',
          value: `<read_binary_file_file_content url="${url}" file_not_found="true"></read_binary_file_file_content>`,
        },
      }
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}

/**
 * Create git-aware file tools for reviewing a specific commit
 * Returns wrapped versions of readFile, listFiles, and readBinaryFile
 */
export function createGitAwareTools(commit: string): {
  readFile: FullToolInfo
  listFiles: FullToolInfo
  readBinaryFile: FullToolInfo
} {
  return {
    readFile: createGitReadFile(commit),
    listFiles: createGitListFiles(commit),
    readBinaryFile: createGitReadBinaryFile(commit),
  }
}
