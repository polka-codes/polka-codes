// generated by polka.codes

import type { FullToolInfo, ToolHandler, ToolInfo } from '@polka-codes/core'
import type { CommandProvider } from '@polka-codes/core/src/tools/provider'
import { z } from 'zod'
import { annotateDiffWithLineNumbers } from '../tools/utils/diffLineNumbers'
import { quoteForShell } from '../utils/shell'

function getMediaType(path: string): string {
  // Use lastIndexOf to handle paths with dots, and basename to handle dotfiles correctly
  const lastDotIndex = path.lastIndexOf('.')
  const ext = lastDotIndex > 0 && lastDotIndex < path.length - 1 ? path.slice(lastDotIndex + 1).toLowerCase() : undefined

  const mediaTypes: Record<string, string> = {
    // Images
    png: 'image/png',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    gif: 'image/gif',
    svg: 'image/svg+xml',
    webp: 'image/webp',
    ico: 'image/x-icon',
    bmp: 'image/bmp',

    // Fonts
    woff: 'font/woff',
    woff2: 'font/woff2',
    ttf: 'font/ttf',
    otf: 'font/otf',
    eot: 'application/vnd.ms-fontobject',

    // Documents
    pdf: 'application/pdf',

    // Audio
    mp3: 'audio/mpeg',
    wav: 'audio/wav',
    ogg: 'audio/ogg',

    // Video
    mp4: 'video/mp4',
    webm: 'video/webm',
    avi: 'video/x-msvideo',
  }

  return mediaTypes[ext || ''] || 'application/octet-stream'
}

/**
 * Helper to extract the target commit from a git range
 * For ranges like "A..B", "A...B", or "HEAD~3..HEAD", returns B
 * For single commit, returns the commit
 * For local changes, returns null
 */
export function extractTargetCommit(range?: string, pr?: number): string | null {
  // PR reviews checkout the branch, so working directory is correct
  if (pr) {
    return null
  }

  // No range or empty range means local changes, use working directory
  if (!range || range.trim() === '') {
    return null
  }

  // Parse the range to extract the target commit
  // Supports formats: "A..B", "A...B", "commit", "HEAD~3", etc.
  const parts = range.split(/\.\.\.?/)
  if (parts.length > 1) {
    // Range format: "A..B" or "A...B"
    // The second part is the target commit (B)
    return parts[1].trim() || null
  }

  // Single commit reference
  const trimmed = range.trim()
  return trimmed || null
}

/**
 * Create git-aware version of readFile that reads from a specific commit
 */
export function createGitReadFile(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'readFile',
    description: `Read file contents from git commit ${commit}. Use this to examine files at the specific commit being reviewed.`,
    parameters: z
      .object({
        path: z
          .preprocess((val) => {
            if (!val) return []
            const values = Array.isArray(val) ? val : [val]
            // NOTE: Comma-splitting matches standard readFile tool behavior
            // This prevents reading files with commas in their names, but allows
            // reading multiple files in a single call (e.g., "file1.ts,file2.ts")
            return values.flatMap((i) => (typeof i === 'string' ? i.split(',') : [])).filter((s) => s.length > 0)
          }, z.array(z.string()))
          .describe('The path of the file to read (relative to git root)')
          .meta({ usageValue: 'Comma separated paths here' }),
      })
      .meta({
        examples: [
          {
            description: 'Read the contents of a file at the commit',
            input: {
              path: 'src/main.ts',
            },
          },
        ],
      }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    const { path: paths } = toolInfo.parameters.parse(args)

    const results: string[] = []
    for (const filePath of paths) {
      // SECURITY: Use quoteForShell to prevent command injection
      // Both commit and filePath could contain shell metacharacters
      const quotedCommit = quoteForShell(commit)
      const quotedPath = quoteForShell(filePath)
      const result = await provider.executeCommand(`git show ${quotedCommit}:${quotedPath}`, false)

      if (result.exitCode === 0) {
        results.push(`<read_file_file_content path="${filePath}">${result.stdout}</read_file_file_content>`)
      } else {
        // File not found or doesn't exist at this commit
        results.push(`<read_file_file_content path="${filePath}" file_not_found="true"></read_file_file_content>`)
      }
    }

    return {
      success: true,
      message: {
        type: 'text',
        value: results.join('\n'),
      },
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}

/**
 * Create git-aware version of listFiles that lists files at a specific commit
 */
export function createGitListFiles(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'listFiles',
    description: `List files and directories at git commit ${commit}. Shows the file tree as it existed at that commit.`,
    parameters: z.object({
      path: z
        .string()
        .optional()
        .describe('The path of the directory to list (relative to git root). Default is root.')
        .meta({ usageValue: 'Directory path here (optional)' }),
      maxCount: z.coerce
        .number()
        .optional()
        .default(2000)
        .describe('The maximum number of files to list. Default to 2000')
        .meta({ usageValue: 'Maximum number of files to list (optional)' }),
    }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    // Parse with fallback for empty string to '.'
    const parsed = toolInfo.parameters.parse(args)
    const path = parsed.path || '.'

    // SECURITY: Use quoteForShell to prevent command injection
    const quotedCommit = quoteForShell(commit)
    const quotedPath = quoteForShell(path)
    // Use git ls-tree to list files at the specific commit
    const result = await provider.executeCommand(`git ls-tree -r --name-only ${quotedCommit} ${quotedPath}`, false)

    if (result.exitCode !== 0) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: `Failed to list files at commit ${commit}: ${result.stderr}`,
        },
      }
    }

    const files = result.stdout
      .trim()
      .split('\n')
      .filter((f) => f.length > 0)

    const truncated = files.length > parsed.maxCount
    const displayFiles = truncated ? files.slice(0, parsed.maxCount) : files

    return {
      success: true,
      message: {
        type: 'text',
        value: `<list_files_path>${path}</list_files_path>
<list_files_files>
${displayFiles.join('\n')}
</list_files_files>
<list_files_truncated>${truncated}</list_files_truncated>`,
      },
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}

/**
 * Create git-aware version of readBinaryFile that reads binary files at a specific commit
 */
export function createGitReadBinaryFile(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'readBinaryFile',
    description: `Read binary file contents from git commit ${commit} and return as base64 encoded data. Use for images, fonts, and other binary files.`,
    parameters: z.object({
      url: z.string().describe('The URL or path of the binary file to read (relative to git root)'),
    }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    const { url } = toolInfo.parameters.parse(args)

    // SECURITY: Use quoteForShell to prevent command injection
    const quotedCommit = quoteForShell(commit)
    const quotedUrl = quoteForShell(url)

    // First verify the file exists at the commit to avoid pipe masking errors
    const checkResult = await provider.executeCommand(`git cat-file -e ${quotedCommit}:${quotedUrl}`, false)
    if (checkResult.exitCode !== 0) {
      return {
        success: true,
        message: {
          type: 'text',
          value: `<read_binary_file_file_content url="${url}" file_not_found="true"></read_binary_file_file_content>`,
        },
      }
    }

    // File exists, read it and encode as base64
    // Use git show piped to base64 for cross-platform binary file handling
    // Windows: requires Git Bash or Unix tools in PATH (base64 command)
    // Unix: always available
    // Note: On Windows without Git Bash, this will fail with a clear error
    const isWindows = process.platform === 'win32'
    const command = isWindows
      ? `cmd /c "git show ${quotedCommit}:${quotedUrl} | base64 -w 0 2>&1"`
      : `sh -c "git show ${quotedCommit}:${quotedUrl} | base64 2>&1"`

    const result = await provider.executeCommand(command, false)

    if (result.exitCode === 0) {
      // The output is base64-encoded text, remove any newlines for consistent output
      // Unix base64 wraps at 76 chars by default, Windows with -w 0 doesn't wrap
      const base64Data = result.stdout.replace(/\n/g, '')
      return {
        success: true,
        message: {
          type: 'content',
          value: [
            {
              type: 'media',
              url,
              data: base64Data,
              mediaType: getMediaType(url),
            },
          ],
        },
      }
    } else {
      // Provide helpful error message if base64 command is not available
      const isBase64Error =
        result.stderr.includes('not recognized') || result.stderr.includes('command not found') || result.stderr.includes('base64')

      const errorMessage = isBase64Error
        ? `Failed to read binary file: base64 command not found. On Windows, ensure Git Bash or Unix tools are installed and in PATH.`
        : `Failed to read binary file: ${result.stderr}`

      return {
        success: false,
        message: {
          type: 'error-text',
          value: errorMessage,
        },
      }
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}

/**
 * Create git-aware file tools for reviewing a specific commit
 * Returns wrapped versions of readFile, listFiles, and readBinaryFile
 */
export function createGitAwareTools(commit: string): {
  readFile: FullToolInfo
  listFiles: FullToolInfo
  readBinaryFile: FullToolInfo
} {
  return {
    readFile: createGitReadFile(commit),
    listFiles: createGitListFiles(commit),
    readBinaryFile: createGitReadBinaryFile(commit),
  }
}

/**
 * Create git-aware version of gitDiff that shows changes introduced by a specific commit
 * Uses `git show <commit>` to display the diff for that commit
 */
export function createGitAwareDiff(commit: string): FullToolInfo {
  const toolInfo = {
    name: 'git_diff',
    description: `Get the git diff for commit ${commit}. Shows the exact changes introduced by this specific commit. Use this to inspect what changed in each file. Always specify a file path.`,
    parameters: z.object({
      file: z
        .string()
        .describe('Get the diff for a specific file within the commit. This parameter is required.')
        .meta({ usageValue: 'File path here (required)' }),
      contextLines: z.coerce
        .number()
        .int()
        .min(0)
        .optional()
        .default(5)
        .describe('Number of context lines to include around changes.')
        .meta({ usageValue: 'Context lines count (optional)' }),
      includeLineNumbers: z
        .preprocess((val) => {
          if (typeof val === 'string') {
            const lower = val.toLowerCase()
            if (lower === 'false') return false
            if (lower === 'true') return true
          }
          return val
        }, z.boolean().optional().default(true))
        .describe('Annotate the diff with line numbers for additions and deletions.')
        .meta({ usageValue: 'true or false (optional)' }),
    }),
  } as const satisfies ToolInfo

  const handler: ToolHandler<typeof toolInfo, CommandProvider> = async (provider, args) => {
    if (!provider.executeCommand) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: 'Not possible to execute command.',
        },
      }
    }

    const { file, contextLines, includeLineNumbers } = toolInfo.parameters.parse(args)

    // SECURITY: Use quoteForShell to prevent command injection
    const quotedCommit = quoteForShell(commit)

    // Build git show command to display commit diff
    // Use --no-color and -U for context lines
    let command = `git show --no-color --format= -U${contextLines} ${quotedCommit}`

    // If a specific file is requested, filter the output
    if (file) {
      const quotedFile = quoteForShell(file)
      command = `git show --no-color --format= -U${contextLines} ${quotedCommit} -- ${quotedFile}`
    }

    try {
      const result = await provider.executeCommand(command, false)

      if (result.exitCode === 0) {
        if (!result.stdout.trim()) {
          return {
            success: true,
            message: {
              type: 'text',
              value: 'No diff found.',
            },
          }
        }

        let diffOutput = result.stdout
        if (includeLineNumbers) {
          diffOutput = annotateDiffWithLineNumbers(diffOutput)
        }

        return {
          success: true,
          message: {
            type: 'text',
            value: `<diff file="${file ?? 'all'}">\n${diffOutput}\n</diff>`,
          },
        }
      }

      return {
        success: false,
        message: {
          type: 'error-text',
          value: `\`${command}\` exited with code ${result.exitCode}:\n${result.stderr}`,
        },
      }
    } catch (error) {
      return {
        success: false,
        message: {
          type: 'error-text',
          value: error instanceof Error ? error.message : String(error),
        },
      }
    }
  }

  return {
    ...toolInfo,
    handler,
  } satisfies FullToolInfo
}
