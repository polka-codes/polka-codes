// generated by polka.codes

import { afterEach, describe, expect, mock, test } from 'bun:test'
import type { WorkflowContext } from '@polka-codes/workflow'
import { UserCancelledError } from '../errors'
import type { CliToolRegistry } from '../workflow-tools'
import { commitWorkflow } from './commit.workflow'

const createMockContext = () => {
  const tools = {
    printChangeFile: mock<any>(),
    executeCommand: mock<any>(),
    confirm: mock<any>(),
    createCommit: mock<any>(),
    invokeAgent: mock<any>(),
    createPullRequest: mock<any>(),
    generateText: mock<any>(),
    taskEvent: mock<any>(),
    invokeTool: mock<any>(),
    readFile: mock<any>(),
    writeToFile: mock<any>(),
    select: mock<any>(),
    input: mock<any>(),
  }
  const step = mock(async (_name: string, fn: () => any) => fn())
  const logger = {
    info: mock(() => {}),
    error: mock(() => {}),
    warn: mock(() => {}),
    debug: mock(() => {}),
  }

  const context = {
    tools,
    step,
    logger,
  } as unknown as WorkflowContext<CliToolRegistry>

  return { context, tools, step, logger }
}

describe('commitWorkflow', () => {
  afterEach(() => {
    mock.restore()
  })

  test('should generate commit message with staged files', async () => {
    const { context, tools, logger } = createMockContext()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [{ path: 'src/file.ts', status: 'M' }],
      unstagedFiles: [],
    })
    tools.executeCommand.mockResolvedValueOnce({ exitCode: 0, stdout: 'M\tsrc/file.ts' }).mockResolvedValueOnce({
      exitCode: 0,
      stdout: '--- a/src/file.ts\n+++ b/src/file.ts\n@@ -1,3 +1,4 @@\n+export const newFunc = () => {}\n',
    })
    tools.createCommit.mockResolvedValue({})
    tools.generateText.mockResolvedValue([
      {
        role: 'assistant',
        content: JSON.stringify({ commitMessage: 'feat: add newFunc' }),
      },
    ])

    await commitWorkflow({}, context)

    expect(tools.printChangeFile).toHaveBeenCalled()
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['diff', '--name-status', '--no-color', '--staged'],
    })
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['diff', '--staged'],
    })
    expect(tools.generateText).toHaveBeenCalled()
    expect(logger.info).toHaveBeenCalledWith('\nCommit message:\nfeat: add newFunc')
    expect(tools.createCommit).toHaveBeenCalledWith({
      message: 'feat: add newFunc',
    })
  })

  test('should auto-stage all files when all=true', async () => {
    const { context, tools } = createMockContext()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [],
      unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    })
    tools.executeCommand.mockResolvedValue({ exitCode: 0, stdout: 'M\tsrc/file.ts' })
    tools.generateText.mockResolvedValue([
      {
        role: 'assistant',
        content: JSON.stringify({ commitMessage: 'feat: stage file' }),
      },
    ])

    await commitWorkflow({ all: true }, context)

    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['add', '.'],
    })
    expect(tools.generateText).toHaveBeenCalled()
    expect(tools.createCommit).toHaveBeenCalledWith({
      message: 'feat: stage file',
    })
  })

  test('should prompt user and stage when confirmed', async () => {
    const { context, tools } = createMockContext()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [],
      unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    })
    tools.confirm.mockResolvedValue(true)
    tools.executeCommand.mockResolvedValue({ exitCode: 0, stdout: 'M\tsrc/file.ts' })
    tools.generateText.mockResolvedValue([
      {
        role: 'assistant',
        content: JSON.stringify({ commitMessage: 'feat: stage file' }),
      },
    ])

    await commitWorkflow({}, context)

    expect(tools.confirm).toHaveBeenCalledWith({
      message: 'No staged files found. Stage all files?',
      default: false,
    })
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['add', '.'],
    })
    expect(tools.generateText).toHaveBeenCalled()
    expect(tools.createCommit).toHaveBeenCalledWith({
      message: 'feat: stage file',
    })
  })

  test('should throw UserCancelledError when user declines staging', async () => {
    const { context, tools } = createMockContext()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [],
      unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    })
    tools.confirm.mockResolvedValue(false)

    await expect(commitWorkflow({}, context)).rejects.toThrow(UserCancelledError)
  })

  test('should throw error when no files to commit', async () => {
    const { context, tools } = createMockContext()

    tools.printChangeFile.mockResolvedValue({ stagedFiles: [], unstagedFiles: [] })

    await expect(commitWorkflow({}, context)).rejects.toThrow('No files to commit. Aborting.')
  })
})
