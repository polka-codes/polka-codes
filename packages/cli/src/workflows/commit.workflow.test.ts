// generated by polka.codes

import { afterEach, describe, expect, mock, test } from 'bun:test'
import { execSync } from 'node:child_process'
import { UserCancelledError } from '../errors'
import { createWorkflowTestContext } from '../test/workflow-fixtures'
import { commitWorkflow } from './commit.workflow'

// Check if git is available synchronously
let gitAvailable = false
try {
  execSync('git --version', { stdio: 'ignore' })
  gitAvailable = true
} catch {
  // Git not available
}

describe.skipIf(!gitAvailable)('commitWorkflow', () => {
  const defaultInput = {
    interactive: false,
    additionalTools: {},
  }

  afterEach(() => {
    mock.restore()
  })

  test('should generate commit message with staged files', async () => {
    const { context, tools, logger } = createWorkflowTestContext()

    // Add commit-specific tools
    tools.printChangeFile = mock<any>()
    tools.createCommit = mock<any>()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [{ path: 'src/file.ts', status: 'M' }],
      unstagedFiles: [],
    })
    tools.executeCommand.mockResolvedValueOnce({ exitCode: 0, stdout: 'M\tsrc/file.ts' }).mockResolvedValueOnce({
      exitCode: 0,
      stdout: '--- a/src/file.ts\n+++ b/src/file.ts\n@@ -1,3 +1,4 @@\n+export const newFunc = () => {}\n',
    })
    tools.createCommit.mockResolvedValue({})
    tools.generateText.mockResolvedValue([
      {
        role: 'assistant',
        content: JSON.stringify({ commitMessage: 'feat: add newFunc' }),
      },
    ])

    const result = await commitWorkflow({ ...defaultInput }, context)

    expect(result).toBe('feat: add newFunc')
    expect(tools.printChangeFile).toHaveBeenCalled()
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['diff', '--name-status', '--no-color', '--staged'],
    })
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['diff', '--staged'],
    })
    expect(tools.generateText).toHaveBeenCalled()
    expect(logger.info).toHaveBeenCalledWith('\nCommit message:\nfeat: add newFunc')
    expect(tools.createCommit).toHaveBeenCalledWith({
      message: 'feat: add newFunc',
    })
  })

  test('should auto-stage all files when all=true', async () => {
    const { context, tools } = createWorkflowTestContext()

    // Add commit-specific tools
    tools.printChangeFile = mock<any>()
    tools.createCommit = mock<any>()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [],
      unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    })
    tools.executeCommand.mockResolvedValue({ exitCode: 0, stdout: 'M\tsrc/file.ts' })
    tools.generateText.mockResolvedValue([
      {
        role: 'assistant',
        content: JSON.stringify({ commitMessage: 'feat: stage file' }),
      },
    ])

    const result = await commitWorkflow({ ...defaultInput, all: true }, context)

    expect(result).toBe('feat: stage file')
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['add', '.'],
    })
    expect(tools.generateText).toHaveBeenCalled()
    expect(tools.createCommit).toHaveBeenCalledWith({
      message: 'feat: stage file',
    })
  })

  test('should prompt user and stage when confirmed', async () => {
    const { context, tools } = createWorkflowTestContext()

    // Add commit-specific tools
    tools.printChangeFile = mock<any>()
    tools.confirm = mock<any>()
    tools.createCommit = mock<any>()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [],
      unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    })
    tools.confirm.mockResolvedValue(true)
    tools.executeCommand.mockResolvedValue({ exitCode: 0, stdout: 'M\tsrc/file.ts' })
    tools.generateText.mockResolvedValue([
      {
        role: 'assistant',
        content: JSON.stringify({ commitMessage: 'feat: stage file' }),
      },
    ])

    const result = await commitWorkflow({ ...defaultInput, interactive: true }, context)

    expect(result).toBe('feat: stage file')
    expect(tools.confirm).toHaveBeenCalledWith({
      message: 'No staged files found. Stage all files?',
      default: false,
    })
    expect(tools.executeCommand).toHaveBeenCalledWith({
      command: 'git',
      args: ['add', '.'],
    })
    expect(tools.generateText).toHaveBeenCalled()
    expect(tools.createCommit).toHaveBeenCalledWith({
      message: 'feat: stage file',
    })
  })

  test('should throw UserCancelledError when user declines staging', async () => {
    const { context, tools } = createWorkflowTestContext()

    // Add commit-specific tools
    tools.printChangeFile = mock<any>()
    tools.confirm = mock<any>()

    tools.printChangeFile.mockResolvedValue({
      stagedFiles: [],
      unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    })
    tools.confirm.mockResolvedValue(false)

    await expect(commitWorkflow({ ...defaultInput, interactive: true }, context)).rejects.toThrow(UserCancelledError)
  })

  test('should throw error when no files to commit', async () => {
    const { context, tools } = createWorkflowTestContext()

    // Add commit-specific tools
    tools.printChangeFile = mock<any>()

    tools.printChangeFile.mockResolvedValue({ stagedFiles: [], unstagedFiles: [] })

    await expect(commitWorkflow({ ...defaultInput }, context)).rejects.toThrow('No files to commit. Aborting.')
  })
})
