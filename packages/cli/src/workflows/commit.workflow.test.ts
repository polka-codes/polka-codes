// generated by polka.codes

import { expect, test } from 'bun:test'
import assert from 'node:assert/strict'
import { run } from '@polka-codes/workflow'
import { UserCancelledError } from '../errors'
import { commitWorkflow } from './commit.workflow'

test('should generate commit message with staged files', async () => {
  const result1 = await run(commitWorkflow, {})
  expect(result1).toMatchSnapshot()
  assert(result1.status === 'pending')

  // Provide staged files
  const result2 = await result1.next({
    stagedFiles: [
      { path: 'src/file.ts', status: 'M' },
      { path: 'src/newfile.ts', status: 'A' },
    ],
    unstagedFiles: [],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  // Provide git diff --name-status output
  const result3 = await result2.next({
    exitCode: 0,
    stdout: 'M\tsrc/file.ts\nA\tsrc/newfile.ts',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  // Provide git diff --staged output
  const result4 = await result3.next({
    exitCode: 0,
    stdout: '--- a/src/file.ts\n+++ b/src/file.ts\n@@ -1,3 +1,4 @@\n+export const newFunc = () => {}\n',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  // Provide agent response
  const result5 = await result4.next({
    output: { commitMessage: 'feat: add new feature\n\nAdded newFunc to file.ts' },
    messages: [],
  })
  expect(result5).toMatchSnapshot()
  assert(result5.status === 'pending')

  // Provide createCommit response
  const result6 = await result5.next({ message: 'feat: add new feature\n\nAdded newFunc to file.ts' })
  expect(result6).toMatchSnapshot()
})

test('should auto-stage all files when all=true', async () => {
  const result1 = await run(commitWorkflow, { all: true })
  assert(result1.status === 'pending')

  // Provide no staged files but some unstaged files
  const result2 = await result1.next({
    stagedFiles: [],
    unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  // Provide git add . response
  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  // Provide git diff --name-status output
  const result4 = await result3.next({
    exitCode: 0,
    stdout: 'M\tsrc/file.ts',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  // Provide git diff --staged output
  const result5 = await result4.next({
    exitCode: 0,
    stdout: '--- a/src/file.ts\n+++ b/src/file.ts\n@@ -1 +1,2 @@\n+// new code',
    stderr: '',
  })
  expect(result5).toMatchSnapshot()
  assert(result5.status === 'pending')

  // Provide agent response
  const result6 = await result5.next({
    output: { commitMessage: 'chore: update file' },
    messages: [],
  })
  expect(result6).toMatchSnapshot()
  assert(result6.status === 'pending')

  // Provide createCommit response
  const result7 = await result6.next({ message: 'chore: update file' })
  expect(result7).toMatchSnapshot()
})

test('should prompt user and stage when confirmed', async () => {
  const result1 = await run(commitWorkflow, {})
  assert(result1.status === 'pending')

  // Provide no staged files but some unstaged files
  const result2 = await result1.next({
    stagedFiles: [],
    unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
  })
  expect(result2).toMatchSnapshot()
  assert(result2.status === 'pending')

  // User confirms staging
  const result3 = await result2.next(true)
  expect(result3).toMatchSnapshot()
  assert(result3.status === 'pending')

  // Provide git add . response
  const result4 = await result3.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  // Provide git diff --name-status output
  const result5 = await result4.next({
    exitCode: 0,
    stdout: 'M\tsrc/file.ts',
    stderr: '',
  })
  expect(result5).toMatchSnapshot()
  assert(result5.status === 'pending')

  // Provide git diff --staged output
  const result6 = await result5.next({
    exitCode: 0,
    stdout: '--- a/src/file.ts\n+++ b/src/file.ts\n@@ -1 +1,2 @@\n+// updated',
    stderr: '',
  })
  expect(result6).toMatchSnapshot()
  assert(result6.status === 'pending')

  // Provide agent response
  const result7 = await result6.next({
    output: { commitMessage: 'fix: update logic' },
    messages: [],
  })
  expect(result7).toMatchSnapshot()
  assert(result7.status === 'pending')

  // Provide createCommit response
  const result8 = await result7.next({ message: 'fix: update logic' })
  expect(result8).toMatchSnapshot()
})

test('should throw UserCancelledError when user declines staging', async () => {
  const result1 = await run(commitWorkflow, {})
  assert(result1.status === 'pending')

  // Provide no staged files but some unstaged files
  const result2 = await result1.next({
    stagedFiles: [],
    unstagedFiles: [{ path: 'src/file.ts', status: 'M' }],
  })
  assert(result2.status === 'pending')

  // User declines staging
  const result3 = await result2.next(false)
  assert(result3.status === 'failed')
  expect(result3.error instanceof UserCancelledError).toBe(true)
  expect({ status: result3.status, errorName: (result3.error as Error)?.name }).toMatchSnapshot()
})

test('should throw error when no files to commit', async () => {
  const result1 = await run(commitWorkflow, {})
  assert(result1.status === 'pending')

  // Provide no staged or unstaged files
  const result2 = await result1.next({
    stagedFiles: [],
    unstagedFiles: [],
  })
  assert(result2.status === 'failed')
  expect({ status: result2.status, error: (result2.error as Error)?.message }).toMatchSnapshot()
})

test('should include user context in agent prompt', async () => {
  const result1 = await run(commitWorkflow, { context: 'Implementing feature X for ticket #123' })
  assert(result1.status === 'pending')

  // Provide staged files
  const result2 = await result1.next({
    stagedFiles: [{ path: 'src/feature.ts', status: 'A' }],
    unstagedFiles: [],
  })
  assert(result2.status === 'pending')

  // Provide git diff --name-status output
  const result3 = await result2.next({
    exitCode: 0,
    stdout: 'A\tsrc/feature.ts',
    stderr: '',
  })
  assert(result3.status === 'pending')

  // Provide git diff --staged output
  const result4 = await result3.next({
    exitCode: 0,
    stdout: '--- /dev/null\n+++ b/src/feature.ts\n@@ -0,0 +1 @@\n+export const feature = () => {}',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  // Provide agent response
  const result5 = await result4.next({
    output: { commitMessage: 'feat: implement feature X (#123)' },
    messages: [],
  })
  assert(result5.status === 'pending')

  // Provide createCommit response
  const result6 = await result5.next({ message: 'feat: implement feature X (#123)' })
  expect(result6).toMatchSnapshot()
})

test('should handle various file statuses', async () => {
  const result1 = await run(commitWorkflow, {})
  assert(result1.status === 'pending')

  // Provide files with different statuses
  const result2 = await result1.next({
    stagedFiles: [
      { path: 'src/modified.ts', status: 'M' },
      { path: 'src/added.ts', status: 'A' },
      { path: 'src/deleted.ts', status: 'D' },
      { path: 'src/renamed.ts', status: 'R' },
    ],
    unstagedFiles: [],
  })
  assert(result2.status === 'pending')

  // Provide git diff --name-status output
  const result3 = await result2.next({
    exitCode: 0,
    stdout: 'M\tsrc/modified.ts\nA\tsrc/added.ts\nD\tsrc/deleted.ts\nR100\tsrc/old.ts\tsrc/renamed.ts',
    stderr: '',
  })
  assert(result3.status === 'pending')

  // Provide git diff --staged output
  const result4 = await result3.next({
    exitCode: 0,
    stdout: '--- a/src/modified.ts\n+++ b/src/modified.ts\n@@ -1 +1,2 @@\n+// changes\n',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  // Provide agent response
  const result5 = await result4.next({
    output: { commitMessage: 'refactor: restructure files' },
    messages: [],
  })
  assert(result5.status === 'pending')

  // Provide createCommit response
  const result6 = await result5.next({ message: 'refactor: restructure files' })
  expect(result6).toMatchSnapshot()
})

test('should handle empty diff name status result', async () => {
  const result1 = await run(commitWorkflow, {})
  assert(result1.status === 'pending')

  // Provide staged files
  const result2 = await result1.next({
    stagedFiles: [{ path: 'src/file.ts', status: 'M' }],
    unstagedFiles: [],
  })
  assert(result2.status === 'pending')

  // Provide empty git diff --name-status output
  const result3 = await result2.next({
    exitCode: 1,
    stdout: '',
    stderr: 'error',
  })
  assert(result3.status === 'pending')

  // Provide git diff --staged output
  const result4 = await result3.next({
    exitCode: 0,
    stdout: '--- a/src/file.ts\n+++ b/src/file.ts\n@@ -1 +1,2 @@\n+// code',
    stderr: '',
  })
  expect(result4).toMatchSnapshot()
  assert(result4.status === 'pending')

  // Provide agent response
  const result5 = await result4.next({
    output: { commitMessage: 'docs: update comments' },
    messages: [],
  })
  assert(result5.status === 'pending')

  // Provide createCommit response
  const result6 = await result5.next({ message: 'docs: update comments' })
  expect(result6).toMatchSnapshot()
})

test('should handle workflow with all stages', async () => {
  const result1 = await run(commitWorkflow, { all: true, context: 'Fix bug in validation' })
  assert(result1.status === 'pending')

  const result2 = await result1.next({
    stagedFiles: [],
    unstagedFiles: [{ path: 'src/validator.ts', status: 'M' }],
  })
  assert(result2.status === 'pending')

  const result3 = await result2.next({
    exitCode: 0,
    stdout: '',
    stderr: '',
  })
  assert(result3.status === 'pending')

  const result4 = await result3.next({
    exitCode: 0,
    stdout: 'M\tsrc/validator.ts',
    stderr: '',
  })
  assert(result4.status === 'pending')

  const result5 = await result4.next({
    exitCode: 0,
    stdout: '--- a/src/validator.ts\n+++ b/src/validator.ts\n@@ -10,7 +10,7 @@\n- return false\n+ return true',
    stderr: '',
  })
  assert(result5.status === 'pending')

  const result6 = await result5.next({
    output: { commitMessage: 'fix: correct validation logic\n\nFixed bug in validation that returned false instead of true' },
    messages: [],
  })
  assert(result6.status === 'pending')

  const result7 = await result6.next({
    message: 'fix: correct validation logic\n\nFixed bug in validation that returned false instead of true',
  })
  expect(result7).toMatchSnapshot()
})
