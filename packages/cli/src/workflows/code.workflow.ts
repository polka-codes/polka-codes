// generated by polka.codes
import { loadConfig } from '@polka-codes/cli-shared'
import type { PlainJson, Workflow } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { createPlan } from './utils/createPlan'

export type CodeWorkflowInput = {
  task: string
  checkCommand?: string
}

type State = 'Implementing' | 'Fixing' | 'Done'

export const codeWorkflow: Workflow<CodeWorkflowInput, PlainJson, CliToolRegistry> = {
  name: 'Code Task',
  description: 'Plan and implement a feature or task using architect and coder agents.',
  async *fn(input, _step, tools) {
    const { task, checkCommand: checkCommandInput } = input
    let plan = ''
    let userFeedback = ''
    let implementationComplete = false

    // Planning phase
    while (true) {
      console.log('\nüìã Phase 1: Creating implementation plan...\n')
      plan = yield* createPlan({
        tools,
        task,
        userFeedback,
      })

      console.log('\nüìã Generated Implementation Plan:\n')
      console.log(plan)
      console.log('\n')

      const approved = yield* tools.confirm({
        message: 'Do you approve this plan and want to proceed with implementation?',
        default: false,
      })

      if (approved) {
        userFeedback = ''
        break
      } else {
        userFeedback = yield* tools.input({
          message: 'What changes would you like to make to the plan?',
        })
      }
    }

    let state: State = 'Implementing'

    while (state !== 'Done') {
      switch (state) {
        case 'Implementing': {
          console.log('\n‚öôÔ∏è  Phase 2: Implementing the plan...\n')

          const implementPrompt = `Implement the following plan:

${plan}

Please implement all the necessary code changes according to this plan.`

          yield* tools.invokeAgent({
            agent: 'coder',
            messages: [{ type: 'user', content: implementPrompt }],
            defaultContext: true,
          })

          implementationComplete = true
          console.log('\n‚úÖ Implementation complete!\n')

          state = 'Fixing'
          break
        }

        case 'Fixing': {
          console.log('\nüîß Phase 3: Checking for errors...\n')

          let checkCommand = checkCommandInput

          if (!checkCommand) {
            const config = loadConfig()
            const check = config?.scripts?.check
            const test = config?.scripts?.test

            let checkCmd: string | undefined
            if (typeof check === 'string') {
              checkCmd = check
            } else if (check) {
              checkCmd = check.command
            }

            let testCmd: string | undefined
            if (typeof test === 'string') {
              testCmd = test
            } else if (test) {
              testCmd = test.command
            }

            let defaultCommand: string | undefined
            if (checkCmd && testCmd) {
              defaultCommand = `${checkCmd} && ${testCmd}`
            } else if (checkCmd) {
              defaultCommand = checkCmd
            } else if (testCmd) {
              defaultCommand = testCmd
            }

            if (defaultCommand) {
              checkCommand = defaultCommand
            } else {
              const shouldCheck = yield* tools.confirm({
                message: 'No check/test command configured. Do you want to specify one?',
                default: false,
              })

              if (shouldCheck) {
                checkCommand = yield* tools.input({
                  message: 'Please enter the command to run:',
                })
              }
            }
          }

          if (!checkCommand) {
            console.log('‚ö†Ô∏è  Skipping error checking phase (no command specified).\n')
            state = 'Done'
            break
          }

          let fixAttempts = 0
          const maxFixAttempts = 5

          while (fixAttempts < maxFixAttempts) {
            console.log(`Running check command: ${checkCommand}`)
            const { exitCode, stdout, stderr } = yield* tools.executeCommand({
              command: checkCommand,
              shell: true,
            })

            if (stdout) {
              console.log('Command stdout:\n', stdout)
            }
            if (stderr) {
              console.error('Command stderr:\n', stderr)
            }

            if (exitCode === 0) {
              console.log('\n‚úÖ All checks passed!\n')
              state = 'Done'
              break
            }

            fixAttempts++
            console.log(
              `\n‚ùå Command failed with exit code ${exitCode}. Asking agent to fix it... (Attempt ${fixAttempts}/${maxFixAttempts})\n`,
            )

            const fixPrompt = `The command "${checkCommand}" failed with exit code ${exitCode}.
Please fix the code to resolve the errors.

stdout:
${stdout}

stderr:
${stderr}
`

            yield* tools.invokeAgent({
              agent: 'codefixer',
              messages: [{ type: 'user', content: fixPrompt }],
              defaultContext: true,
            })
          }

          if (fixAttempts >= maxFixAttempts) {
            console.log(`\n‚ö†Ô∏è  Warning: Failed to fix all issues after ${maxFixAttempts} attempts. Manual intervention may be required.\n`)
          }

          state = 'Done'
          break
        }
      }
    }

    return {
      success: implementationComplete,
      plan,
    }
  },
}
