// generated by polka.codes
import { loadConfig } from '@polka-codes/cli-shared'
import type { PlainJson, Workflow, WorkflowTools } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { getFixPrompt, getImplementPrompt } from './prompts'
import { createPlan } from './utils/createPlan'

export type CodeWorkflowInput = {
  task: string
  checkCommand?: string
}

async function* resolveCheckCommand(
  tools: WorkflowTools<CliToolRegistry>,
  checkCommandInput?: string,
): AsyncGenerator<any, string | undefined, any> {
  if (checkCommandInput) {
    return checkCommandInput
  }

  const config = loadConfig()
  const check = config?.scripts?.check
  const test = config?.scripts?.test

  let checkCmd: string | undefined
  if (typeof check === 'string') {
    checkCmd = check
  } else if (check) {
    checkCmd = check.command
  }

  let testCmd: string | undefined
  if (typeof test === 'string') {
    testCmd = test
  } else if (test) {
    testCmd = test.command
  }

  let defaultCommand: string | undefined
  if (checkCmd && testCmd) {
    defaultCommand = `${checkCmd} && ${testCmd}`
  } else if (checkCmd) {
    defaultCommand = checkCmd
  } else if (testCmd) {
    defaultCommand = testCmd
  }

  if (defaultCommand) {
    return defaultCommand
  }

  const shouldCheck = yield* tools.confirm({
    message: 'No check/test command configured. Do you want to specify one?',
    default: false,
  })

  if (shouldCheck) {
    return yield* tools.input({
      message: 'Please enter the command to run:',
    })
  }

  return undefined
}

async function* runFixingLoop(tools: WorkflowTools<CliToolRegistry>, checkCommand: string): AsyncGenerator<any, boolean, any> {
  let fixAttempts = 0
  const maxFixAttempts = 5

  while (fixAttempts < maxFixAttempts) {
    console.log(`Running check command: ${checkCommand}`)
    const { exitCode, stdout, stderr } = yield* tools.executeCommand({
      command: checkCommand,
      shell: true,
    })

    if (stdout) {
      console.log('Command stdout:\n', stdout)
    }
    if (stderr) {
      console.error('Command stderr:\n', stderr)
    }

    if (exitCode === 0) {
      console.log('\n‚úÖ All checks passed!\n')
      return true
    }

    fixAttempts++
    console.log(`\n‚ùå Command failed with exit code ${exitCode}. Asking agent to fix it... (Attempt ${fixAttempts}/${maxFixAttempts})\n`)

    const fixPrompt = getFixPrompt(checkCommand, exitCode, stdout, stderr)

    yield* tools.invokeAgent({
      agent: 'codefixer',
      messages: [{ type: 'user', content: fixPrompt }],
      defaultContext: true,
    })
  }

  if (fixAttempts >= maxFixAttempts) {
    console.log(`\n‚ö†Ô∏è  Warning: Failed to fix all issues after ${maxFixAttempts} attempts. Manual intervention may be required.\n`)
  }

  return false
}

export const codeWorkflow: Workflow<CodeWorkflowInput, PlainJson, CliToolRegistry> = {
  name: 'Code Task',
  description: 'Plan and implement a feature or task using architect and coder agents.',
  async *fn(input, _step, tools) {
    const { task, checkCommand: checkCommandInput } = input
    let plan = ''
    let userFeedback = ''
    let implementationComplete = false

    // Planning phase
    while (true) {
      console.log('\nüìã Phase 1: Creating implementation plan...\n')
      plan = yield* createPlan({
        tools,
        task,
        userFeedback,
      })

      console.log('\nüìã Generated Implementation Plan:\n')
      console.log(plan)
      console.log('\n')

      const approved = yield* tools.confirm({
        message: 'Do you approve this plan and want to proceed with implementation?',
        default: false,
      })

      if (approved) {
        userFeedback = ''
        break
      } else {
        userFeedback = yield* tools.input({
          message: 'What changes would you like to make to the plan?',
        })
      }
    }

    // Implementation phase
    console.log('\n‚öôÔ∏è  Phase 2: Implementing the plan...\n')

    const implementPrompt = getImplementPrompt(plan)

    yield* tools.invokeAgent({
      agent: 'coder',
      messages: [{ type: 'user', content: implementPrompt }],
      defaultContext: true,
    })

    implementationComplete = true
    console.log('\n‚úÖ Implementation complete!\n')

    // Fixing phase
    console.log('\nüîß Phase 3: Checking for errors...\n')
    const checkCommand = yield* resolveCheckCommand(tools, checkCommandInput)

    if (checkCommand) {
      yield* runFixingLoop(tools, checkCommand)
    } else {
      console.log('‚ö†Ô∏è  Skipping error checking phase (no command specified).\n')
    }

    return {
      success: implementationComplete,
      plan,
    }
  },
}
