// generated by polka.codes
import type { PlainJson, Workflow, WorkflowTools } from '@polka-codes/workflow'
import { run } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { fixWorkflow } from './fix.workflow'
import { getImplementPrompt } from './prompts'
import { createPlan } from './utils/createPlan'

export type CodeWorkflowInput = {
  task: string
  checkCommand?: string
}

/**
 * Helper function to run a sub-workflow within the current workflow context.
 * This allows code.workflow to invoke fix.workflow without duplicating its logic.
 */
async function* runSubWorkflow<TInput extends PlainJson, TOutput extends PlainJson>(
  tools: WorkflowTools<CliToolRegistry>,
  workflow: Workflow<TInput, TOutput, CliToolRegistry>,
  input: TInput,
): AsyncGenerator<any, TOutput | undefined, any> {
  // Start the sub-workflow
  let state = await run(workflow, input)

  // Process tool calls from the sub-workflow
  while (state.status === 'pending') {
    const toolName = state.tool.tool as keyof CliToolRegistry
    const toolInput = state.tool.input as any

    // Delegate the tool call to the parent workflow's tools
    const toolFn = tools[toolName] as any
    const toolResult = yield* toolFn(toolInput)

    // Continue the sub-workflow with the tool result
    state = await state.next(toolResult)
  }

  // Handle the final state
  if (state.status === 'completed') {
    return state.output
  }

  if (state.status === 'failed') {
    console.log('‚ö†Ô∏è  Warning: Fix workflow encountered errors.\n')
    const error = state.error as Error
    console.error('Error details:', error.message)
    return undefined
  }

  return undefined
}

export const codeWorkflow: Workflow<CodeWorkflowInput, PlainJson, CliToolRegistry> = {
  name: 'Code Task',
  description: 'Plan and implement a feature or task using architect and coder agents.',
  async *fn(input, _step, tools) {
    const { task, checkCommand: checkCommandInput } = input
    let plan = ''
    let userFeedback = ''
    let implementationComplete = false

    // Planning phase
    while (true) {
      console.log('\nüìã Phase 1: Creating implementation plan...\n')
      plan = yield* createPlan({
        tools,
        task,
        userFeedback,
      })

      console.log('\nüìã Generated Implementation Plan:\n')
      console.log(plan)
      console.log('\n')

      const approved = yield* tools.confirm({
        message: 'Do you approve this plan and want to proceed with implementation?',
        default: false,
      })

      if (approved) {
        userFeedback = ''
        break
      } else {
        userFeedback = yield* tools.input({
          message: 'What changes would you like to make to the plan?',
        })
      }
    }

    // Implementation phase
    console.log('\n‚öôÔ∏è  Phase 2: Implementing the plan...\n')

    const implementPrompt = getImplementPrompt(plan)

    yield* tools.invokeAgent({
      agent: 'coder',
      messages: [{ type: 'user', content: implementPrompt }],
      defaultContext: true,
    })

    implementationComplete = true
    console.log('\n‚úÖ Implementation complete!\n')

    // Fixing phase
    console.log('\nüîß Phase 3: Checking for errors...\n')

    if (checkCommandInput) {
      // Run fix workflow with the provided command
      yield* runSubWorkflow(tools, fixWorkflow, { command: checkCommandInput })
    }

    return {
      success: implementationComplete,
      plan,
    }
  },
}
