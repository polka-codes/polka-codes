// generated by polka.codes

import {
  askFollowupQuestion,
  executeCommand,
  type FullToolInfo,
  fetchUrl,
  listFiles,
  listMemoryTopics,
  readBinaryFile,
  readFile,
  readMemory,
  removeFile,
  renameFile,
  replaceInFile,
  searchFiles,
  ToolResponseType,
  updateMemory,
  writeToFile,
} from '@polka-codes/core'
import { agentWorkflow, type JsonUserContent, type WorkflowFn } from '@polka-codes/workflow'
import { z } from 'zod'
import type { CliToolRegistry } from '../workflow-tools'
import { fixWorkflow } from './fix.workflow'
import { planWorkflow } from './plan.workflow'
import { CODER_SYSTEM_PROMPT, getImplementPrompt } from './prompts'
import { getDefaultContext } from './workflow.utils'

export type JsonImagePart = {
  type: 'image'
  mediaType: string
  image: string // base64 encoded
}

export type JsonFilePart = {
  type: 'file'
  mediaType: string
  filename: string
  data: string // base64 encoded
}

const ImplementOutputSchema = z
  .object({
    summary: z.string().nullish(),
    bailReason: z.string().nullish(),
  })
  .refine((data) => (data.summary != null) !== (data.bailReason != null), {
    message: 'Either summary or bailReason must be provided, but not both',
  })

export type CodeWorkflowInput = {
  task: string
  files?: (JsonFilePart | JsonImagePart)[]
  mode?: 'interactive' | 'noninteractive'
}

export const codeWorkflow: WorkflowFn<
  CodeWorkflowInput,
  { success: true; summaries: string[] } | { success: false; reason: string; summaries: string[] },
  CliToolRegistry
> = async (input, context) => {
  const { logger, step, tools } = context
  const { task, files, mode = 'interactive' } = input
  const summaries: string[] = []

  // Planning phase
  logger.info('\n📋 Phase 1: Creating implementation plan...\n')
  const planResult = await step('plan', async () => {
    return await planWorkflow({ task, files, mode: mode === 'interactive' ? 'confirm' : 'noninteractive' }, context)
  })

  if (!planResult) {
    logger.info('Plan not approved. Exiting.')
    return { success: false, reason: 'Plan not approved', summaries }
  }

  const { plan, files: planFiles } = planResult

  // Implementation phase
  logger.info('\n⚙️  Phase 2: Implementing the plan...\n')

  let implementPrompt = getImplementPrompt(plan)
  if (planFiles && planFiles.length > 0) {
    const fileContentString = planFiles.map((f) => `<file path="${f.path}">${f.content}</file>`).join('\n')
    implementPrompt += `\n\nHere are the files related to the plan:\n${fileContentString}`
  }
  const userContent: JsonUserContent = [{ type: 'text', text: implementPrompt }]
  if (files) {
    for (const file of files) {
      if (file.type === 'file') {
        userContent.push({
          type: 'file',
          mediaType: file.mediaType,
          filename: file.filename,
          data: { type: 'base64', value: file.data },
        })
      } else if (file.type === 'image') {
        userContent.push({
          type: 'image',
          mediaType: file.mediaType,
          image: { type: 'base64', value: file.image },
        })
      }
    }
  }

  const agentTools: FullToolInfo[] = [
    readFile,
    writeToFile,
    replaceInFile,
    searchFiles,
    listFiles,
    executeCommand,
    fetchUrl,
    readBinaryFile,
    removeFile,
    renameFile,
    readMemory,
    updateMemory,
    listMemoryTopics,
  ]
  if (mode === 'interactive') {
    agentTools.push(askFollowupQuestion)
  }

  const res = await step('implement', async () => {
    const defaultContext = await getDefaultContext()
    const memoryContext = await tools.getMemoryContext()
    const textContent = userContent.find((c) => c.type === 'text')
    if (textContent && textContent.type === 'text') {
      textContent.text = `${textContent.text}\n\n${defaultContext}\n${memoryContext}`
    } else {
      userContent.push({
        type: 'text',
        text: `${defaultContext}\n${memoryContext}`,
      })
    }
    return await agentWorkflow(
      {
        systemPrompt: CODER_SYSTEM_PROMPT,
        userMessage: [{ role: 'user', content: userContent }],
        tools: agentTools,
        outputSchema: ImplementOutputSchema,
      },
      context,
    )
  })

  if (res.type === ToolResponseType.Exit && res.object) {
    const { summary, bailReason } = res.object as z.infer<typeof ImplementOutputSchema>

    if (bailReason) {
      logger.error(`\n❌ Implementation failed: ${bailReason}\n`)
      return { success: false, reason: bailReason, summaries }
    }

    if (summary) {
      logger.info('\n✅ Implementation complete!\n')
      summaries.push(summary)
      logger.info(`Summary: ${summary}`)
      await step('summarize-implementation', async () => {
        await tools.updateMemory({
          operation: 'append',
          topic: 'implementation-summary',
          content: summary,
        })
      })
    } else {
      logger.info('\n✅ Implementation complete!\n')
    }
  } else if (res.type === ToolResponseType.Exit) {
    logger.info('\n✅ Implementation complete!\n')
  } else {
    logger.warn('\n⚠️ Implementation failed. Please check the output for errors.\n', res)
  }

  // Fixing phase
  logger.info('\n🔧 Phase 3: Checking for errors...\n')
  const fixResult = await step('fix', async () => {
    return await fixWorkflow({ interactive: false, task: input.task }, context)
  })

  if (fixResult.summaries) {
    summaries.push(...fixResult.summaries)
  }

  if (!fixResult.success) {
    return { success: false, reason: fixResult.reason, summaries }
  }

  return { success: true, summaries }
}
