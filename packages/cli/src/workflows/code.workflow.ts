// generated by polka.codes

import {
  askFollowupQuestion,
  executeCommand,
  type FullToolInfoV2,
  fetchUrl,
  listFiles,
  readBinaryFile,
  readFile,
  removeFile,
  renameFile,
  replaceInFile,
  searchFiles,
  ToolResponseType,
  writeToFile,
} from '@polka-codes/core'
import { agentWorkflow, type JsonUserContent, type WorkflowFn } from '@polka-codes/workflow'
import type { CliToolRegistry } from '../workflow-tools'
import { fixWorkflow } from './fix.workflow'
import { planWorkflow } from './plan.workflow'
import { CODER_SYSTEM_PROMPT, getImplementPrompt } from './prompts'

export type JsonImagePart = {
  type: 'image'
  mediaType: string
  image: string // base64 encoded
}

export type JsonFilePart = {
  type: 'file'
  mediaType: string
  filename: string
  data: string // base64 encoded
}

export type CodeWorkflowInput = {
  task: string
  files?: (JsonFilePart | JsonImagePart)[]
  mode?: 'interactive' | 'noninteractive'
}

export const codeWorkflow: WorkflowFn<CodeWorkflowInput, void, CliToolRegistry> = async (input, context) => {
  const { logger, step } = context
  const { task, files, mode = 'interactive' } = input

  // Planning phase
  logger.info('\nðŸ“‹ Phase 1: Creating implementation plan...\n')
  const planResult = await step('plan', async () => {
    return await planWorkflow({ task, files, mode: mode === 'interactive' ? 'confirm' : 'noninteractive' }, context)
  })

  if (!planResult) {
    logger.info('Plan not approved. Exiting.')
    return
  }

  const { plan, files: planFiles } = planResult

  // Implementation phase
  logger.info('\nâš™ï¸  Phase 2: Implementing the plan...\n')

  let implementPrompt = getImplementPrompt(plan)
  if (planFiles && planFiles.length > 0) {
    const fileContentString = planFiles.map((f) => `<file path="${f.path}">${f.content}</file>`).join('\n')
    implementPrompt += `\n\nHere are the files related to the plan:\n${fileContentString}`
  }
  const userContent: JsonUserContent = [{ type: 'text', text: implementPrompt }]
  if (files) {
    for (const file of files) {
      if (file.type === 'file') {
        userContent.push({
          type: 'file',
          mediaType: file.mediaType,
          filename: file.filename,
          data: { type: 'base64', value: file.data },
        })
      } else if (file.type === 'image') {
        userContent.push({
          type: 'image',
          mediaType: file.mediaType,
          image: { type: 'base64', value: file.image },
        })
      }
    }
  }

  const agentTools: FullToolInfoV2[] = [
    readFile,
    writeToFile,
    replaceInFile,
    searchFiles,
    listFiles,
    executeCommand,
    fetchUrl,
    readBinaryFile,
    removeFile,
    renameFile,
  ]
  if (mode === 'interactive') {
    agentTools.push(askFollowupQuestion)
  }

  const res = await step('implement', async () => {
    return await agentWorkflow(
      {
        systemPrompt: CODER_SYSTEM_PROMPT,
        userMessage: [{ role: 'user', content: userContent }],
        tools: agentTools,
      },
      context,
    )
  })

  if (res.type === ToolResponseType.Exit) {
    logger.info('\nâœ… Implementation complete!\n')
  } else {
    logger.warn('\nâš ï¸ Implementation failed. Please check the output for errors.\n', res)
  }

  // Fixing phase
  logger.info('\nðŸ”§ Phase 3: Checking for errors...\n')
  await step('fix', async () => {
    await fixWorkflow({ interactive: false, task: input.task }, context)
  })
}
