// generated by polka.codes
import { describe, expect, it } from 'bun:test'
import { mkdirSync, rmSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import type { Logger, ScriptConfig } from '@polka-codes/core'
import { ScriptExecutionError, ScriptRunner, ScriptTimeoutError, ScriptValidationError } from '../runner'

// Mock logger
const mockLogger: Logger = {
  debug: () => {},
  info: () => {},
  warn: () => {},
  error: () => {},
}

describe('ScriptRunner', () => {
  const testDir = join(process.cwd(), 'test-scripts')
  const runner = new ScriptRunner()

  // Setup test directory
  const setup = () => {
    try {
      mkdirSync(testDir, { recursive: true })
    } catch {
      // Directory already exists
    }
  }

  // Cleanup test directory
  const cleanup = () => {
    try {
      rmSync(testDir, { recursive: true, force: true })
    } catch {
      // Directory doesn't exist
    }
  }

  // Create a test script
  const createTestScript = (name: string, content: string) => {
    writeFileSync(join(testDir, name), content)
  }

  it('should execute a valid TypeScript script', async () => {
    setup()
    createTestScript(
      'valid.ts',
      `
      export async function main(args: string[]) {
        return { success: true, args }
      }
    `,
    )

    const result = await runner.execute({
      scriptPath: join(testDir, 'valid.ts'),
      args: ['--test'],
      context: {},
      logger: mockLogger,
    })

    expect(result.success).toBe(true)
    expect(result.returnValue).toEqual({ success: true, args: ['--test'] })

    cleanup()
  })

  it('should throw error for script without main function', async () => {
    setup()
    createTestScript(
      'no-main.ts',
      `
      export const helper = () => {}
    `,
    )

    const result = await runner.execute({
      scriptPath: join(testDir, 'no-main.ts'),
      args: [],
      context: {},
      logger: mockLogger,
    })

    expect(result.success).toBe(false)
    expect(result.error).toBeDefined()
    expect(result.error).toBeInstanceOf(ScriptExecutionError)

    cleanup()
  })

  it('should handle script execution errors', async () => {
    setup()
    createTestScript(
      'error.ts',
      `
      export async function main(args: string[]) {
        throw new Error('Test error')
      }
    `,
    )

    const result = await runner.execute({
      scriptPath: join(testDir, 'error.ts'),
      args: [],
      context: {},
      logger: mockLogger,
    })

    expect(result.success).toBe(false)
    expect(result.error?.message).toContain('Test error')

    cleanup()
  })

  it('should enforce timeout', async () => {
    setup()
    createTestScript(
      'timeout.ts',
      `
      export async function main(args: string[]) {
        await new Promise(resolve => setTimeout(resolve, 10000))
        return 'done'
      }
    `,
    )

    // Timeout errors are re-thrown, so we need to catch them
    try {
      await runner.execute({
        scriptPath: join(testDir, 'timeout.ts'),
        args: [],
        context: {},
        logger: mockLogger,
        timeout: 100, // 100ms timeout
      })
      // Should not reach here
      expect(true).toBe(false)
    } catch (error) {
      // Expected to timeout
      expect(error).toBeInstanceOf(ScriptTimeoutError)
      expect(error).toHaveProperty('message', expect.stringContaining('timeout'))
    }

    cleanup()
  })

  it('should validate script path before execution', async () => {
    // Try to execute a script outside the project directory
    // This should fail validation before attempting to execute
    try {
      await runner.execute({
        scriptPath: '../etc/passwd', // Invalid path
        args: [],
        context: {},
        logger: mockLogger,
      })
      // Should not reach here
      expect(true).toBe(false)
    } catch (error) {
      // Expected to throw during validation
      expect(error).toBeInstanceOf(ScriptValidationError)
      expect(error).toHaveProperty('message', expect.stringContaining('outside project directory'))
    }
  })
})

describe('ScriptRunner type guards', () => {
  const runner = new ScriptRunner()

  it('should identify TypeScript scripts', () => {
    const script: ScriptConfig = { script: './test.ts', description: 'Test' }
    expect(runner.isTypeScriptScript(script)).toBe(true)
  })

  it('should identify workflow scripts', () => {
    const script: ScriptConfig = { workflow: './test.yml' }
    expect(runner.isWorkflowScript(script)).toBe(true)
  })

  it('should identify shell commands', () => {
    const script1: ScriptConfig = 'bun test'
    expect(runner.isShellCommand(script1)).toBe(true)

    const script2: ScriptConfig = { command: 'bun test', description: 'Test' }
    expect(runner.isShellCommand(script2)).toBe(true)
  })

  it('should not misidentify script types', () => {
    const script: ScriptConfig = { script: './test.ts' }
    expect(runner.isWorkflowScript(script)).toBe(false)
    expect(runner.isShellCommand(script)).toBe(false)
  })
})

describe('ScriptRunner error classes', () => {
  it('should create ScriptValidationError with correct name', () => {
    const error = new ScriptValidationError('test message')
    expect(error.name).toBe('ScriptValidationError')
    expect(error.message).toBe('Script validation failed: test message')
  })

  it('should create ScriptTimeoutError with correct name', () => {
    const error = new ScriptTimeoutError('test.ts', 5000)
    expect(error.name).toBe('ScriptTimeoutError')
    expect(error.message).toBe('Script execution timeout: test.ts exceeded 5000ms')
  })

  it('should create ScriptExecutionError with correct name and cause', () => {
    const cause = new Error('original error')
    const error = new ScriptExecutionError('test.ts', cause)
    expect(error.name).toBe('ScriptExecutionError')
    expect(error.message).toBe('Script execution failed: test.ts')
    expect(error.cause).toBe(cause)
  })
})
