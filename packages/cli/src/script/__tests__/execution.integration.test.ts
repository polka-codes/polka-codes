// generated by polka.codes
import { afterAll, beforeAll, describe, expect, it } from 'bun:test'
import { execSync, execFileSync } from 'node:child_process'
import { existsSync, mkdirSync, rmSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import type { Logger } from '@polka-codes/core'
import { ScriptRunner } from '../runner'

// Mock logger
const mockLogger: Logger = {
  debug: () => {},
  info: () => {},
  warn: () => {},
  error: () => {},
}

describe('Script Execution Integration Tests', () => {
  const testProjectDir = join(process.cwd(), 'test-integration-project')
  const scriptsDir = join(testProjectDir, '.polka-scripts')
  const runner = new ScriptRunner()

  beforeAll(() => {
    // Create test project directory
    mkdirSync(scriptsDir, { recursive: true })

    // Create a test script that uses polka-codes APIs
    writeFileSync(
      join(scriptsDir, 'test-script.ts'),
      `
import type { ScriptContext } from '@polka-codes/cli'

export async function main(args: string[], context: ScriptContext) {
  const { logger } = context
  logger.info('Test script executed')
  logger.info('Args:', args.join(' '))

  return {
    success: true,
    message: 'Integration test passed',
    args,
  }
}

if (import.meta.main) {
  main(process.argv.slice(2), { logger: console, projectRoot: process.cwd() })
}
`,
    )

    // Create a script with timeout
    writeFileSync(
      join(scriptsDir, 'timeout-script.ts'),
      `
import type { ScriptContext } from '@polka-codes/cli'

export async function main(args: string[], context: ScriptContext) {
  const { logger } = context
  logger.info('Starting long operation...')
  await new Promise(resolve => setTimeout(resolve, 10000))
  return { done: true }
}

if (import.meta.main) {
  main(process.argv.slice(2), { logger: console, projectRoot: process.cwd() })
}
`,
    )

    // Create a script that throws an error
    writeFileSync(
      join(scriptsDir, 'error-script.ts'),
      `
import type { ScriptContext } from '@polka-codes/cli'

export async function main(args: string[], context: ScriptContext) {
  throw new Error('Intentional test error')
}

if (import.meta.main) {
  main(process.argv.slice(2), { logger: console, projectRoot: process.cwd() })
}
`,
    )

    // Create a script without main function
    writeFileSync(
      join(scriptsDir, 'no-main-script.ts'),
      `
export const helper = () => 'helper function'
`,
    )
  })

  afterAll(() => {
    // Cleanup test project directory
    try {
      rmSync(testProjectDir, { recursive: true, force: true })
    } catch {
      // Directory doesn't exist
    }
  })

  describe('Direct ScriptRunner execution', () => {
    it('should execute TypeScript script and return result', async () => {
      const scriptPath = join(scriptsDir, 'test-script.ts')
      const result = await runner.execute({
        scriptPath,
        args: ['--arg1', '--arg2'],
        context: {},
        logger: mockLogger,
      })

      expect(result.success).toBe(true)
      expect(result.returnValue).toEqual({
        success: true,
        message: 'Integration test passed',
        args: ['--arg1', '--arg2'],
      })
    })

    it('should handle script execution errors gracefully', async () => {
      const scriptPath = join(scriptsDir, 'error-script.ts')
      const result = await runner.execute({
        scriptPath,
        args: [],
        context: {},
        logger: mockLogger,
      })

      expect(result.success).toBe(false)
      expect(result.error).toBeDefined()
      expect(result.error?.message).toContain('Intentional test error')
    })

    it('should enforce timeout on long-running scripts', async () => {
      const scriptPath = join(scriptsDir, 'timeout-script.ts')

      try {
        await runner.execute({
          scriptPath,
          args: [],
          context: {},
          logger: mockLogger,
          timeout: 500, // 500ms timeout
        })
        expect(true).toBe(false) // Should not reach here
      } catch (error) {
        expect(error).toBeDefined()
        expect((error as Error).name).toBe('ScriptTimeoutError')
      }
    })

    it('should fail when script lacks main function', async () => {
      const scriptPath = join(scriptsDir, 'no-main-script.ts')
      const result = await runner.execute({
        scriptPath,
        args: [],
        context: {},
        logger: mockLogger,
      })

      expect(result.success).toBe(false)
      expect(result.error).toBeDefined()
      expect(result.error?.name).toBe('ScriptExecutionError')
      expect(result.error?.cause).toBeDefined()
      if (result.error?.cause instanceof Error) {
        expect(result.error.cause.message).toContain("must export a 'main")
      }
    })
  })

  describe('End-to-end CLI execution', () => {
    it('should execute script via Bun runtime', () => {
      const scriptPath = join(scriptsDir, 'test-script.ts')

      const output = execFileSync('bun', ['run', scriptPath, '--test-arg'], {
        cwd: testProjectDir,
        encoding: 'utf-8',
      })

      expect(output).toContain('Test script executed')
      expect(output).toContain('--test-arg')
    })

    it('should handle scripts that throw errors via Bun runtime', () => {
      const scriptPath = join(scriptsDir, 'error-script.ts')

      try {
        execFileSync('bun', ['run', scriptPath], {
          cwd: testProjectDir,
          encoding: 'utf-8',
        })
        expect(true).toBe(false) // Should not reach here
      } catch (error) {
        expect((error as any).stderr).toContain('Intentional test error')
      }
    })
  })

  describe('Script file system operations', () => {
    it('should read and write files in script directory', async () => {
      const testFilePath = join(scriptsDir, 'test-io.ts')
      const testDataFile = join(testProjectDir, 'test-data.txt')

      writeFileSync(
        testFilePath,
        `
import { readFileSync, writeFileSync } from 'node:fs'
import { join, dirname } from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

export async function main(args: string[]) {
  // Use absolute path for test data file
  const dataFile = '${testDataFile}'

  // Write test data
  writeFileSync(dataFile, 'test content from script')

  // Read it back
  const content = readFileSync(dataFile, 'utf-8')

  return {
    success: true,
    content,
  }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`,
      )

      const result = await runner.execute({
        scriptPath: testFilePath,
        args: [],
        context: {},
        logger: mockLogger,
      })

      expect(result.success).toBe(true)
      if (result.returnValue && typeof result.returnValue === 'object') {
        expect(result.returnValue).toHaveProperty('content', 'test content from script')
      }
      expect(existsSync(testDataFile)).toBe(true)

      // Cleanup
      rmSync(testFilePath)
      rmSync(testDataFile)
    })
  })

  describe('Script argument parsing', () => {
    it('should handle empty arguments', async () => {
      const testFilePath = join(scriptsDir, 'test-args.ts')

      writeFileSync(
        testFilePath,
        `
export async function main(args: string[]) {
  return {
    success: true,
    argCount: args.length,
    args,
  }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`,
      )

      const result = await runner.execute({
        scriptPath: testFilePath,
        args: [],
        context: {},
        logger: mockLogger,
      })

      expect(result.success).toBe(true)
      if (result.returnValue && typeof result.returnValue === 'object') {
        expect(result.returnValue).toHaveProperty('argCount', 0)
        expect(result.returnValue).toHaveProperty('args', [])
      }

      rmSync(testFilePath)
    })

    it('should handle multiple arguments with special characters', async () => {
      const testFilePath = join(scriptsDir, 'test-special-args.ts')

      writeFileSync(
        testFilePath,
        `
export async function main(args: string[]) {
  return {
    success: true,
    args,
  }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`,
      )

      const specialArgs = ['--flag', 'value with spaces', '--another="quoted"', '--emoji=ðŸš€']

      const result = await runner.execute({
        scriptPath: testFilePath,
        args: specialArgs,
        context: {},
        logger: mockLogger,
      })

      expect(result.success).toBe(true)
      if (result.returnValue && typeof result.returnValue === 'object') {
        expect(result.returnValue).toHaveProperty('args', specialArgs)
      }

      rmSync(testFilePath)
    })
  })
})
