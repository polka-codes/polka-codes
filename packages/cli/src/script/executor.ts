// generated by polka.codes
import { spawnSync } from 'node:child_process'
import type { Logger, ScriptConfig } from '@polka-codes/core'
import { ScriptRunner } from './runner'

/**
 * Error thrown when script execution fails
 */
export class ScriptExecutionFailedError extends Error {
  constructor(
    public scriptName: string,
    public exitCode: number,
    message?: string,
  ) {
    super(message || `Script '${scriptName}' failed with exit code ${exitCode}`)
    this.name = 'ScriptExecutionFailedError'
  }
}

/**
 * Execute a script configuration with the provided arguments.
 * This is a shared utility used by both the `run` and `meta` commands.
 *
 * @param script - The script configuration to execute
 * @param name - The name of the script (for error messages)
 * @param logger - Logger instance for output
 * @param args - Arguments to pass to the script
 * @throws {ScriptExecutionFailedError} When script execution fails
 */
export async function executeScript(script: ScriptConfig, name: string, logger: Logger, args: string[] = []): Promise<void> {
  const runner = new ScriptRunner()

  // Simple shell command string
  if (typeof script === 'string') {
    const fullCommand = args.length > 0 ? `${script} ${quoteArgs(args)}` : script
    executeShellCommand(fullCommand, name)
    return
  }

  // Command object with description
  if ('command' in script) {
    const fullCommand = args.length > 0 ? `${script.command} ${quoteArgs(args)}` : script.command
    executeShellCommand(fullCommand, name)
    return
  }

  // Workflow script
  if ('workflow' in script) {
    throw new ScriptExecutionFailedError(name, 1, `workflow execution not yet implemented for '${name}'`)
  }

  // TypeScript script
  if ('script' in script) {
    const scriptPath = script.script
    const result = await runner.execute({
      scriptPath,
      args,
      context: {}, // Context is currently unused but reserved for future use
      logger,
      timeout: script.timeout,
    })

    if (!result.success && result.error) {
      logger.error(`Script '${name}' failed: ${result.error.message}`)
      throw new ScriptExecutionFailedError(name, 1, result.error.message)
    }

    return
  }
}

/**
 * Execute a shell command using spawnSync with proper error handling.
 *
 * @param command - The command string to execute
 * @param scriptName - Name of the script for error reporting
 * @throws {ScriptExecutionFailedError} When command fails
 */
function executeShellCommand(command: string, scriptName: string): void {
  const result = spawnSync(command, {
    stdio: 'inherit',
    shell: true,
  })

  if (result.status !== 0) {
    throw new ScriptExecutionFailedError(scriptName, result.status ?? 1)
  }
}

/**
 * Quote shell arguments to preserve spaces and special characters.
 * Uses POSIX-style single quoting for safety and consistency.
 *
 * **Platform Compatibility Note**: This function uses POSIX single quotes which work
 * on Unix-like systems (Linux, macOS) but are not recognized by cmd.exe on Windows.
 * Windows users may encounter issues with arguments containing spaces or special
 * characters. Consider using a cross-platform quoting library for full Windows support.
 *
 * @param args - Array of argument strings
 * @returns Quoted arguments string
 */
function quoteArgs(args: string[]): string {
  return args
    .map((arg) => {
      // Use single quotes and escape any existing single quotes
      return `'${arg.replace(/'/g, "'\\''")}'`
    })
    .join(' ')
}
