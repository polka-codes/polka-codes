// generated by polka.codes
import { spawnSync } from 'node:child_process'
import type { Logger, ScriptConfig } from '@polka-codes/core'
import { createErrorClass } from '@polka-codes/core'
import { ScriptRunner, validateScriptPermissions } from './runner'

/**
 * Error thrown when script execution fails
 */
export const ScriptExecutionFailedError = createErrorClass(
  'ScriptExecutionFailedError',
  (args: [string, number] | [string, number, string?]) => {
    const [scriptName, exitCode, message] = args
    return message || `Script '${scriptName}' failed with exit code ${exitCode}`
  },
)

/**
 * Execute a shell command using spawnSync with proper error handling.
 *
 * SECURITY: This function uses shell execution for complex commands.
 * The command strings come from trusted configuration files (polka.codes.json),
 * not from user input. This is acceptable since:
 * 1. Commands are defined by developers in config files
 * 2. The tool itself requires explicit permissions (--allow-read, --allow-run, etc.)
 * 3. There's no user-supplied input that could lead to injection
 *
 * @param command - The command string to execute
 * @param scriptName - Name of the script for error reporting
 * @throws {ScriptExecutionFailedError} When command fails
 */
function executeShellCommand(command: string, scriptName: string): void {
  const result = spawnSync(command, {
    stdio: 'inherit',
    shell: true,
  })

  if (result.status !== 0) {
    throw new ScriptExecutionFailedError(scriptName, result.status ?? 1)
  }
}

/**
 * Quote shell arguments to preserve spaces and special characters.
 * Uses platform-appropriate quoting for cross-platform compatibility.
 *
 * On Windows (cmd.exe), arguments with spaces are wrapped in double quotes.
 * On Unix-like systems, uses POSIX single quoting.
 *
 * @param args - Array of argument strings
 * @returns Quoted arguments string
 */
function quoteArgs(args: string[]): string {
  const isWindows = process.platform === 'win32'

  return args
    .map((arg) => {
      // For Windows cmd.exe
      if (isWindows) {
        // Double quotes are used on Windows
        // Escape existing double quotes and backslashes
        const escaped = arg.replace(/(\\*)"/g, '$1$1\\"').replace(/(\\*)$/, '$1$1')
        return `"${escaped}"`
      }

      // For Unix-like systems, use single quotes
      return `'${arg.replace(/'/g, "'\\''")}'`
    })
    .join(' ')
}

/**
 * Strategy pattern for script execution
 */
type ScriptExecutor = (script: ScriptConfig, name: string, args: string[], logger: Logger, runner: ScriptRunner) => Promise<void>

// String command executor
const executeStringCommand: ScriptExecutor = async (script, name, args, _logger) => {
  const fullCommand = args.length > 0 ? `${script} ${quoteArgs(args)}` : (script as string)
  executeShellCommand(fullCommand, name)
}

// Command object executor
const executeCommandObject: ScriptExecutor = async (script, name, args, _logger) => {
  const fullCommand =
    args.length > 0 ? `${(script as { command: string }).command} ${quoteArgs(args)}` : (script as { command: string }).command
  executeShellCommand(fullCommand, name)
}

// TypeScript script executor
const executeTypeScriptScript: ScriptExecutor = async (script, name, args, logger, runner) => {
  const scriptPath = (script as { script: string; timeout?: number }).script
  const result = await runner.execute({
    scriptPath,
    args,
    context: {
      projectRoot: process.cwd(), // Provide project root to scripts
      // Additional context can be added here in the future
    },
    logger,
    timeout: (script as { timeout?: number }).timeout,
  })

  if (!result.success) {
    const errorMsg = result.error?.message || 'Unknown error'
    logger.error(`Script '${name}' failed: ${errorMsg}`)
    throw new ScriptExecutionFailedError(name, 1, errorMsg)
  }
}

/**
 * Execute a script configuration with the provided arguments.
 * This is a shared utility used by both the `run` and `meta` commands.
 *
 * @param script - The script configuration to execute
 * @param name - The name of the script (for error messages)
 * @param logger - Logger instance for output
 * @param args - Arguments to pass to the script
 * @throws {ScriptExecutionFailedError} When script execution fails
 */
export async function executeScript(script: ScriptConfig, name: string, logger: Logger, args: string[] = []): Promise<void> {
  const runner = new ScriptRunner()

  // Validate script permissions before execution
  validateScriptPermissions(script, logger)

  // Determine script type and use appropriate executor
  let scriptType = 'string'
  if (typeof script !== 'string') {
    if ('script' in script) scriptType = 'script'
    else if ('command' in script) scriptType = 'command'
    else if ('workflow' in script) scriptType = 'workflow'
    else scriptType = Object.keys(script)[0]
  }

  const executors: Record<string, ScriptExecutor> = {
    string: executeStringCommand,
    command: executeCommandObject,
    script: executeTypeScriptScript,
  }

  const executor = executors[scriptType]

  if (!executor) {
    throw new ScriptExecutionFailedError(name, 1, `workflow execution not yet implemented for '${name}'`)
  }

  await executor(script, name, args, logger, runner)
}
