// generated by polka.codes

/**
 * Script execution runtime for custom TypeScript scripts
 *
 * Provides in-process execution of TypeScript scripts with:
 * - Dynamic module loading
 * - Timeout enforcement
 * - Error handling with stack traces
 * - Security validation
 *
 * **IMPORTANT: Memory Limitation**
 * This runner uses cache busting (?t=timestamp) to ensure scripts are reloaded
 * on each execution. This creates a new module entry in Bun's module cache
 * every time a script runs. For CLI commands (which exit after one run),
 * this is acceptable. However, in long-running processes (watch mode,
 * daemon, server), this will cause memory leaks as each execution creates
 * new uncached module entries. Do NOT use this runner in long-running
 * processes (like packages/runner) without implementing a proper cache
 * management strategy.
 */

import { existsSync } from 'node:fs'
import { relative, resolve } from 'node:path'
import { pathToFileURL } from 'node:url'
import type { Logger, ScriptConfig } from '@polka-codes/core'
import { createErrorClass } from '@polka-codes/core'
import type { ExecutionContext } from '../runWorkflow'

/**
 * Error thrown when script validation fails
 */
export const ScriptValidationError = createErrorClass(
  'ScriptValidationError',
  ([message]: [string]) => `Script validation failed: ${message}`,
)

/**
 * Error thrown when script execution times out
 */
export const ScriptTimeoutError = createErrorClass(
  'ScriptTimeoutError',
  ([scriptPath, timeout]: [string, number]) => `Script execution timeout: ${scriptPath} exceeded ${timeout}ms`,
)

/**
 * Error thrown when script execution fails
 */
export const ScriptExecutionError = createErrorClass(
  'ScriptExecutionError',
  ([scriptPath]: [string]) => `Script execution failed: ${scriptPath}`,
)

/**
 * Options for script execution
 */
export interface ScriptRunnerOptions {
  /**
   * Path to the TypeScript script file
   */
  scriptPath: string

  /**
   * Command-line arguments to pass to the script
   */
  args: string[]

  /**
   * Execution context (for CLI options, etc.)
   */
  context: Partial<ExecutionContext> & { projectRoot?: string }

  /**
   * Logger instance for output
   */
  logger: Logger

  /**
   * Execution timeout in milliseconds (default: 5 minutes)
   */
  timeout?: number
}

/**
 * Result of script execution
 */
export interface ScriptExecutionResult {
  /**
   * Whether the script executed successfully
   */
  success: boolean

  /**
   * Return value from the script (if any)
   */
  returnValue?: unknown

  /**
   * Error if execution failed
   */
  error?: Error
}

/**
 * Script context passed to main function
 * Provides scripts with access to logger, config, and project info
 */
export interface ScriptContext {
  /**
   * Logger instance for output
   */
  logger: Logger

  /**
   * Project root directory
   */
  projectRoot: string

  /**
   * Additional context from execution environment
   */
  [key: string]: unknown
}

/**
 * Validates that a script path is safe to execute
 *
 * @param scriptPath - Path to the script file
 * @param projectRoot - Root directory of the project (defaults to cwd)
 * @throws {ScriptValidationError} if validation fails
 */
export function validateScriptPath(scriptPath: string, projectRoot: string = process.cwd()): void {
  // Normalize and resolve to absolute paths
  const normalizedRoot = resolve(projectRoot)
  const normalizedScript = resolve(projectRoot, scriptPath)

  // Check if path is within project directory (prevent path traversal)
  const relativePath = relative(normalizedRoot, normalizedScript)

  // Check for path traversal attempts (.. segments at start or in path components)
  if (relativePath.startsWith('..')) {
    throw new ScriptValidationError(`Script path '${scriptPath}' is outside project directory`)
  }

  // Check if file exists
  if (!existsSync(normalizedScript)) {
    throw new ScriptValidationError(`Script file not found: ${scriptPath}`)
  }

  // Check file extension (Bun supports .ts, .js, .mjs, .cjs)
  const validExtensions = ['.ts', '.js', '.mjs', '.cjs']
  const hasValidExtension = validExtensions.some((ext) => normalizedScript.endsWith(ext))

  if (!hasValidExtension) {
    throw new ScriptValidationError(`Script must be a .ts, .js, .mjs, or .cjs file: ${scriptPath}`)
  }
}

/**
 * Validates script permissions based on security configuration
 *
 * IMPORTANT: TypeScript scripts currently run with full process permissions.
 * Permission declarations in the config are ADVISORY ONLY for future sandboxing.
 * Scripts can access filesystem, network, and subprocesses regardless of declared permissions.
 *
 * @param script - Script configuration
 * @throws {ScriptValidationError} if permissions are invalid
 */
export function validateScriptPermissions(script: ScriptConfig, logger?: { warn: (message: string) => void }): void {
  if (typeof script === 'string' || 'command' in script || 'workflow' in script) {
    // These types don't have permission checks
    return
  }

  if ('script' in script && script.permissions) {
    // Warn user that permissions are advisory only
    logger?.warn('Script permissions are currently advisory only. Scripts run with full process permissions.')

    // Validate permission values
    const { fs, network, subprocess } = script.permissions

    if (fs && !['read', 'write', 'none'].includes(fs)) {
      throw new ScriptValidationError(`Invalid fs permission: ${fs}. Must be 'read', 'write', or 'none'`)
    }

    if (typeof network !== 'boolean' && network !== undefined) {
      throw new ScriptValidationError(`Invalid network permission: must be true or false`)
    }

    if (typeof subprocess !== 'boolean' && subprocess !== undefined) {
      throw new ScriptValidationError(`Invalid subprocess permission: must be true or false`)
    }
  }
}

/**
 * In-process script runner for TypeScript files
 *
 * Executes TypeScript scripts by dynamically importing them as modules.
 * Scripts should export a `main(args: string[], context: ScriptContext)` function.
 *
 * **Important Limitations:**
 *
 * 1. **Synchronous Blocking**: The timeout mechanism uses `Promise.race()` which only
 *    handles timeouts for asynchronous operations. If a script performs a synchronous
 *    blocking operation (e.g., `while(true) {}`), the timeout will not trigger and the
 *    process will hang indefinitely. This is a known limitation of in-process script
 *    execution without using Worker threads or child processes.
 *
 * 2. **Path Resolution**: Script paths are resolved relative to `process.cwd()`. If the
 *    CLI is run from a subdirectory, script paths from config may not resolve correctly.
 *    The caller should ensure paths are absolute or relative to the correct working directory.
 *
 * 3. **Memory Leak Warning**: Cache busting via timestamp query parameters (`?t=...`)
 *    only invalidates the entry point script. If a script imports other local modules,
 *    those dependencies remain cached across executions. This is acceptable for CLI
 *    commands that run once and exit, but **will cause memory leaks in long-running
 *    processes**. Do NOT use this ScriptRunner in the `packages/runner` service or
 *    other long-lived contexts without implementing proper module cache clearing
 *    strategies (e.g., using a custom VM context or Worker threads).
 *
 * @example
 * ```typescript
 * // Script file (scripts/deploy.ts):
 * export async function main(args: string[], context: ScriptContext) {
 *   const { logger, projectRoot } = context
 *   logger.info('Deploying...')
 *   // Use logger and projectRoot as needed
 * }
 *
 * // Execution:
 * const runner = new ScriptRunner()
 * const result = await runner.execute({
 *   scriptPath: './scripts/deploy.ts',
 *   args: ['--production'],
 *   context: { projectRoot: '/path/to/project' },
 *   logger: createLogger({ verbose: 1 }),
 *   timeout: 60000
 * })
 * ```
 */
export class ScriptRunner {
  /**
   * Execute a TypeScript script
   *
   * @param options - Script execution options
   * @returns Promise<ScriptExecutionResult>
   * @throws {ScriptValidationError} if validation fails
   * @throws {ScriptTimeoutError} if execution times out
   * @throws {ScriptExecutionError} if execution fails
   */
  async execute(options: ScriptRunnerOptions): Promise<ScriptExecutionResult> {
    const { scriptPath, args, logger, timeout = 300000, context } = options

    // Validate script path
    validateScriptPath(scriptPath)

    // Log execution start
    logger.debug(`Executing script: ${scriptPath}`)
    logger.debug(`Arguments: ${args.join(' ')}`)
    logger.debug(`Timeout: ${timeout}ms`)

    try {
      // Execute with timeout
      const returnValue = await this.withTimeout(timeout, async () => {
        // Resolve script path relative to project root (where config was loaded)
        const projectRoot = context.projectRoot || process.cwd()
        const absolutePath = resolve(projectRoot, scriptPath)

        // Cache busting ensures we reload the script on each execution
        // WARNING: This creates a new module entry in the cache on each execution.
        // For CLI commands that run once and exit, this is acceptable and ensures
        // scripts are reloaded without process restart. However, in long-running
        // processes (watch mode, daemon), this will cause memory leaks as each unique
        // URL creates an uncached module entry. If used in long-running processes,
        // implement explicit cache clearing or use a different strategy.
        const cacheBustUrl = `${pathToFileURL(absolutePath).href}?t=${Date.now()}`

        // Dynamic import of the script module
        const scriptModule = await import(cacheBustUrl)

        // Check if script exports a main function
        if (typeof scriptModule.main !== 'function') {
          throw new ScriptExecutionError(
            scriptPath,
            new Error(`Script must export a 'main(args: string[], context: ScriptContext)' function`),
          )
        }

        // Build script context with logger and project root
        const scriptContext: ScriptContext = {
          logger,
          projectRoot,
          ...context, // Spread additional context (config, etc.)
        }

        // Execute the main function with args and context
        return await scriptModule.main(args, scriptContext)
      })

      logger.debug(`Script completed successfully: ${scriptPath}`)

      return {
        success: true,
        returnValue,
      }
    } catch (error) {
      const executionError = error instanceof Error ? error : new Error(String(error))

      // Check if it's a timeout
      if (executionError.name === 'ScriptTimeoutError') {
        throw executionError
      }

      logger.error(`Script execution failed: ${scriptPath}`)
      logger.error(executionError.message)

      // Show stack trace in debug mode
      if (executionError.stack) {
        logger.debug('Stack trace:')
        logger.debug(executionError.stack)
      }

      // Show helpful hint for debugging
      logger.info(`ðŸ’¡ Tip: Run with --verbose=1 for more details`)

      return {
        success: false,
        error: executionError,
      }
    }
  }

  /**
   * Execute a function with a timeout
   *
   * @param ms - Timeout in milliseconds
   * @param fn - Function to execute
   * @returns Promise<T>
   * @throws {ScriptTimeoutError} if timeout is exceeded
   */
  private withTimeout<T>(ms: number, fn: () => Promise<T>): Promise<T> {
    let timeoutHandle: ReturnType<typeof setTimeout> | undefined
    const timeoutPromise = new Promise<never>((_, reject) => {
      timeoutHandle = setTimeout(() => reject(new ScriptTimeoutError('script', ms)), ms)
    })

    return Promise.race([fn(), timeoutPromise]).then(
      (result) => {
        if (timeoutHandle) clearTimeout(timeoutHandle)
        return result
      },
      (error) => {
        if (timeoutHandle) clearTimeout(timeoutHandle)
        throw error
      },
    )
  }

  /**
   * Check if a script is a TypeScript file
   */
  isTypeScriptScript(script: ScriptConfig): script is { script: string } {
    return typeof script !== 'string' && 'script' in script
  }

  /**
   * Check if a script is a workflow YAML
   */
  isWorkflowScript(script: ScriptConfig): script is { workflow: string } {
    return typeof script !== 'string' && 'workflow' in script
  }

  /**
   * Check if a script is a shell command
   */
  isShellCommand(script: ScriptConfig): script is string | { command: string; description: string } {
    return typeof script === 'string' || (typeof script !== 'string' && 'command' in script)
  }
}
