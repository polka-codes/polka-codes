// generated by polka.codes

/**
 * Script execution runtime for custom TypeScript scripts
 *
 * Provides in-process execution of TypeScript scripts with:
 * - Dynamic module loading
 * - Timeout enforcement
 * - Error handling with stack traces
 * - Security validation
 */

import { existsSync } from 'node:fs'
import { relative, resolve } from 'node:path'
import { pathToFileURL } from 'node:url'
import type { Logger, ScriptConfig } from '@polka-codes/core'
import type { ExecutionContext } from '../runWorkflow'

/**
 * Error thrown when script validation fails
 */
export class ScriptValidationError extends Error {
  constructor(message: string) {
    super(`Script validation failed: ${message}`)
    this.name = 'ScriptValidationError'
  }
}

/**
 * Error thrown when script execution times out
 */
export class ScriptTimeoutError extends Error {
  constructor(scriptPath: string, timeout: number) {
    super(`Script execution timeout: ${scriptPath} exceeded ${timeout}ms`)
    this.name = 'ScriptTimeoutError'
  }
}

/**
 * Error thrown when script execution fails
 */
export class ScriptExecutionError extends Error {
  constructor(
    scriptPath: string,
    public cause: Error,
  ) {
    super(`Script execution failed: ${scriptPath}`)
    this.name = 'ScriptExecutionError'
    this.cause = cause
  }
}

/**
 * Options for script execution
 */
export interface ScriptRunnerOptions {
  /**
   * Path to the TypeScript script file
   */
  scriptPath: string

  /**
   * Command-line arguments to pass to the script
   */
  args: string[]

  /**
   * Execution context (for CLI options, etc.)
   */
  context: Partial<ExecutionContext>

  /**
   * Logger instance for output
   */
  logger: Logger

  /**
   * Execution timeout in milliseconds (default: 5 minutes)
   */
  timeout?: number
}

/**
 * Result of script execution
 */
export interface ScriptExecutionResult {
  /**
   * Whether the script executed successfully
   */
  success: boolean

  /**
   * Return value from the script (if any)
   */
  returnValue?: unknown

  /**
   * Error if execution failed
   */
  error?: Error
}

/**
 * Validates that a script path is safe to execute
 *
 * @param scriptPath - Path to the script file
 * @param projectRoot - Root directory of the project (defaults to cwd)
 * @throws {ScriptValidationError} if validation fails
 */
export function validateScriptPath(scriptPath: string, projectRoot: string = process.cwd()): void {
  // Normalize and resolve to absolute paths
  const normalizedRoot = resolve(projectRoot)
  const normalizedScript = resolve(projectRoot, scriptPath)

  // Check if path is within project directory (prevent path traversal)
  const relativePath = relative(normalizedRoot, normalizedScript)

  // Check for path traversal attempts (.. segments)
  if (relativePath.startsWith('..') || relativePath.includes('..')) {
    throw new ScriptValidationError(`Script path '${scriptPath}' is outside project directory`)
  }

  // Check if file exists
  if (!existsSync(normalizedScript)) {
    throw new ScriptValidationError(`Script file not found: ${scriptPath}`)
  }

  // Check file extension (must be .ts for ScriptRunner)
  if (!normalizedScript.endsWith('.ts')) {
    throw new ScriptValidationError(`Script must be .ts file: ${scriptPath}`)
  }
}

/**
 * Validates script permissions based on security configuration
 *
 * IMPORTANT: TypeScript scripts currently run with full process permissions.
 * Permission declarations in the config are ADVISORY ONLY for future sandboxing.
 * Scripts can access filesystem, network, and subprocesses regardless of declared permissions.
 *
 * @param script - Script configuration
 * @throws {ScriptValidationError} if permissions are invalid
 */
export function validateScriptPermissions(script: ScriptConfig): void {
  if (typeof script === 'string' || 'command' in script || 'workflow' in script) {
    // These types don't have permission checks
    return
  }

  if ('script' in script && script.permissions) {
    // Validate permission values
    const { fs, network, subprocess } = script.permissions

    if (fs && !['read', 'write', 'none'].includes(fs)) {
      throw new ScriptValidationError(`Invalid fs permission: ${fs}. Must be 'read', 'write', or 'none'`)
    }

    if (typeof network !== 'boolean' && network !== undefined) {
      throw new ScriptValidationError(`Invalid network permission: must be true or false`)
    }

    if (typeof subprocess !== 'boolean' && subprocess !== undefined) {
      throw new ScriptValidationError(`Invalid subprocess permission: must be true or false`)
    }
  }
}

/**
 * In-process script runner for TypeScript files
 *
 * Executes TypeScript scripts by dynamically importing them as modules.
 * Scripts should export a `main(args: string[])` function.
 *
 * **Important Limitations:**
 *
 * 1. **Synchronous Blocking**: The timeout mechanism uses `Promise.race()` which only
 *    handles timeouts for asynchronous operations. If a script performs a synchronous
 *    blocking operation (e.g., `while(true) {}`), the timeout will not trigger and the
 *    process will hang indefinitely. This is a known limitation of in-process script
 *    execution without using Worker threads or child processes.
 *
 * 2. **Path Resolution**: Script paths are resolved relative to `process.cwd()`. If the
 *    CLI is run from a subdirectory, script paths from config may not resolve correctly.
 *    The caller should ensure paths are absolute or relative to the correct working directory.
 *
 * @example
 * ```typescript
 * const runner = new ScriptRunner()
 * const result = await runner.execute({
 *   scriptPath: './scripts/deploy.ts',
 *   args: ['--production'],
 *   context: {},
 *   logger: createLogger({ verbose: 1 }),
 *   timeout: 60000
 * })
 * ```
 */
export class ScriptRunner {
  /**
   * Execute a TypeScript script
   *
   * @param options - Script execution options
   * @returns Promise<ScriptExecutionResult>
   * @throws {ScriptValidationError} if validation fails
   * @throws {ScriptTimeoutError} if execution times out
   * @throws {ScriptExecutionError} if execution fails
   */
  async execute(options: ScriptRunnerOptions): Promise<ScriptExecutionResult> {
    const { scriptPath, args, logger, timeout = 300000 } = options

    // Validate script path
    validateScriptPath(scriptPath)

    // Log execution start
    logger.debug(`Executing script: ${scriptPath}`)
    logger.debug(`Arguments: ${args.join(' ')}`)
    logger.debug(`Timeout: ${timeout}ms`)

    try {
      // Execute with timeout
      const returnValue = await this.withTimeout(timeout, async () => {
        // Use cache-busting query parameter for ESM module re-loading
        const absolutePath = resolve(process.cwd(), scriptPath)
        const cacheBustUrl = `${pathToFileURL(absolutePath).href}?t=${Date.now()}`

        // Dynamic import of the script module
        const scriptModule = await import(cacheBustUrl)

        // Check if script exports a main function
        if (typeof scriptModule.main !== 'function') {
          throw new ScriptExecutionError(scriptPath, new Error(`Script must export a 'main(args: string[])' function`))
        }

        // Execute the main function
        return await scriptModule.main(args)
      })

      logger.debug(`Script completed successfully: ${scriptPath}`)

      return {
        success: true,
        returnValue,
      }
    } catch (error) {
      const executionError = error instanceof Error ? error : new Error(String(error))

      // Check if it's a timeout
      if (executionError.name === 'ScriptTimeoutError') {
        throw executionError
      }

      logger.error(`Script execution failed: ${scriptPath}`)
      logger.error(executionError.message)

      // Show stack trace in debug mode
      if (executionError.stack) {
        logger.debug('Stack trace:')
        logger.debug(executionError.stack)
      }

      // Show helpful hint for debugging
      logger.info(`ðŸ’¡ Tip: Run with --verbose=1 for more details`)

      return {
        success: false,
        error: executionError,
      }
    }
  }

  /**
   * Execute a function with a timeout
   *
   * @param ms - Timeout in milliseconds
   * @param fn - Function to execute
   * @returns Promise<T>
   * @throws {ScriptTimeoutError} if timeout is exceeded
   */
  private withTimeout<T>(ms: number, fn: () => Promise<T>): Promise<T> {
    let timeoutHandle: ReturnType<typeof setTimeout> | undefined
    const timeoutPromise = new Promise<never>((_, reject) => {
      timeoutHandle = setTimeout(() => reject(new ScriptTimeoutError('script', ms)), ms)
    })

    return Promise.race([fn(), timeoutPromise]).then(
      (result) => {
        if (timeoutHandle) clearTimeout(timeoutHandle)
        return result
      },
      (error) => {
        if (timeoutHandle) clearTimeout(timeoutHandle)
        throw error
      },
    )
  }

  /**
   * Check if a script is a TypeScript file
   */
  isTypeScriptScript(script: ScriptConfig): script is { script: string } {
    return typeof script !== 'string' && 'script' in script
  }

  /**
   * Check if a script is a workflow YAML
   */
  isWorkflowScript(script: ScriptConfig): script is { workflow: string } {
    return typeof script !== 'string' && 'workflow' in script
  }

  /**
   * Check if a script is a shell command
   */
  isShellCommand(script: ScriptConfig): script is string | { command: string; description: string } {
    return typeof script === 'string' || (typeof script !== 'string' && 'command' in script)
  }
}
