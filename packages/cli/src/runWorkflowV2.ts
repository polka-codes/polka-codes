// generated by polka.codes

import os from 'node:os'
import { getProvider, printEvent } from '@polka-codes/cli-shared'
import type { AgentNameType } from '@polka-codes/core'
import { EnableCachePolicy, UsageMeter } from '@polka-codes/core'
import { type Logger, makeStepFn, type ToolHandler, type ToolRegistry, type WorkflowContext, type WorkflowFn } from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash-es'
import ora, { type Ora } from 'ora'
import { UserCancelledError } from './errors'
import { getModel } from './getModel'
import { getProviderOptions } from './getProviderOptions'
import { parseOptions } from './options'
import prices from './prices'
import { type AgentContextParameters, handleToolCall } from './tool-implementations'

type RunWorkflowV2Options = {
  commandName: string
  command: Command
  logger: Logger
  requiresProvider?: boolean
}

const makeStepFnWithSpinner = (spinner: Ora) => {
  const stepFn = makeStepFn()
  return async <T>(name: string, fn: () => Promise<T>): Promise<T> => {
    spinner.text = name
    return await stepFn(name, fn)
  }
}

export async function runWorkflowV2<TInput, TOutput, TTools extends ToolRegistry>(
  workflow: WorkflowFn<TInput, TOutput, TTools>,
  workflowInput: TInput,
  options: RunWorkflowV2Options,
): Promise<TOutput | undefined> {
  const { commandName, command, logger, requiresProvider = true } = options
  const globalOpts = (command.parent ?? command).opts()
  const { json } = globalOpts
  const { providerConfig, config, verbose } = parseOptions(globalOpts, {})

  if (requiresProvider) {
    const commandConfig = providerConfig.getConfigForCommand(commandName)
    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      logger.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
      process.exit(1)
    }
    logger.info('Provider:', commandConfig.provider)
    logger.info('Model:', commandConfig.model)
  }

  const spinner = ora({
    text: 'Running workflow...',
    ...(json && { stream: process.stderr }),
  }).start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), {
    maxMessages: config.maxMessageCount,
    maxCost: config.budget,
  })
  const onEvent = printEvent(verbose, usage, process.stderr)
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const agentConfig = providerConfig.getConfigForCommand(commandName)
  const model = agentConfig ? getModel(agentConfig) : undefined

  const providerOptions = agentConfig
    ? getProviderOptions({
        provider: agentConfig.provider,
        modelId: agentConfig.model,
        parameters: agentConfig.parameters,
      })
    : {}

  const parameters: AgentContextParameters = {
    toolFormat: config.toolFormat,
    os: os.platform(),
    policies: [EnableCachePolicy],
    modelParameters: agentConfig?.parameters,
    providerOptions,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  const toolHandler = new Proxy({} as ToolHandler<TTools>, {
    get: (_target, tool: string) => {
      return async (input: any) => {
        spinner.text = `Running tool: ${String(tool)}`
        return await handleToolCall(
          { tool: tool as any, input },
          {
            providerConfig,
            parameters,
            spinner,
            getModel: async (agent: AgentNameType) => {
              const config = providerConfig.getConfigForAgent(agent) || providerConfig.getConfigForCommand(commandName)
              if (!config) {
                throw new Error(`Could not get model config for agent ${agent} or command ${commandName}`)
              }
              return getModel(config)
            },
            model,
            agentCallback: onEvent,
            toolProvider,
            command,
          },
        )
      }
    },
  })

  const context: WorkflowContext<TTools> = {
    step: makeStepFnWithSpinner(spinner),
    logger,
    toolHandler,
  }

  try {
    const output = await workflow(workflowInput, context)
    spinner.succeed('Workflow completed successfully.')
    logger.info(usage.getUsageText())
    return output
  } catch (e) {
    const error = e as any
    if (error instanceof UserCancelledError) {
      spinner.warn('Workflow cancelled by user.')
    } else {
      spinner.fail(`Workflow failed: ${error.message}`)
      logger.error(error)
    }
    spinner.stop()
    logger.info(usage.getUsageText())
    return undefined
  }
}
