// generated by polka.codes

import { exec, execSync } from 'node:child_process'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { getProvider, printEvent } from '@polka-codes/cli-shared'
import {
  type AgentBase,
  type AgentContextParameters,
  AnalyzerAgent,
  ArchitectAgent,
  CodeFixerAgent,
  CoderAgent,
  EnableCachePolicy,
  parseJsonFromMarkdown,
  type SharedAgentOptions,
  type ToolResponse,
  ToolResponseType,
  UsageMeter,
} from '@polka-codes/core'
import type { AgentName, ToolSignature } from '@polka-codes/workflow'
import { type InvokeAgentTool, type PlainJson, run, type ToolCall, type Workflow } from '@polka-codes/workflow'
import type { Command } from 'commander'
import { merge } from 'lodash'
import ora from 'ora'
import type { ApiProviderConfig } from './ApiProviderConfig'
import { getModel } from './getModel'
import { parseOptions } from './options'
import prices from './prices'

const agentRegistry: Record<string, new (options: SharedAgentOptions) => AgentBase> = {
  analyzer: AnalyzerAgent,
  architect: ArchitectAgent,
  coder: CoderAgent,
  codefixer: CodeFixerAgent,
}

class WorkflowAgent extends CoderAgent {
  protected onBeforeInvokeTool(_name: string, _args: Record<string, string>): Promise<ToolResponse | undefined> {
    return Promise.resolve(undefined)
  }
}

type Tools = {
  invokeAgent: InvokeAgentTool
  createPullRequest: ToolSignature<{ title: string; description: string }, { title: string; description: string }>
}

async function handleToolCall(
  toolCall: ToolCall<Tools>,
  context: {
    providerConfig: ApiProviderConfig
    parameters: AgentContextParameters
    getModel: (name: AgentName) => Promise<LanguageModelV2>
    agentCallback?: (event: any) => void
    toolProvider: any // ToolProvider
  },
) {
  switch (toolCall.tool) {
    case 'invokeAgent': {
      const input = toolCall.input
      const model = await context.getModel(input.agent)

      const AgentClass = agentRegistry[input.agent] ?? WorkflowAgent

      const agent = new AgentClass({
        ai: model,
        os: context.parameters.os ?? 'linux',
        provider: context.toolProvider,
        toolFormat: context.parameters.toolFormat ?? 'native',
        policies: context.parameters.policies ?? [],
        usageMeter: context.parameters.usageMeter,
        parameters: context.parameters.modelParameters,
        scripts: context.parameters.scripts,
        callback: context.agentCallback,
        requireToolUse: false,
        retryCount: context.parameters.retryCount,
        requestTimeoutSeconds: context.parameters.requestTimeoutSeconds,
      })

      const userPrompt = input.messages
        .filter((m) => typeof m === 'string' || m.type !== 'system')
        .map((m) => (typeof m === 'string' ? m : m.content))
        .join('\n\n')

      const exitReason = await agent.start(userPrompt)

      if (exitReason.type !== ToolResponseType.Exit) {
        throw new Error(`Agent exited for an unhandled reason: ${JSON.stringify(exitReason)}`)
      }

      const parsed = parseJsonFromMarkdown(exitReason.message)
      if (!parsed.success) {
        throw new Error(parsed.error)
      }
      const validated = input.outputSchema.safeParse(parsed.data)
      if (!validated.success) {
        throw new Error(validated.error.message)
      }
      return validated.data
    }
    case 'createPullRequest': {
      const { title, description } = toolCall.input as { title: string; description: string }
      const cmd = `gh pr create --title "${title.replaceAll('"', '\\"')}" --body "${description.replaceAll('"', '\\"')}"`
      return new Promise((resolve, reject) => {
        exec(cmd, (err, stdout, stderr) => {
          if (err) {
            console.error(stderr)
            return reject(err)
          }
          console.log(stdout)
          resolve(toolCall.input)
        })
      })
    }
    default:
      throw new Error(`Unknown tool: ${String((toolCall as any).tool)}`)
  }
}

export async function runWorkflowV2<TInput extends PlainJson, TOutput extends PlainJson>(
  commandName: 'pr',
  workflow: Workflow<TInput, TOutput, Tools>,
  command: Command,
  workflowInput: TInput,
) {
  const parentOptions = command.parent?.opts() ?? {}
  const { providerConfig, config, verbose } = parseOptions(parentOptions)
  const commandConfig = providerConfig.getConfigForCommand(commandName)
  if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
    console.error(`Error: No provider specified for ${commandName}. Please run "polka config" to configure your AI provider.`)
    process.exit(1)
  }

  console.log('Provider:', commandConfig.provider)
  console.log('Model:', commandConfig.model)

  const spinner = ora('Running workflow...').start()

  const usage = new UsageMeter(merge(prices, config.prices ?? {}), { maxMessages: config.maxMessageCount, maxCost: config.budget })
  const onEvent = verbose > 0 ? printEvent(verbose, usage, console) : undefined
  const toolProvider = getProvider({ excludeFiles: config.excludeFiles })

  const agentConfig = providerConfig.getConfigForCommand(commandName)

  const parameters: AgentContextParameters = {
    toolFormat: config.toolFormat,
    os: execSync('uname -s', { encoding: 'utf-8' }).trim(),
    policies: [EnableCachePolicy],
    modelParameters: agentConfig?.parameters,
    scripts: config.scripts,
    retryCount: config.retryCount,
    requestTimeoutSeconds: config.requestTimeoutSeconds,
    usageMeter: usage,
  }

  let result = await run(workflow, workflowInput)

  while (result.status === 'pending') {
    spinner.text = `Running tool: ${String(result.tool.tool)}`
    try {
      const toolResult = await handleToolCall(result.tool, {
        providerConfig,
        parameters,
        getModel: async (agent: AgentName) => {
          const config = providerConfig.getConfigForAgent(agent) || providerConfig.getConfigForCommand(commandName)
          if (!config) {
            throw new Error(`Could not get model config for agent ${agent} or command ${commandName}`)
          }
          return getModel(config)
        },
        agentCallback: onEvent,
        toolProvider,
      })
      result = await result.next(toolResult)
    } catch (e) {
      result = { status: 'failed', error: e }
    }
  }

  spinner.stop()

  if (result.status === 'completed') {
    console.log('Workflow completed successfully.')
    console.log('Output:', result.output)
  } else if (result.status === 'failed') {
    console.error('Workflow failed:', result.error)
    process.exit(1)
  }

  usage.printUsage()
}
