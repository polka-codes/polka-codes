// generated by polka.codes

import { mkdir, readFile, writeFile } from 'node:fs/promises'
import { dirname, resolve } from 'node:path'
import {
  type Config,
  detectProjectScope,
  getGlobalConfigPath,
  loadConfigAtPath,
  MemoryManager,
  SQLiteMemoryStore,
} from '@polka-codes/cli-shared'
import { DEFAULT_MEMORY_CONFIG, type MemoryQuery, resolveHomePath } from '@polka-codes/core'
import type { Command } from 'commander'

/**
 * Get memory store instance
 * @internal Exported for testing purposes
 */
export async function getMemoryStore() {
  const globalConfigPath = getGlobalConfigPath()
  const config = (await loadConfigAtPath(globalConfigPath)) as Config | null
  const memoryConfig = config?.memory || DEFAULT_MEMORY_CONFIG

  if (!memoryConfig.enabled || memoryConfig.type === 'memory') {
    console.error('Memory store is not enabled. Enable it in config with memory.enabled: true')
    process.exit(1)
  }

  const cwd = process.cwd()

  // Detect scope once and pass to SQLite store using shared utility
  const scope = detectProjectScope(cwd)

  // Create SQLite store implementation with scope
  const sqliteStore = new SQLiteMemoryStore(memoryConfig, scope)

  // Wrap with MemoryManager for core logic
  return new MemoryManager(sqliteStore)
}

/**
 * List memory entries
 */
export async function memoryList(options: {
  type?: string
  status?: string
  priority?: string
  tags?: string
  search?: string
  limit?: number
  offset?: number
  sortBy?: string
  sortOrder?: string
  format?: 'json' | 'table'
}) {
  const store = await getMemoryStore()

  try {
    const query: MemoryQuery = {
      scope: 'auto',
    }

    if (options.type) query.type = options.type
    if (options.status) query.status = options.status
    if (options.priority) query.priority = options.priority
    if (options.tags) query.tags = options.tags.split(',')
    if (options.search) query.search = options.search
    if (options.limit) query.limit = options.limit
    if (options.offset) query.offset = options.offset
    if (options.sortBy) query.sortBy = options.sortBy as 'created' | 'updated' | 'accessed' | 'name'
    if (options.sortOrder) query.sortOrder = options.sortOrder as 'asc' | 'desc'

    const entries = await store.queryMemory(query, { operation: 'select' })

    if (options.format === 'json') {
      console.log(JSON.stringify(entries, null, 2))
    } else {
      // Table format
      if (!Array.isArray(entries) || entries.length === 0) {
        console.log('No entries found.')
        return
      }

      console.log('\nMemory Entries:')
      console.log('─'.repeat(80))
      for (const entry of entries) {
        console.log(`\nName: ${entry.name}`)
        console.log(`Type: ${entry.entry_type}`)
        console.log(`Status: ${entry.status || 'N/A'}`)
        console.log(`Priority: ${entry.priority || 'N/A'}`)
        console.log(`Tags: ${entry.tags || 'N/A'}`)
        console.log(`Updated: ${new Date(entry.updated_at).toLocaleString()}`)
        console.log(`Content:\n${entry.content}`)
        console.log('─'.repeat(80))
      }
      console.log(`\nTotal: ${entries.length} entries`)
    }
  } finally {
    store.close()
  }
}

/**
 * Read a specific memory entry
 */
export async function memoryRead(name: string, options: { format?: 'json' | 'text' }) {
  const store = await getMemoryStore()

  try {
    const content = await store.readMemory(name)

    if (!content) {
      console.error(`Memory entry "${name}" not found.`)
      process.exit(1)
    }

    if (options.format === 'json') {
      console.log(JSON.stringify({ name, content }, null, 2))
    } else {
      console.log(content)
    }
  } finally {
    store.close()
  }
}

/**
 * Delete a memory entry
 */
export async function memoryDelete(name: string, options: { force?: boolean }) {
  if (!options.force) {
    console.log(`Are you sure you want to delete memory entry "${name}"?`)
    console.log('This action cannot be undone.')
    console.log('Use --force to skip this confirmation.')
    process.exit(1)
  }

  const store = await getMemoryStore()

  try {
    await store.updateMemory('remove', name, undefined)
    console.log(`Memory entry "${name}" deleted.`)
  } finally {
    store.close()
  }
}

/**
 * Rename a memory entry
 */
export async function memoryRename(oldName: string, newName: string) {
  const store = await getMemoryStore()

  try {
    // Use transaction to atomically check for newName, fetch oldEntry, and perform rename
    // This prevents race conditions where concurrent processes could modify data
    await store.transaction(async () => {
      // Check if old entry exists (within transaction for consistency)
      const oldEntries = await store.queryMemory({ name: oldName }, { operation: 'select' })
      if (!Array.isArray(oldEntries) || oldEntries.length === 0) {
        throw new Error(`Memory entry "${oldName}" not found.`)
      }

      const oldEntry = oldEntries[0]

      // Check if new name already exists (within transaction for consistency)
      const newEntries = await store.queryMemory({ name: newName }, { operation: 'select' })
      if (Array.isArray(newEntries) && newEntries.length > 0) {
        throw new Error(`Memory entry "${newName}" already exists.`)
      }

      // Perform the rename
      await store.batchUpdateMemory([
        {
          operation: 'replace',
          name: newName,
          content: oldEntry.content,
          metadata: {
            entry_type: oldEntry.entry_type,
            status: oldEntry.status,
            priority: oldEntry.priority,
            tags: oldEntry.tags,
          },
        },
        { operation: 'remove', name: oldName },
      ])
    })

    console.log(`Memory entry renamed from "${oldName}" to "${newName}".`)
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes('already exists') || error.message.includes('not found')) {
        console.error(error.message)
        process.exit(1)
      }
    }
    throw error
  } finally {
    store.close()
  }
}

/**
 * Export memory to JSON
 */
export async function memoryExport(options: { output?: string; type?: string; scope?: 'global' | 'project'; format?: 'json' }) {
  const store = await getMemoryStore()

  try {
    const query: MemoryQuery = {}

    if (options.type) query.type = options.type
    if (options.scope === 'global') {
      query.scope = 'global'
    } else if (options.scope === 'project') {
      query.scope = 'project'
    } else {
      query.scope = 'auto'
    }

    const entries = await store.queryMemory(query, { operation: 'select' })

    if (!Array.isArray(entries)) {
      console.error('Failed to export: query did not return entries')
      return
    }

    const outputPath = options.output ? resolve(process.cwd(), options.output) : resolve(process.cwd(), `memory-export-${Date.now()}.json`)

    // Ensure directory exists
    await mkdir(dirname(outputPath), { recursive: true })

    await writeFile(outputPath, JSON.stringify(entries, null, 2))
    console.log(`Exported ${entries.length} entries to ${outputPath}`)
  } finally {
    store.close()
  }
}

/**
 * Import memory from JSON
 */
export async function memoryImport(inputFile: string, options: { merge?: boolean; format?: 'json' }) {
  const store = await getMemoryStore()

  try {
    const inputPath = resolve(process.cwd(), inputFile)
    const data = await readFile(inputPath, 'utf-8')

    let entries: unknown
    try {
      entries = JSON.parse(data)
    } catch (error) {
      console.error(`Failed to parse JSON from ${inputPath}:`, error)
      process.exit(1)
    }

    if (!Array.isArray(entries)) {
      console.error('Invalid import file format. Expected an array of memory entries.')
      process.exit(1)
    }

    // Collect all valid entries first, then batch import for better performance
    const validEntries: Array<{
      operation: 'replace'
      name: string
      content: string
      metadata?: {
        entry_type?: string
        status?: string
        priority?: string
        tags?: string
        created_at?: number
        updated_at?: number
        last_accessed?: number
      }
    }> = []
    const validPriorities = ['low', 'medium', 'high', 'critical'] as const
    let skipped = 0

    // If not merging, we need to check for existing entries upfront
    const existingNames = new Set<string>()
    if (!options.merge) {
      const allEntries = await store.queryMemory({}, { operation: 'select' })
      if (Array.isArray(allEntries)) {
        for (const entry of allEntries) {
          existingNames.add(entry.name)
        }
      }
    }

    for (const entry of entries as unknown[]) {
      try {
        // Validate that entry is an object
        if (typeof entry !== 'object' || entry === null) {
          console.error('Skipping invalid entry: not an object')
          skipped++
          continue
        }

        const entryObj = entry as Record<string, unknown>

        // Validate required fields
        if (!entryObj.name || typeof entryObj.name !== 'string') {
          console.error('Skipping invalid entry: missing or invalid name')
          skipped++
          continue
        }

        const entryName = entryObj.name

        if (!entryObj.content || typeof entryObj.content !== 'string') {
          console.error(`Skipping entry "${entryName}": missing or invalid content`)
          skipped++
          continue
        }

        // Check if entry already exists (when not merging)
        if (existingNames.has(entryName)) {
          skipped++
          continue
        }

        // Validate priority if present
        let priority = entryObj.priority as string | undefined
        if (priority && !validPriorities.includes(priority as 'low' | 'medium' | 'high' | 'critical')) {
          console.warn(`Entry "${entryName}" has invalid priority "${priority}", defaulting to null`)
          priority = undefined
        }

        // Validate and cast metadata fields
        const entryType = entryObj.entry_type
        const validatedEntryType = typeof entryType === 'string' ? entryType : 'note'

        const status = entryObj.status
        const validatedStatus = typeof status === 'string' ? status : undefined

        const tags = entryObj.tags
        const validatedTags = typeof tags === 'string' ? tags : undefined

        // Preserve timestamps if available
        const createdAt = entryObj.created_at
        const validatedCreatedAt = typeof createdAt === 'number' ? createdAt : undefined

        const updatedAt = entryObj.updated_at
        const validatedUpdatedAt = typeof updatedAt === 'number' ? updatedAt : undefined

        const lastAccessed = entryObj.last_accessed
        const validatedLastAccessed = typeof lastAccessed === 'number' ? lastAccessed : undefined

        validEntries.push({
          operation: 'replace',
          name: entryName,
          content: entryObj.content as string,
          metadata: {
            entry_type: validatedEntryType,
            status: validatedStatus,
            priority: priority,
            tags: validatedTags,
            created_at: validatedCreatedAt,
            updated_at: validatedUpdatedAt,
            last_accessed: validatedLastAccessed,
          },
        })
      } catch (error) {
        console.error(`Failed to process entry:`, error)
        skipped++
      }
    }

    // Batch import all valid entries in a single transaction
    if (validEntries.length > 0) {
      await store.batchUpdateMemory(validEntries)
    }

    console.log(`Imported ${validEntries.length} entries, skipped ${skipped} entries.`)
  } finally {
    store.close()
  }
}

/**
 * Show memory statistics
 */
export async function memoryStatus() {
  const store = await getMemoryStore()

  try {
    const stats = await store.getStats()

    const globalConfigPath = getGlobalConfigPath()
    const config = (await loadConfigAtPath(globalConfigPath)) as Config | null
    const memoryConfig = config?.memory || { path: '~/.config/polka-codes/memory.sqlite' }
    const dbPath = resolveHomePath(memoryConfig.path || '~/.config/polka-codes/memory.sqlite')

    console.log('\nMemory Store Status:')
    console.log('─'.repeat(80))
    console.log(`Database: ${dbPath}`)
    console.log(`Total entries: ${stats.totalEntries}`)
    console.log(`Database size: ${(stats.databaseSize / 1024).toFixed(2)} KB`)
    console.log('\nEntries by type:')

    for (const [type, count] of Object.entries(stats.entriesByType)) {
      console.log(`  ${type}: ${count}`)
    }

    console.log('─'.repeat(80))
  } finally {
    store.close()
  }
}

/**
 * Register memory commands
 */
export function registerMemoryCommands(program: Command) {
  const memoryCmd = program.command('memory').description('Memory management commands')

  memoryCmd
    .command('list')
    .description('List memory entries')
    .option('--type <type>', 'Filter by type')
    .option('--status <status>', 'Filter by status')
    .option('--priority <priority>', 'Filter by priority')
    .option('--tags <tags>', 'Filter by tags (comma-separated)')
    .option('--search <term>', 'Search in content and name')
    .option('--limit <number>', 'Limit results', parseInt)
    .option('--offset <number>', 'Offset results', parseInt)
    .option('--sort-by <field>', 'Sort by field (created, updated, accessed, name)')
    .option('--sort-order <order>', 'Sort order (asc, desc)', 'desc')
    .option('--format <format>', 'Output format (json, table)', 'table')
    .action(async (options) => {
      await memoryList(options)
    })

  memoryCmd
    .command('read <name>')
    .description('Read a specific memory entry')
    .option('--format <format>', 'Output format (json, text)', 'text')
    .action(async (name, options) => {
      await memoryRead(name, options)
    })

  memoryCmd
    .command('delete <name>')
    .description('Delete a memory entry')
    .option('--force', 'Skip confirmation')
    .action(async (name, options) => {
      await memoryDelete(name, options)
    })

  memoryCmd
    .command('rename <oldName> <newName>')
    .description('Rename a memory entry')
    .action(async (oldName, newName) => {
      await memoryRename(oldName, newName)
    })

  memoryCmd
    .command('export')
    .description('Export memory to JSON')
    .option('--output <file>', 'Output file path')
    .option('--type <type>', 'Filter by type')
    .option('--scope <scope>', 'Filter by scope (global, project)')
    .action(async (options) => {
      await memoryExport(options)
    })

  memoryCmd
    .command('import <file>')
    .description('Import memory from JSON')
    .option('--merge', 'Overwrite existing entries during import (default: skip existing entries)')
    .action(async (file, options) => {
      await memoryImport(file, options)
    })

  memoryCmd
    .command('status')
    .description('Show memory statistics')
    .action(async () => {
      await memoryStatus()
    })
}
