// generated by polka.codes
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import { dirname, resolve } from 'node:path'
import { type Config, getGlobalConfigPath, loadConfigAtPath, MemoryManager, SQLiteMemoryStore } from '@polka-codes/cli-shared'
import type { MemoryQuery } from '@polka-codes/core'
import { resolveHomePath } from '@polka-codes/core'
import type { Command } from 'commander'

/**
 * Get memory store instance
 */
async function getMemoryStore() {
  const globalConfigPath = getGlobalConfigPath()
  const config = (await loadConfigAtPath(globalConfigPath)) as Config | null
  const memoryConfig = config?.memory || { enabled: true, type: 'sqlite', path: '~/.config/polka-codes/memory.sqlite' }

  if (!memoryConfig.enabled || memoryConfig.type === 'memory') {
    console.error('Memory store is not enabled. Enable it in config with memory.enabled: true')
    process.exit(1)
  }

  const cwd = process.cwd()

  // Detect scope once and pass to SQLite store
  const scope = detectProjectScope(cwd)

  // Create SQLite store implementation with scope
  const sqliteStore = new SQLiteMemoryStore(memoryConfig, scope)

  // Wrap with MemoryManager for core logic
  return new MemoryManager(sqliteStore, cwd)
}

/**
 * Detect project scope from current working directory
 */
function detectProjectScope(cwd: string): string {
  const { resolve, dirname, join } = require('node:path')
  const { existsSync } = require('node:fs')

  const projectPath = findProjectRoot(cwd)

  if (!projectPath) {
    return 'global'
  }

  const normalizedPath = normalizePath(projectPath)
  return `project:${normalizedPath}`

  function findProjectRoot(dir: string): string | null {
    let currentDir = resolve(dir)

    while (currentDir !== '/') {
      const configPath = join(currentDir, '.polkacodes.yml')

      if (existsSync(configPath)) {
        return currentDir
      }

      const parentDir = dirname(currentDir)
      if (parentDir === currentDir) break
      currentDir = parentDir

      // Safety: don't search too high
      if (currentDir.split(require('node:path').sep).length < 3) break
    }

    return null
  }

  function normalizePath(path: string): string {
    const normalized = resolve(path).replace(/\/$/, '')
    if (normalized.includes('..')) {
      throw new Error(`Path contains parent directory references: ${path}`)
    }
    return normalized
  }
}

/**
 * List memory entries
 */
export async function memoryList(options: {
  type?: string
  status?: string
  priority?: string
  tags?: string
  search?: string
  limit?: number
  offset?: number
  sortBy?: string
  sortOrder?: string
  format?: 'json' | 'table'
}) {
  const store = await getMemoryStore()

  try {
    const query: MemoryQuery = {
      scope: 'auto',
    }

    if (options.type) query.type = options.type
    if (options.status) query.status = options.status
    if (options.priority) query.priority = options.priority
    if (options.tags) query.tags = options.tags.split(',')
    if (options.search) query.search = options.search
    if (options.limit) query.limit = options.limit
    if (options.offset) query.offset = options.offset
    if (options.sortBy) query.sortBy = options.sortBy as any
    if (options.sortOrder) query.sortOrder = options.sortOrder as any

    const entries = await store.queryMemory(query, { operation: 'select' })

    if (options.format === 'json') {
      console.log(JSON.stringify(entries, null, 2))
    } else {
      // Table format
      if (entries.length === 0) {
        console.log('No entries found.')
        return
      }

      console.log('\nMemory Entries:')
      console.log('─'.repeat(80))
      for (const entry of entries as any[]) {
        console.log(`\nName: ${entry.name}`)
        console.log(`Type: ${entry.entry_type}`)
        console.log(`Status: ${entry.status || 'N/A'}`)
        console.log(`Priority: ${entry.priority || 'N/A'}`)
        console.log(`Tags: ${entry.tags || 'N/A'}`)
        console.log(`Updated: ${new Date(entry.updated_at).toLocaleString()}`)
        console.log(`Content:\n${entry.content}`)
        console.log('─'.repeat(80))
      }
      console.log(`\nTotal: ${entries.length} entries`)
    }
  } finally {
    store.close()
  }
}

/**
 * Read a specific memory entry
 */
export async function memoryRead(name: string, options: { format?: 'json' | 'text' }) {
  const store = await getMemoryStore()

  try {
    const content = await store.readMemory(name)

    if (!content) {
      console.error(`Memory entry "${name}" not found.`)
      process.exit(1)
    }

    if (options.format === 'json') {
      console.log(JSON.stringify({ name, content }, null, 2))
    } else {
      console.log(content)
    }
  } finally {
    store.close()
  }
}

/**
 * Delete a memory entry
 */
export async function memoryDelete(name: string, options: { force?: boolean }) {
  if (!options.force) {
    console.log(`Are you sure you want to delete memory entry "${name}"?`)
    console.log('This action cannot be undone.')
    console.log('Use --force to skip this confirmation.')
    process.exit(1)
  }

  const store = await getMemoryStore()

  try {
    await store.updateMemory('remove', name, undefined)
    console.log(`Memory entry "${name}" deleted.`)
  } finally {
    store.close()
  }
}

/**
 * Rename a memory entry
 */
export async function memoryRename(oldName: string, newName: string) {
  const store = await getMemoryStore()

  try {
    // Read old entry
    const oldContent = await store.readMemory(oldName)
    if (!oldContent) {
      console.error(`Memory entry "${oldName}" not found.`)
      process.exit(1)
    }

    // Check if new name already exists
    const newContent = await store.readMemory(newName)
    if (newContent) {
      console.error(`Memory entry "${newName}" already exists.`)
      process.exit(1)
    }

    // Create new entry with old content
    await store.updateMemory('replace', newName, oldContent)

    // Delete old entry
    await store.updateMemory('remove', oldName, undefined)

    console.log(`Memory entry renamed from "${oldName}" to "${newName}".`)
  } finally {
    store.close()
  }
}

/**
 * Export memory to JSON
 */
export async function memoryExport(options: { output?: string; type?: string; scope?: 'global' | 'project'; format?: 'json' }) {
  const store = await getMemoryStore()

  try {
    const query: MemoryQuery = {}

    if (options.type) query.type = options.type
    if (options.scope === 'global') {
      query.scope = 'global'
    } else if (options.scope === 'project') {
      query.scope = 'project'
    } else {
      query.scope = 'auto'
    }

    const entries = await store.queryMemory(query, { operation: 'select' })

    const outputPath = options.output ? resolve(process.cwd(), options.output) : resolve(process.cwd(), `memory-export-${Date.now()}.json`)

    // Ensure directory exists
    await mkdir(dirname(outputPath), { recursive: true })

    await writeFile(outputPath, JSON.stringify(entries, null, 2))
    console.log(`Exported ${entries.length} entries to ${outputPath}`)
  } finally {
    store.close()
  }
}

/**
 * Import memory from JSON
 */
export async function memoryImport(inputFile: string, options: { merge?: boolean; format?: 'json' }) {
  const store = await getMemoryStore()

  try {
    const inputPath = resolve(process.cwd(), inputFile)
    const data = await readFile(inputPath, 'utf-8')

    let entries: unknown
    try {
      entries = JSON.parse(data)
    } catch (error) {
      console.error(`Failed to parse JSON from ${inputPath}:`, error)
      process.exit(1)
    }

    if (!Array.isArray(entries)) {
      console.error('Invalid import file format. Expected an array of memory entries.')
      process.exit(1)
    }

    let imported = 0
    let skipped = 0

    for (const entry of entries) {
      try {
        // Validate required fields
        if (!entry.name || typeof entry.name !== 'string') {
          console.error('Skipping invalid entry: missing or invalid name')
          skipped++
          continue
        }

        if (!entry.content || typeof entry.content !== 'string') {
          console.error(`Skipping entry "${entry.name}": missing or invalid content`)
          skipped++
          continue
        }

        // Validate priority if present
        const validPriorities = ['low', 'medium', 'high', 'critical']
        let priority = entry.priority
        if (priority && !validPriorities.includes(priority)) {
          console.warn(`Entry "${entry.name}" has invalid priority "${priority}", defaulting to null`)
          priority = null
        }

        // Check if entry already exists
        const existing = await store.readMemory(entry.name)

        if (existing && !options.merge) {
          skipped++
          continue
        }

        await store.updateMemory('replace', entry.name, entry.content, {
          entry_type: entry.entry_type || 'note',
          status: entry.status,
          priority: priority,
          tags: entry.tags,
        })

        imported++
      } catch (error) {
        console.error(`Failed to import entry "${entry.name}":`, error)
        skipped++
      }
    }

    console.log(`Imported ${imported} entries, skipped ${skipped} entries.`)
  } finally {
    store.close()
  }
}

/**
 * Show memory statistics
 */
export async function memoryStatus() {
  const store = await getMemoryStore()

  try {
    const stats = await store.getStats()

    const globalConfigPath = getGlobalConfigPath()
    const config = (await loadConfigAtPath(globalConfigPath)) as Config | null
    const memoryConfig = config?.memory || { path: '~/.config/polka-codes/memory.sqlite' }
    const dbPath = resolveHomePath(memoryConfig.path || '~/.config/polka-codes/memory.sqlite')

    console.log('\nMemory Store Status:')
    console.log('─'.repeat(80))
    console.log(`Database: ${dbPath}`)
    console.log(`Total entries: ${stats.totalEntries}`)
    console.log(`Database size: ${(stats.databaseSize / 1024).toFixed(2)} KB`)
    console.log('\nEntries by type:')

    for (const [type, count] of Object.entries(stats.entriesByType)) {
      console.log(`  ${type}: ${count}`)
    }

    console.log('─'.repeat(80))
  } finally {
    store.close()
  }
}

/**
 * Register memory commands
 */
export function registerMemoryCommands(program: Command) {
  const memoryCmd = program.command('memory').description('Memory management commands')

  memoryCmd
    .command('list')
    .description('List memory entries')
    .option('--type <type>', 'Filter by type')
    .option('--status <status>', 'Filter by status')
    .option('--priority <priority>', 'Filter by priority')
    .option('--tags <tags>', 'Filter by tags (comma-separated)')
    .option('--search <term>', 'Search in content and name')
    .option('--limit <number>', 'Limit results', parseInt)
    .option('--offset <number>', 'Offset results', parseInt)
    .option('--sort-by <field>', 'Sort by field (created, updated, accessed, name)')
    .option('--sort-order <order>', 'Sort order (asc, desc)', 'desc')
    .option('--format <format>', 'Output format (json, table)', 'table')
    .action(async (options) => {
      await memoryList(options)
    })

  memoryCmd
    .command('read <name>')
    .description('Read a specific memory entry')
    .option('--format <format>', 'Output format (json, text)', 'text')
    .action(async (name, options) => {
      await memoryRead(name, options)
    })

  memoryCmd
    .command('delete <name>')
    .description('Delete a memory entry')
    .option('--force', 'Skip confirmation')
    .action(async (name, options) => {
      await memoryDelete(name, options)
    })

  memoryCmd
    .command('rename <oldName> <newName>')
    .description('Rename a memory entry')
    .action(async (oldName, newName) => {
      await memoryRename(oldName, newName)
    })

  memoryCmd
    .command('export')
    .description('Export memory to JSON')
    .option('--output <file>', 'Output file path')
    .option('--type <type>', 'Filter by type')
    .option('--scope <scope>', 'Filter by scope (global, project)')
    .action(async (options) => {
      await memoryExport(options)
    })

  memoryCmd
    .command('import <file>')
    .description('Import memory from JSON')
    .option('--merge', 'Merge with existing data (skip conflicts)')
    .action(async (file, options) => {
      await memoryImport(file, options)
    })

  memoryCmd
    .command('status')
    .description('Show memory statistics')
    .action(async () => {
      await memoryStatus()
    })
}
