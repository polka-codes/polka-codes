/**
 * Initialize polkacodes configuration command.
 * Generated by polka.codes
 */

import { existsSync, readFileSync, writeFileSync } from 'node:fs'
import { confirm, select } from '@inquirer/prompts'
import { type Config, getGlobalConfigPath, loadConfigAtPath, localConfigFileName, readConfig } from '@polka-codes/cli-shared'
import { Command } from 'commander'
import { set } from 'lodash-es'
import { stringify } from 'yaml'
import { configPrompt } from '../configPrompt'
import { createLogger } from '../logger'
import { runWorkflow } from '../runWorkflow'
import { initWorkflow } from '../workflows/init.workflow'

export const initCommand = new Command('init')
  .description('Initialize polkacodes configuration')
  .option('-g, --global', 'Use global config')
  .action(async (options, command: Command) => {
    const globalOpts = (command.parent ?? command).opts()
    const { verbose, yes } = globalOpts
    const logger = createLogger({
      verbose: verbose,
    })

    const interactive = !yes

    const globalConfigPath = getGlobalConfigPath()
    let isGlobal = options.global ?? false
    let configPath = isGlobal ? globalConfigPath : localConfigFileName

    const exists = existsSync(configPath)

    if (exists) {
      if (interactive) {
        const proceed = await confirm({
          message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
          default: false,
        })
        if (!proceed) {
          logger.info('User cancelled')
          return
        }
      }
    } else if (!options.global) {
      if (interactive) {
        const location = await select({
          message: 'No config file found. Do you want to create one?',
          choices: [
            { name: `Create a global config at ${globalConfigPath}`, value: 'global' },
            { name: `Create a local config at ${configPath}`, value: 'local' },
          ],
        })
        if (location === 'global') {
          isGlobal = true
          configPath = globalConfigPath
        }
      }
    }

    logger.info(`Config file path: ${configPath}`)

    let existingConfig: Config = {}
    try {
      existingConfig = readConfig(configPath)
    } catch (error) {
      logger.error(`Unable to parse config file: ${configPath}`, error)
      process.exit(1)
    }

    const providerConfig = await configPrompt({})
    const { provider, model, apiKey } = providerConfig

    if (apiKey && !isGlobal) {
      let option = 'local'
      if (interactive) {
        option = await select({
          message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
          choices: [
            { name: 'Save API key in the local config file', value: 'local' },
            { name: 'Save API key in the global config file', value: 'global' },
            { name: 'Save API key to .env file', value: 'env' },
          ],
        })
      }

      switch (option) {
        case 'local':
          break
        case 'global': {
          const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
          set(globalConfig, ['providers', provider, 'apiKey'], apiKey)
          writeFileSync(globalConfigPath, stringify(globalConfig))
          logger.info(`API key saved to global config file: ${globalConfigPath}`)
          providerConfig.apiKey = undefined
          break
        }
        case 'env': {
          let envFileContent = ''
          const envExists = existsSync('.env')
          if (envExists) {
            envFileContent = readFileSync('.env', 'utf-8')
            if (!envFileContent.endsWith('\n')) envFileContent += '\n'
          }
          envFileContent += `${provider.toUpperCase()}_API_KEY=${apiKey}\n`
          writeFileSync('.env', envFileContent)
          logger.info('API key saved to .env file')
          providerConfig.apiKey = undefined
          break
        }
      }
    }

    const finalConfig: Config = {
      ...existingConfig,
      defaultProvider: provider,
      defaultModel: model,
    }

    if (!finalConfig.providers) {
      finalConfig.providers = {}
    }

    if (providerConfig.apiKey) {
      set(finalConfig, ['providers', provider, 'apiKey'], providerConfig.apiKey)
    }

    writeFileSync(configPath, stringify(finalConfig))
    logger.info(`Configuration saved to ${configPath}`)

    let shouldAnalyze = false
    if (!isGlobal && interactive) {
      shouldAnalyze = await confirm({
        message: 'Would you like to analyze the project to generate recommended configuration?',
        default: false,
      })
    }

    if (shouldAnalyze) {
      await runWorkflow(
        initWorkflow,
        {
          configPath,
        },
        {
          commandName: 'init',
          command,
          logger,
          requiresProvider: true,
        },
      )
    }
  })
