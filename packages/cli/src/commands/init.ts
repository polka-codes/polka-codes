/**
 * Initialize polkacodes configuration command.
 * Generated by polka.codes
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import { confirm, input, select } from '@inquirer/prompts'
import { type Config, getGlobalConfigPath, loadConfigAtPath, localConfigFileName, readConfig } from '@polka-codes/cli-shared'
import type { Logger } from '@polka-codes/core'
import { Command } from 'commander'
import { set } from 'lodash-es'
import { parseDocument, stringify } from 'yaml'
import { BUILT_IN_COMMANDS, type BuiltInCommand } from '../builtin-commands'
import { configPrompt } from '../configPrompt'
import { createLogger } from '../logger'
import { runWorkflow } from '../runWorkflow'
import { getBaseWorkflowOptions } from '../utils/command'
import { initWorkflow } from '../workflows/init.workflow'
import { initInteractiveWorkflow } from '../workflows/init-interactive.workflow'

/**
 * Create a new Agent Skill template
 */
async function createSkill(name: string, logger: Logger, interactive: boolean) {
  // Validate skill name (same rules as Agent Skills spec)
  const nameRegex = /^[a-z0-9-]+$/
  if (!nameRegex.test(name)) {
    throw new Error('Skill name must contain only lowercase letters, numbers, and hyphens. Example: "react-component-generator"')
  }

  if (name.length > 64) {
    throw new Error('Skill name must be at most 64 characters')
  }

  // Check for conflicts with built-in commands
  if (BUILT_IN_COMMANDS.includes(name as BuiltInCommand)) {
    throw new Error(
      `Skill name '${name}' conflicts with a built-in command. ` + `Please choose a different name (e.g., '${name}-skill' or 'my-${name}')`,
    )
  }

  const skillDir = join('.claude', 'skills', name)

  // Check if skill already exists
  if (existsSync(skillDir)) {
    if (interactive) {
      const proceed = await confirm({
        message: `Skill '${name}' already exists. Overwrite?`,
        default: false,
      })
      if (!proceed) {
        logger.info('Skill creation cancelled')
        return
      }
    } else {
      throw new Error(`Skill already exists: ${skillDir}`)
    }
  }

  // Create skill directory
  mkdirSync(skillDir, { recursive: true })
  logger.info(`Created skill directory: ${skillDir}`)

  // Generate skill template
  const template = generateSkillTemplate(name)
  writeFileSync(join(skillDir, 'SKILL.md'), template)
  logger.info(`Created SKILL.md`)

  logger.info('')
  logger.info(`Skill '${name}' created successfully!`)
  logger.info('')
  logger.info('Next steps:')
  logger.info(`  1. Edit ${skillDir}/SKILL.md to add your instructions`)
  logger.info(`  2. Add supporting files (reference.md, examples.md, etc.)`)
  logger.info(`  3. Validate with: polka skills validate ${name}`)
  logger.info(`  4. Test by asking Claude to use the skill`)
}

/**
 * Generate skill template content
 */
function generateSkillTemplate(name: string): string {
  const capitalizedName = name
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')

  return `---
name: ${name}
description: Brief description of what this skill does and when to use it. Include trigger terms like "when the user mentions..." or "for tasks involving..."
---

# ${capitalizedName}

## Instructions

Provide clear, step-by-step guidance for Claude here.

### When to Use This Skill

Use this skill when:
- The user asks about [specific topics]
- Working with [specific technologies/file types]
- [other trigger conditions]

### Step-by-Step Process

1. First step
2. Second step
3. Continue as needed

## Examples

### Example 1: Simple usage

\`\`\`
Input: [user input example]
Output: [expected response]
\`\`\`

## Best Practices

- Tip 1
- Tip 2
- Tip 3

## Troubleshooting

### Common Issues

**Problem**: Description of problem
**Solution**: How to fix it

## Resources

Add additional files like:
- \`reference.md\` - Detailed documentation
- \`examples.md\` - More usage examples
- \`scripts/\` - Helper scripts
- \`templates/\` - File templates
`
}

/**
 * Create a new TypeScript script template
 */
async function createScript(name: string, logger: Logger, interactive: boolean, isGlobal: boolean = false) {
  // Note: Script name validation and built-in command checks are done at the
  // higher level in the script type handler to apply to both AI and template paths

  const scriptDir = '.polka-scripts'
  // Use forward slashes for config (cross-platform), actual path for file operations
  const scriptPathConfig = `${scriptDir}/${name}.ts`
  const scriptPathActual = join(scriptDir, `${name}.ts`)

  // Check if script already exists
  if (existsSync(scriptPathActual)) {
    if (interactive) {
      const proceed = await confirm({
        message: `Script '${scriptPathActual}' already exists. Overwrite?`,
        default: false,
      })
      if (!proceed) {
        logger.info('Script generation cancelled')
        return
      }
    } else {
      throw new Error(`Script already exists: ${scriptPathActual}`)
    }
  }

  // Create .polka-scripts directory if it doesn't exist
  if (!existsSync(scriptDir)) {
    mkdirSync(scriptDir, { recursive: true })
    logger.info(`Created directory: ${scriptDir}`)
  }

  // Generate script template
  const template = `// Generated by polka.codes
import { code, commit } from '@polka-codes/cli'

export async function main(args: string[]) {
  console.log('Running script: ${name}')
  console.log('Arguments:', args)

  // Your automation here
  // Example workflows:
  // await code({ task: 'Add feature', interactive: false })
  // await commit({ all: true, context: 'Feature complete' })

  console.log('Script completed successfully')
}

// Only run main if this is the entry point
if (import.meta.main) {
  main(process.argv.slice(2))
}
`

  // Write script file
  writeFileSync(scriptPathActual, template)
  logger.info(`Created script: ${scriptPathActual}`)

  // Add to config if it exists
  const configPath = isGlobal ? getGlobalConfigPath() : localConfigFileName
  if (existsSync(configPath)) {
    try {
      const config = readConfig(configPath)
      if (!config.scripts) {
        config.scripts = {}
      }
      config.scripts[name] = {
        script: scriptPathConfig,
        description: `Custom script: ${name}`,
      }

      // Append script to config file while preserving existing content
      const configContent = readFileSync(configPath, 'utf-8')
      let newContent = configContent

      // Check if scripts section exists
      if (!configContent.includes('scripts:')) {
        // Add scripts section at the end
        newContent = `${configContent.trimEnd()}\n\nscripts:\n  ${name}:\n    script: ${scriptPathConfig}\n    description: Custom script: ${name}\n`
      } else {
        // Parse YAML to safely insert into scripts section
        try {
          // Use parseDocument to preserve comments
          const doc = parseDocument(configContent)

          if (!doc.has('scripts')) {
            doc.set('scripts', {})
          }

          doc.setIn(['scripts', name], {
            script: scriptPathConfig,
            description: `Custom script: ${name}`,
          })

          newContent = doc.toString()
        } catch (parseError) {
          // Fallback to string append if YAML parsing fails
          logger.warn('Could not parse config file safely. Please add the script manually:')
          logger.info(`  scripts:`)
          logger.info(`    ${name}:`)
          logger.info(`      script: ${scriptPathConfig}`)
          logger.info(`      description: Custom script: ${name}`)
          if (parseError instanceof Error) {
            logger.debug(`Error: ${parseError.message}`)
          }
          return
        }
      }

      writeFileSync(configPath, newContent)
      logger.info(`Added script to config: ${configPath}`)
      logger.info(`Run with: polka run ${name}`)
    } catch (error) {
      logger.warn('Could not update config file. Add the script manually:')
      logger.info(`  scripts:`)
      logger.info(`    ${name}:`)
      logger.info(`      script: ${scriptPathConfig}`)
      logger.info(`      description: Custom script: ${name}`)
      if (error instanceof Error) {
        logger.debug(`Error: ${error.message}`)
      }
    }
  } else {
    logger.info(`Tip: Add this script to your .polkacodes.yml:`)
    logger.info(`  scripts:`)
    logger.info(`    ${name}:`)
    logger.info(`      script: ${scriptPathConfig}`)
    logger.info(`      description: Custom script: ${name}`)
  }
}

export const initCommand = new Command('init')
  .description('Initialize polkacodes configuration, generate scripts, or create skills')
  .argument('[type]', 'Type of resource to initialize (config, script, skill)')
  .argument('[name]', 'Name of the script or skill (only for type=script|skill)')
  .option('-g, --global', 'Use global config')
  .option('-i, --instructions <string>', 'Script description for AI-assisted generation (only for type=script)')
  .action(async (type, name, options: Record<string, unknown> & { instructions?: string }, command: Command) => {
    const workflowOpts = getBaseWorkflowOptions(command)
    const { verbose, yes } = workflowOpts
    const logger = createLogger({
      verbose: verbose,
    })

    const interactive = !yes

    // Handle skill creation
    if (type === 'skill') {
      if (!name) {
        logger.error('Error: Skill name is required when type=skill')
        logger.info('Usage: polka init skill <skill-name>')
        process.exit(1)
      }
      try {
        await createSkill(name, logger, interactive)
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error)
        logger.error(`Skill creation failed: ${message}`)
        process.exit(1)
      }
      return
    }

    // Handle script generation
    if (type === 'script') {
      if (!name) {
        logger.error('Error: Script name is required when type=script')
        logger.info('Usage: polka init script <script-name>')
        logger.info('')
        logger.info('For AI-assisted script generation:')
        logger.info('  polka init script <name> -i "description"')
        logger.info('')
        logger.info('For basic template generation:')
        logger.info('  polka init script <name>')
        process.exit(1)
      }

      // Validate script name (prevent path traversal - must be flat in .polka-scripts)
      // This validation applies to both AI and basic template generation
      if (name.includes('/') || name.includes('\\')) {
        logger.error('Error: Script name cannot contain slashes. Use a simple name (e.g., "deploy" not "utils/deploy")')
        process.exit(1)
      }

      // Check for conflicts with built-in commands
      if (BUILT_IN_COMMANDS.includes(name as BuiltInCommand)) {
        logger.error(
          `Error: Script name '${name}' conflicts with a built-in command. ` +
            `Please choose a different name (e.g., '${name}-script' or 'my-${name}')`,
        )
        process.exit(1)
      }

      // Check if AI-assisted generation is requested (presence of -i flag)
      const useAI = options.instructions !== undefined

      if (useAI) {
        // Interactive AI-assisted script generation
        try {
          let scriptInstructions = options.instructions
          if (!scriptInstructions && interactive) {
            scriptInstructions = await input({
              message: 'Describe what this script should do:',
              validate: (input) => input.length > 0 || 'Please provide a description',
            })
          }

          if (!scriptInstructions) {
            logger.error('Error: Script instructions are required for AI generation')
            logger.info('Usage: polka init script <name> -i "your instructions"')
            process.exit(1)
          }

          // Check if script already exists before running AI workflow
          const scriptDir = '.polka-scripts'
          const scriptPath = join(scriptDir, `${name}.ts`)

          if (existsSync(scriptPath)) {
            if (interactive) {
              const proceed = await confirm({
                message: `Script '${scriptPath}' already exists. Overwrite?`,
                default: false,
              })
              if (!proceed) {
                logger.info('Script generation cancelled')
                return
              }
            } else {
              throw new Error(`Script already exists: ${scriptPath}`)
            }
          }

          // Get config path
          const globalConfigPath = getGlobalConfigPath()
          const isGlobal = options.global ?? false
          const configPath = isGlobal ? globalConfigPath : localConfigFileName

          // Run interactive workflow
          await runWorkflow(
            initInteractiveWorkflow,
            {
              configPath,
              scriptName: name,
              scriptInstructions,
              generateScript: true,
              skipConfirmation: !interactive,
            },
            {
              commandName: 'init',
              context: workflowOpts,
              logger,
              interactive,
            },
          )
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error)
          logger.error(`AI script generation failed: ${message}`)
          process.exit(1)
        }
      } else {
        // Basic template generation
        try {
          const isGlobal = Boolean(options.global)
          await createScript(name, logger, interactive, isGlobal)
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error)
          logger.error(`Script generation failed: ${message}`)
          process.exit(1)
        }
      }
      return
    }

    // Original config initialization logic
    if (type && type !== 'config') {
      logger.error(`Error: Unknown type '${type}'`)
      logger.info('Valid types: config, script, skill')
      process.exit(1)
    }

    const globalConfigPath = getGlobalConfigPath()
    let isGlobal = options.global ?? false
    let configPath = isGlobal ? globalConfigPath : localConfigFileName

    const exists = existsSync(configPath)

    if (exists) {
      if (interactive) {
        const proceed = await confirm({
          message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
          default: false,
        })
        if (!proceed) {
          logger.info('User cancelled')
          return
        }
      }
    } else if (!options.global) {
      if (interactive) {
        const location = await select({
          message: 'No config file found. Do you want to create one?',
          choices: [
            { name: `Create a global config at ${globalConfigPath}`, value: 'global' },
            { name: `Create a local config at ${configPath}`, value: 'local' },
          ],
        })
        if (location === 'global') {
          isGlobal = true
          configPath = globalConfigPath
        }
      }
    }

    logger.info(`Config file path: ${configPath}`)

    let existingConfig: Config = {}
    try {
      existingConfig = readConfig(configPath)
    } catch (error) {
      logger.error(`Unable to parse config file: ${configPath}`, error)
      throw error
    }

    const providerConfig = await configPrompt({})
    const { provider, model, apiKey } = providerConfig

    if (apiKey && !isGlobal) {
      let option = 'local'
      if (interactive) {
        option = await select({
          message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
          choices: [
            { name: 'Save API key in the local config file', value: 'local' },
            { name: 'Save API key in the global config file', value: 'global' },
            { name: 'Save API key to .env file', value: 'env' },
          ],
        })
      }

      switch (option) {
        case 'local':
          break
        case 'global': {
          const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
          set(globalConfig, ['providers', provider, 'apiKey'], apiKey)
          writeFileSync(globalConfigPath, stringify(globalConfig))
          logger.info(`API key saved to global config file: ${globalConfigPath}`)
          providerConfig.apiKey = undefined
          break
        }
        case 'env': {
          let envFileContent = ''
          const envExists = existsSync('.env')
          if (envExists) {
            envFileContent = readFileSync('.env', 'utf-8')
            if (!envFileContent.endsWith('\n')) envFileContent += '\n'
          }
          envFileContent += `${provider.toUpperCase()}_API_KEY=${apiKey}\n`
          writeFileSync('.env', envFileContent)
          logger.info('API key saved to .env file')
          providerConfig.apiKey = undefined
          break
        }
      }
    }

    const finalConfig: Config = {
      ...existingConfig,
      defaultProvider: provider,
      defaultModel: model,
    }

    if (!finalConfig.providers) {
      finalConfig.providers = {}
    }

    if (providerConfig.apiKey) {
      set(finalConfig, ['providers', provider, 'apiKey'], providerConfig.apiKey)
    }

    writeFileSync(configPath, stringify(finalConfig))
    logger.info(`Configuration saved to ${configPath}`)

    let shouldAnalyze = false
    if (!isGlobal && interactive) {
      shouldAnalyze = await confirm({
        message: 'Would you like to analyze the project to generate recommended configuration?',
        default: false,
      })
    }

    if (shouldAnalyze) {
      await runWorkflow(
        initWorkflow,
        {
          configPath,
        },
        {
          commandName: 'init',
          context: workflowOpts,
          logger,
        },
      )
    }
  })
