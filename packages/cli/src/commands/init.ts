/**
 * Initialize polkacodes configuration command.
 * Generated by polka.codes
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import { confirm, select } from '@inquirer/prompts'
import { type Config, getGlobalConfigPath, loadConfigAtPath, localConfigFileName, readConfig } from '@polka-codes/cli-shared'
import type { Logger } from '@polka-codes/core'
import { Command } from 'commander'
import { set } from 'lodash-es'
import { stringify } from 'yaml'
import { configPrompt } from '../configPrompt'
import { createLogger } from '../logger'
import { runWorkflow } from '../runWorkflow'
import { initWorkflow } from '../workflows/init.workflow'

/**
 * Create a new TypeScript script template
 */
async function createScript(name: string, logger: Logger, interactive: boolean) {
  // Validate script name (prevent path traversal - must be flat in .polka-scripts)
  if (name.includes('/') || name.includes('\\')) {
    throw new Error('Script name cannot contain slashes. Use a simple name (e.g., "deploy" not "utils/deploy")')
  }

  // Check for conflicts with built-in commands
  const BUILT_IN_COMMANDS = ['code', 'commit', 'pr', 'review', 'fix', 'plan', 'workflow', 'run', 'init', 'meta']
  if (BUILT_IN_COMMANDS.includes(name)) {
    throw new Error(
      `Script name '${name}' conflicts with a built-in command. ` +
        `Please choose a different name (e.g., '${name}-script' or 'my-${name}')`,
    )
  }

  const scriptDir = '.polka-scripts'
  const scriptPath = join(scriptDir, `${name}.ts`)

  // Check if script already exists
  if (existsSync(scriptPath)) {
    if (interactive) {
      const proceed = await confirm({
        message: `Script '${scriptPath}' already exists. Overwrite?`,
        default: false,
      })
      if (!proceed) {
        logger.info('Script generation cancelled')
        return
      }
    } else {
      throw new Error(`Script already exists: ${scriptPath}`)
    }
  }

  // Create .polka-scripts directory if it doesn't exist
  if (!existsSync(scriptDir)) {
    mkdirSync(scriptDir, { recursive: true })
    logger.info(`Created directory: ${scriptDir}`)
  }

  // Generate script template
  const template = `// Generated by polka.codes
import { code, commit } from '@polka-codes/cli'

export async function main(args: string[]) {
  console.log('Running script: ${name}')
  console.log('Arguments:', args)

  // Your automation here
  // Example workflows:
  // await code({ task: 'Add feature', interactive: false })
  // await commit({ all: true, context: 'Feature complete' })

  console.log('Script completed successfully')
}

// Only run main if this is the entry point
if (import.meta.main) {
  main(process.argv.slice(2))
}
`

  // Write script file
  writeFileSync(scriptPath, template)
  logger.info(`Created script: ${scriptPath}`)

  // Add to config if it exists
  if (existsSync(localConfigFileName)) {
    try {
      const config = readConfig(localConfigFileName)
      if (!config.scripts) {
        config.scripts = {}
      }
      config.scripts[name] = {
        script: scriptPath,
        description: `Custom script: ${name}`,
      }
      // Note: This will reformat the config file and remove comments
      writeFileSync(localConfigFileName, stringify(config))
      logger.info(`Added script to config: ${localConfigFileName}`)
      logger.info(`Run with: polka run ${name}`)
    } catch (error) {
      logger.warn('Could not update config file. Add the script manually:')
      logger.info(`  scripts:`)
      logger.info(`    ${name}:`)
      logger.info(`      script: ${scriptPath}`)
      logger.info(`      description: Custom script: ${name}`)
      if (error instanceof Error) {
        logger.debug(`Error: ${error.message}`)
      }
    }
  } else {
    logger.info(`Tip: Add this script to your .polkacodes.yml:`)
    logger.info(`  scripts:`)
    logger.info(`    ${name}:`)
    logger.info(`      script: ${scriptPath}`)
    logger.info(`      description: Custom script: ${name}`)
  }
}

export const initCommand = new Command('init')
  .description('Initialize polkacodes configuration or generate scripts')
  .argument('[type]', 'Type of resource to initialize (config, script)')
  .argument('[name]', 'Name of the script (only for type=script)')
  .option('-g, --global', 'Use global config')
  .action(async (type, name, options, command: Command) => {
    const globalOpts = (command.parent ?? command).opts()
    const { verbose, yes } = globalOpts
    const logger = createLogger({
      verbose: verbose,
    })

    const interactive = !yes

    // Handle script generation
    if (type === 'script') {
      if (!name) {
        logger.error('Error: Script name is required when type=script')
        logger.info('Usage: polka init script <script-name>')
        process.exit(1)
      }
      try {
        await createScript(name, logger, interactive)
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error)
        logger.error(`Script generation failed: ${message}`)
        process.exit(1)
      }
      return
    }

    // Original config initialization logic
    if (type && type !== 'config') {
      logger.error(`Error: Unknown type '${type}'`)
      logger.info('Valid types: config, script')
      process.exit(1)
    }

    const globalConfigPath = getGlobalConfigPath()
    let isGlobal = options.global ?? false
    let configPath = isGlobal ? globalConfigPath : localConfigFileName

    const exists = existsSync(configPath)

    if (exists) {
      if (interactive) {
        const proceed = await confirm({
          message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
          default: false,
        })
        if (!proceed) {
          logger.info('User cancelled')
          return
        }
      }
    } else if (!options.global) {
      if (interactive) {
        const location = await select({
          message: 'No config file found. Do you want to create one?',
          choices: [
            { name: `Create a global config at ${globalConfigPath}`, value: 'global' },
            { name: `Create a local config at ${configPath}`, value: 'local' },
          ],
        })
        if (location === 'global') {
          isGlobal = true
          configPath = globalConfigPath
        }
      }
    }

    logger.info(`Config file path: ${configPath}`)

    let existingConfig: Config = {}
    try {
      existingConfig = readConfig(configPath)
    } catch (error) {
      logger.error(`Unable to parse config file: ${configPath}`, error)
      throw error
    }

    const providerConfig = await configPrompt({})
    const { provider, model, apiKey } = providerConfig

    if (apiKey && !isGlobal) {
      let option = 'local'
      if (interactive) {
        option = await select({
          message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
          choices: [
            { name: 'Save API key in the local config file', value: 'local' },
            { name: 'Save API key in the global config file', value: 'global' },
            { name: 'Save API key to .env file', value: 'env' },
          ],
        })
      }

      switch (option) {
        case 'local':
          break
        case 'global': {
          const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
          set(globalConfig, ['providers', provider, 'apiKey'], apiKey)
          writeFileSync(globalConfigPath, stringify(globalConfig))
          logger.info(`API key saved to global config file: ${globalConfigPath}`)
          providerConfig.apiKey = undefined
          break
        }
        case 'env': {
          let envFileContent = ''
          const envExists = existsSync('.env')
          if (envExists) {
            envFileContent = readFileSync('.env', 'utf-8')
            if (!envFileContent.endsWith('\n')) envFileContent += '\n'
          }
          envFileContent += `${provider.toUpperCase()}_API_KEY=${apiKey}\n`
          writeFileSync('.env', envFileContent)
          logger.info('API key saved to .env file')
          providerConfig.apiKey = undefined
          break
        }
      }
    }

    const finalConfig: Config = {
      ...existingConfig,
      defaultProvider: provider,
      defaultModel: model,
    }

    if (!finalConfig.providers) {
      finalConfig.providers = {}
    }

    if (providerConfig.apiKey) {
      set(finalConfig, ['providers', provider, 'apiKey'], providerConfig.apiKey)
    }

    writeFileSync(configPath, stringify(finalConfig))
    logger.info(`Configuration saved to ${configPath}`)

    let shouldAnalyze = false
    if (!isGlobal && interactive) {
      shouldAnalyze = await confirm({
        message: 'Would you like to analyze the project to generate recommended configuration?',
        default: false,
      })
    }

    if (shouldAnalyze) {
      await runWorkflow(
        initWorkflow,
        {
          configPath,
        },
        {
          commandName: 'init',
          context: globalOpts,
          logger,
          requiresProvider: true,
        },
      )
    }
  })
