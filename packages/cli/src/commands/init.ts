import os from 'node:os'
/**
 * Initialize polkacodes configuration command.
 * Generated by polka.codes
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { dirname } from 'node:path'
import { confirm, select } from '@inquirer/prompts'
import {
  type AiServiceProvider,
  AnalyzerAgent,
  MultiAgent,
  analyzerAgentInfo,
  createService,
  generateProjectConfig,
} from '@polka-codes/core'
import { Command } from 'commander'
import { set } from 'lodash'
import { parse, stringify } from 'yaml'

import { getGlobalConfigPath, loadConfigAtPath, localConfigFileName, readLocalConfig } from '../config'
import { configPrompt } from '../configPrompt'
import { parseOptions } from '../options'
import { getProvider } from '../provider'
import { printEvent } from '../utils/eventHandler'
import { listFiles } from '../utils/listFiles'

export const initCommand = new Command('init')
  .description('Initialize polkacodes configuration')
  .option('-g, --global', 'Use global config')

initCommand.action(async (options, command: Command) => {
  const cmdOptions = command.parent?.opts() ?? {}
  const globalConfigPath = getGlobalConfigPath()
  let configPath = options.global ? globalConfigPath : localConfigFileName

  try {
    // Check for existing config
    const localConfig = readLocalConfig()
    if (localConfig) {
      const proceed = await confirm({
        message: `Found existing config at ${configPath}. Do you want to proceed? This will overwrite the existing config.`,
        default: false,
      })
      if (!proceed) {
        console.log('Cancelled')
        return
      }
    }

    // If no config exists and not explicitly global, ask for location
    if (!localConfig && !options.global) {
      const isGlobal = await select({
        message: 'No config file found. Do you want to create one?',
        choices: [
          {
            name: `Create a global config at ${globalConfigPath}`,
            value: true,
          },
          {
            name: `Create a local config at ${configPath}`,
            value: false,
          },
        ],
      })
      if (isGlobal) {
        configPath = globalConfigPath
      }
    }

    console.log(`Config file path: ${configPath}`)

    const { config: existingConfig, providerConfig, verbose } = parseOptions(cmdOptions)
    let { provider, model, apiKey } = providerConfig.getConfigForCommand('init') ?? {}

    // Get provider configuration
    const newConfig = await configPrompt({ provider, model, apiKey })
    provider = newConfig.provider as AiServiceProvider
    model = newConfig.model
    apiKey = newConfig.apiKey

    // Handle API key storage if provided
    if (apiKey && configPath === localConfigFileName) {
      const option = await select({
        message: 'It is not recommended to store API keys in the local config file. How would you like to proceed?',
        choices: [
          {
            name: 'Save API key in the local config file',
            value: 1,
          },
          {
            name: 'Save API key in the global config file',
            value: 2,
          },
          {
            name: 'Save API key to .env file',
            value: 3,
          },
        ],
      })

      switch (option) {
        case 1:
          // do nothing, will be saved in local config
          break
        case 2: {
          const globalConfig = loadConfigAtPath(globalConfigPath) ?? {}
          set(globalConfig, ['providers', provider, 'apiKey'], apiKey)
          mkdirSync(dirname(globalConfigPath), { recursive: true })
          writeFileSync(globalConfigPath, stringify(globalConfig))
          console.log(`API key saved to global config file: ${globalConfigPath}`)
          apiKey = undefined
          break
        }
        case 3: {
          let envFileContent: string
          if (existsSync('.env')) {
            envFileContent = readFileSync('.env', 'utf8')
            envFileContent += `\n${provider.toUpperCase()}_API_KEY=${apiKey}`
          } else {
            envFileContent = `${provider.toUpperCase()}_API_KEY=${apiKey}`
          }
          writeFileSync('.env', envFileContent)
          console.log('API key saved to .env file')
          apiKey = undefined
          break
        }
      }
    }

    // Ask if user wants to analyze project
    const shouldAnalyze = await confirm({
      message: 'Would you like to analyze the project to generate recommended configuration?',
      default: true,
    })

    let generatedConfig = {}
    if (shouldAnalyze) {
      // Create AI service
      const service = createService(provider as AiServiceProvider, {
        apiKey: apiKey ?? process.env.POLKA_API_KEY ?? cmdOptions.apiKey ?? existingConfig.providers?.[provider]?.apiKey,
        model,
      })

      // Create MultiAgent
      const multiAgent = new MultiAgent({
        createAgent: async (name: string) => {
          const agentName = name.trim().toLowerCase()
          switch (agentName) {
            case analyzerAgentInfo.name:
              return new AnalyzerAgent({
                ai: service,
                os: os.platform(),
                provider: getProvider('analyzer', existingConfig),
                interactive: false,
              })
            default:
              throw new Error(`Unknown agent: ${name}`)
          }
        },
      })

      // Generate project config
      console.log('Analyzing project files...')
      const files: Record<string, string> = {}
      const [relevantFiles] = await listFiles('.', true, 1000, process.cwd())

      // Read relevant files
      for (const filePath of relevantFiles) {
        if (typeof filePath === 'string' && existsSync(filePath)) {
          try {
            const content = readFileSync(filePath, 'utf8')
            files[filePath] = content
          } catch (error) {
            console.warn(`Failed to read file: ${filePath}`)
          }
        }
      }

      const { response } = await generateProjectConfig(multiAgent, relevantFiles, printEvent(verbose))
      generatedConfig = response ? parse(response) : {}
    }

    // Combine configs
    const finalConfig = {
      ...(existingConfig ?? {}),
      ...generatedConfig,
      defaultProvider: provider,
      defaultModel: model,
    }

    if (apiKey) {
      set(finalConfig, ['providers', provider, 'apiKey'], apiKey)
    }

    // Save config
    mkdirSync(dirname(configPath), { recursive: true })
    writeFileSync(configPath, stringify(finalConfig))
    console.log(`Configuration saved to ${configPath}`)
  } catch (error) {
    console.error('Failed to generate configuration:', error)
    process.exit(1)
  }
})
