// generated by polka.codes

import { execSync } from 'node:child_process'
import { loadConfig } from '@polka-codes/cli-shared'
import type { Logger } from '@polka-codes/core'
import type { Command } from 'commander'
import { BUILT_IN_COMMANDS, type BuiltInCommand } from '../builtin-commands'
import { createLogger } from '../logger'
import { runWorkflow } from '../runWorkflow'
import { executeScript, ScriptExecutionFailedError } from '../script/executor'
import { getBaseWorkflowOptions } from '../utils/command'
import { getUserInput } from '../utils/userInput'
import { metaWorkflow } from '../workflows/meta.workflow'

export async function runMeta(task: string | undefined, command: Command) {
  const workflowOpts = getBaseWorkflowOptions(command)
  const { verbose } = workflowOpts
  const logger = createLogger({
    verbose,
  })

  // Priority 1: Check if input is a command
  if (task) {
    const trimmedTask = task.trim()
    const words = trimmedTask.split(/\s+/)

    // Single word = command
    if (words.length === 1) {
      const matched = await tryExecuteCommand(words[0], logger)
      if (matched) {
        return
      }

      logger.error(`Error: Unknown command '${words[0]}'`)
      logger.info('Available commands:')
      logger.info('  Built-in: code, commit, pr, review, fix, plan, workflow, run')

      // List custom scripts from config
      const config = await loadConfig()
      if (config?.scripts) {
        const scriptNames = Object.keys(config.scripts)
        if (scriptNames.length > 0) {
          logger.info('  Custom:')
          for (const name of scriptNames) {
            logger.info(`    ${name}`)
          }
        }
      }
      return
    }

    // Multi-word: must be >1 word (2 or more words is a task)
    if (words.length < 2) {
      logger.error('Error: Task must be at least 2 words.')
      logger.info('  For commands: polka <command>')
      logger.info('  For tasks: polka "detailed task description"')
      return
    }

    // Execute meta workflow for the task
    const workflowInput = {
      task,
      ...workflowOpts,
    }

    await runWorkflow(metaWorkflow, workflowInput, {
      commandName: 'meta',
      context: workflowOpts,
      logger,
      ...workflowOpts,
    })
    return
  }

  // Priority 2: Prompt for input
  const input = await getUserInput('What do you want to work on?')
  if (!input) {
    logger.info('No input provided. Exiting.')
    return
  }

  const trimmedInput = input.trim()
  const words = trimmedInput.split(/\s+/)

  // Single word = command
  if (words.length === 1) {
    const matched = await tryExecuteCommand(words[0], logger)
    if (matched) {
      return
    }

    logger.error(`Error: Unknown command '${words[0]}'`)
    logger.info('Available commands:')
    logger.info('  Built-in: code, commit, pr, review, fix, plan, workflow, run')
    return
  }

  // Multi-word: must be >1 word (2 or more words is a task)
  if (words.length < 2) {
    logger.error('Error: Task must be at least 2 words.')
    logger.info('  For commands: polka <command>')
    logger.info('  For tasks: polka "detailed task description"')
    return
  }

  // Execute meta workflow for the task
  const workflowInput = {
    task: input,
    ...workflowOpts,
  }

  await runWorkflow(metaWorkflow, workflowInput, {
    commandName: 'meta',
    context: workflowOpts,
    logger,
    ...workflowOpts,
  })
}

/**
 * Try to execute a command (built-in or custom script)
 * @returns true if command was found and executed, false otherwise
 */
async function tryExecuteCommand(commandName: string, logger: Logger): Promise<boolean> {
  // Check built-in commands
  if (BUILT_IN_COMMANDS.includes(commandName as BuiltInCommand)) {
    // Use the current executable to run the command
    const runtime = process.argv[0] // The node/bun runtime
    const script = process.argv[1] // The script being executed
    const args = [commandName]
    execSync(`"${runtime}" "${script}" ${args.join(' ')}`, { stdio: 'inherit' })
    return true
  }

  // Check custom scripts
  const config = await loadConfig()
  const script = config?.scripts?.[commandName]
  if (script) {
    try {
      await executeScript(script, commandName, logger, [])
    } catch (error) {
      if (error instanceof ScriptExecutionFailedError) {
        process.exit(error.exitCode)
      }
      throw error
    }
    return true
  }

  return false
}
