// generated by polka.codes

import { execSync } from 'node:child_process'
import { getProvider, loadConfig } from '@polka-codes/cli-shared'
import type { Logger, ScriptConfig, UsageMeter } from '@polka-codes/core'
import type { Command } from 'commander'
import { createLogger } from '../logger'
import { runWorkflow } from '../runWorkflow'
import { ScriptRunner } from '../script'
import { getUserInput } from '../utils/userInput'
import {
  type EpicContext,
  EpicMemoryStore,
  EpicTodoItemStore,
  loadEpicContext,
  saveEpicContext as persistEpicContext,
} from '../workflows/epic-context'
import { metaWorkflow } from '../workflows/meta.workflow'

export async function runMeta(task: string | undefined, command: Command) {
  const globalOpts = (command.parent ?? command).opts()
  const { verbose } = globalOpts
  const logger = createLogger({
    verbose,
  })

  const epicContext = await loadEpicContext()

  // Priority 1: Resume epic if exists
  if (epicContext.task) {
    if (task) {
      logger.error('Error: Existing epic context found.')
      logger.info(`Current task: ${epicContext.task}`)
      logger.info('Use "polka epic --clear" to start a new task.')
      return
    }
    logger.info('Resuming existing epic session. Task:')
    logger.info(`   ${epicContext.task}`)

    let usageMeter: UsageMeter | undefined

    const saveUsageSnapshot = async () => {
      if (usageMeter) {
        const currentUsage = usageMeter.usage
        if (!epicContext.usages) {
          epicContext.usages = []
        }
        epicContext.usages.push({ ...currentUsage, timestamp: Date.now() })
      }
    }

    const workflowInput = {
      ...epicContext,
      async saveEpicContext(context: EpicContext) {
        await persistEpicContext(context)
      },
      saveUsageSnapshot,
      interactive: !globalOpts.yes,
    }

    await runWorkflow(metaWorkflow, workflowInput, {
      commandName: 'meta',
      context: globalOpts,
      logger,
      onUsageMeterCreated: (meter) => {
        usageMeter = meter
      },
      getProvider: (opt) =>
        getProvider({
          ...opt,
          todoItemStore: new EpicTodoItemStore(workflowInput),
          memoryStore: new EpicMemoryStore(workflowInput),
        }),
    })
    return
  }

  // Priority 2: Check if input is a command
  if (task) {
    const trimmedTask = task.trim()
    const words = trimmedTask.split(/\s+/)

    // Single word = command
    if (words.length === 1) {
      const matched = await tryExecuteCommand(words[0], logger)
      if (matched) {
        return
      }

      logger.error(`Error: Unknown command '${words[0]}'`)
      logger.info('Available commands:')
      logger.info('  Built-in: code, commit, pr, review, fix, plan, workflow, run')

      // List custom scripts from config
      const config = await loadConfig()
      if (config?.scripts) {
        const scriptNames = Object.keys(config.scripts)
        if (scriptNames.length > 0) {
          logger.info('  Custom:')
          for (const name of scriptNames) {
            logger.info(`    ${name}`)
          }
        }
      }
      return
    }

    // Multi-word: must be >2 words
    if (words.length <= 2) {
      logger.error('Error: Task must be more than 2 words.')
      logger.info('  For commands: polka <command>')
      logger.info('  For tasks: polka "detailed task description"')
      return
    }

    // Start new epic with task
    epicContext.task = task
    let usageMeter: UsageMeter | undefined

    const saveUsageSnapshot = async () => {
      if (usageMeter) {
        const currentUsage = usageMeter.usage
        if (!epicContext.usages) {
          epicContext.usages = []
        }
        epicContext.usages.push({ ...currentUsage, timestamp: Date.now() })
      }
    }

    const workflowInput = {
      ...epicContext,
      async saveEpicContext(context: EpicContext) {
        await persistEpicContext(context)
      },
      saveUsageSnapshot,
      interactive: !globalOpts.yes,
    }

    await runWorkflow(metaWorkflow, workflowInput, {
      commandName: 'meta',
      context: globalOpts,
      logger,
      onUsageMeterCreated: (meter) => {
        usageMeter = meter
      },
      getProvider: (opt) =>
        getProvider({
          ...opt,
          todoItemStore: new EpicTodoItemStore(workflowInput),
          memoryStore: new EpicMemoryStore(workflowInput),
        }),
    })
    return
  }

  // Priority 3: Prompt for input
  const input = await getUserInput('What do you want to work on?')
  if (!input) {
    logger.info('No input provided. Exiting.')
    return
  }

  const trimmedInput = input.trim()
  const words = trimmedInput.split(/\s+/)

  // Single word = command
  if (words.length === 1) {
    const matched = await tryExecuteCommand(words[0], logger)
    if (matched) {
      return
    }

    logger.error(`Error: Unknown command '${words[0]}'`)
    logger.info('Available commands:')
    logger.info('  Built-in: code, commit, pr, review, fix, plan, workflow, run')
    return
  }

  // Multi-word: must be >2 words
  if (words.length <= 2) {
    logger.error('Error: Task must be more than 2 words.')
    logger.info('  For commands: polka <command>')
    logger.info('  For tasks: polka "detailed task description"')
    return
  }

  // Start new epic with task
  epicContext.task = input
  let usageMeter: UsageMeter | undefined

  const saveUsageSnapshot = async () => {
    if (usageMeter) {
      const currentUsage = usageMeter.usage
      if (!epicContext.usages) {
        epicContext.usages = []
      }
      epicContext.usages.push({ ...currentUsage, timestamp: Date.now() })
    }
  }

  const workflowInput = {
    ...epicContext,
    async saveEpicContext(context: EpicContext) {
      await persistEpicContext(context)
    },
    saveUsageSnapshot,
    interactive: !globalOpts.yes,
  }

  await runWorkflow(metaWorkflow, workflowInput, {
    commandName: 'meta',
    context: globalOpts,
    logger,
    onUsageMeterCreated: (meter) => {
      usageMeter = meter
    },
    getProvider: (opt) =>
      getProvider({
        ...opt,
        todoItemStore: new EpicTodoItemStore(workflowInput),
        memoryStore: new EpicMemoryStore(workflowInput),
      }),
  })
}

/**
 * Try to execute a command (built-in or custom script)
 * @returns true if command was found and executed, false otherwise
 */
async function tryExecuteCommand(commandName: string, logger: Logger): Promise<boolean> {
  // Check built-in commands
  const builtInCommands = ['code', 'commit', 'pr', 'review', 'fix', 'plan', 'workflow', 'run']
  if (builtInCommands.includes(commandName)) {
    // Execute via subprocess
    execSync(`bun run cli ${commandName}`, { stdio: 'inherit', shell: true } as any)
    return true
  }

  // Check custom scripts
  const config = await loadConfig()
  const script = config?.scripts?.[commandName]
  if (script) {
    await executeScript(script, commandName, logger)
    return true
  }

  return false
}

/**
 * Execute a script (shell command, workflow, or TypeScript)
 */
async function executeScript(script: ScriptConfig, name: string, logger: Logger) {
  const runner = new ScriptRunner()

  // Determine script type and execute
  if (typeof script === 'string') {
    // Shell command
    execSync(script, { stdio: 'inherit', shell: true } as any)
  } else if ('command' in script) {
    // Shell command with description
    execSync(script.command, { stdio: 'inherit', shell: true } as any)
  } else if ('workflow' in script) {
    // Dynamic workflow YAML
    logger.error(`Error: workflow execution not yet implemented for '${name}'`)
    logger.info('Workflow scripts will be supported in a future update.')
  } else if ('script' in script) {
    // TypeScript script
    const result = await runner.execute({
      scriptPath: script.script,
      args: [],
      context: {},
      logger,
      timeout: script.timeout,
    })

    if (!result.success && result.error) {
      logger.error(`Script '${name}' failed: ${result.error.message}`)
      process.exit(1)
    }
  }
}
