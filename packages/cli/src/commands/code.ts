// generated by polka.codes
import { readFile } from 'node:fs/promises'
import { input } from '@inquirer/prompts'
import { Command } from 'commander'
import { lookup } from 'mime-types'
import { parseOptions } from '../options'
import { runWorkflow } from '../runWorkflow'
import { type CodeWorkflowInput, codeWorkflow, type JsonFilePart, type JsonImagePart } from '../workflows/code.workflow'

const readStdin = async (timeoutMs = 1000): Promise<string> => {
  if (process.stdin.isTTY) {
    return ''
  }

  return new Promise((resolve, reject) => {
    let input = ''
    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId)
      process.stdin.removeAllListeners()
    }

    const timeoutId = setTimeout(() => {
      cleanup()
      // Don't reject, just resolve with what we have
      resolve(input)
    }, timeoutMs)

    process.stdin.on('data', (chunk: Buffer) => {
      input += chunk.toString()
    })

    process.stdin.on('end', () => {
      cleanup()
      resolve(input)
    })

    process.stdin.on('error', (err) => {
      cleanup()
      reject(err)
    })
  })
}

export async function runCode(task: string | undefined, _options: any, command: Command) {
  let taskInput = task
  const stdin = await readStdin()

  if (stdin) {
    taskInput = stdin
  }

  const { file: files } = parseOptions(command.opts())

  const fileContents: (JsonFilePart | JsonImagePart)[] = []
  if (files) {
    for (const file of files) {
      try {
        const mimeType = lookup(file)
        if (mimeType) {
          const buffer = await readFile(file)
          if (mimeType.startsWith('image/')) {
            fileContents.push({
              type: 'image',
              mediaType: mimeType,
              image: buffer.toString('base64'),
            })
          } else {
            fileContents.push({
              type: 'file',
              mediaType: mimeType,
              filename: file,
              data: buffer.toString('base64'),
            })
          }
        } else {
          console.warn(`Unknown mime type for file: ${file}`)
        }
      } catch (error) {
        console.error(`Error reading file '${file}': ${(error as Error).message}`)
      }
    }
  }

  if (!taskInput && fileContents.length === 0) {
    try {
      taskInput = await input({
        message: 'What feature or task do you want to implement?',
      })
    } catch (error) {
      if (error instanceof Error && error.name === 'ExitPromptError') {
        return
      }
      throw error
    }
  }

  if (!taskInput && fileContents.length > 0) {
    taskInput = 'Implement the changes based on the provided files.'
  }

  if (!taskInput) {
    // This should not happen based on the logic above, but as a safeguard:
    console.error('No task provided. Aborting.')
    return
  }

  const workflowInput: CodeWorkflowInput = {
    task: taskInput,
    files: fileContents,
  }

  await runWorkflow('code', codeWorkflow, command, workflowInput)
}

export const codeCommand = new Command('code')
  .description('Plan and implement a feature or task using architect and coder agents.')
  .argument('[task]', 'The task to plan and implement.')
  .action(runCode)
