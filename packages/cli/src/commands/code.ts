// generated by polka.codes
import { readFile } from 'node:fs/promises'
import { Command } from 'commander'
import { lookup } from 'mime-types'
import { createLogger } from '../logger'
import { parseOptions } from '../options'
import { runWorkflow } from '../runWorkflow'
import { getUserInput } from '../utils/userInput'
import { type CodeWorkflowInput, codeWorkflow, type JsonFilePart, type JsonImagePart } from '../workflows/code.workflow'

const readStdin = async (timeoutMs = 1000): Promise<string> => {
  if (process.stdin.isTTY) {
    return ''
  }

  return new Promise((resolve, reject) => {
    let input = ''
    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId)
      process.stdin.removeAllListeners()
    }

    const timeoutId = setTimeout(() => {
      cleanup()
      // Don't reject, just resolve with what we have
      resolve(input)
    }, timeoutMs)

    process.stdin.on('data', (chunk: Buffer) => {
      input += chunk.toString()
    })

    process.stdin.on('end', () => {
      cleanup()
      resolve(input)
    })

    process.stdin.on('error', (err) => {
      cleanup()
      reject(err)
    })
  })
}

export async function runCode(task: string | undefined, _options: any, command: Command) {
  let taskInput = task
  const stdin = await readStdin()

  if (stdin) {
    taskInput = stdin
  }

  const { file: files } = parseOptions(command.opts(), { commandName: 'code' })

  const fileContents: (JsonFilePart | JsonImagePart)[] = []
  if (files) {
    for (const file of files) {
      try {
        const mimeType = lookup(file)
        if (mimeType) {
          const buffer = await readFile(file)
          if (mimeType.startsWith('image/')) {
            fileContents.push({
              type: 'image',
              mediaType: mimeType,
              image: buffer.toString('base64'),
            })
          } else {
            fileContents.push({
              type: 'file',
              mediaType: mimeType,
              filename: file,
              data: buffer.toString('base64'),
            })
          }
        } else {
          console.warn(`Unknown mime type for file: ${file}`)
        }
      } catch (error) {
        console.error(`Error reading file '${file}': ${(error as Error).message}`)
      }
    }
  }

  if (!taskInput && fileContents.length === 0) {
    taskInput = await getUserInput('What feature or task do you want to implement?')
    if (taskInput === undefined) {
      return
    }
  }

  if (!taskInput && fileContents.length > 0) {
    taskInput = 'Implement the changes based on the provided files.'
  }

  if (!taskInput) {
    // This should not happen based on the logic above, but as a safeguard:
    console.error('No task provided. Aborting.')
    return
  }

  const workflowInput: CodeWorkflowInput = {
    task: taskInput,
    files: fileContents,
  }

  const globalOpts = (command.parent ?? command).opts()
  const { verbose, yes } = globalOpts
  const logger = createLogger({
    verbose,
  })

  await runWorkflow(codeWorkflow, workflowInput, { commandName: 'code', command, logger, yes })
}

export const codeCommand = new Command('code')
  .description('Plan and implement a feature or task using architect and coder agents.')
  .argument('[task]', 'The task to plan and implement.')
  .action(runCode)
