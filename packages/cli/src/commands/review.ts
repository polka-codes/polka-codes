// generated by polka.codes

import { confirm } from '@inquirer/prompts'
import { Command, InvalidOptionArgumentError } from 'commander'
import { runWorkflow } from '../runWorkflow'
import type { CliToolRegistry } from '../workflow-tools'
import { codeWorkflow, type ReviewWorkflowInput, reviewWorkflow } from '../workflows'
import { formatReviewForConsole, type ReviewResult } from '../workflows/workflow.utils'

export const reviewCommand = new Command('review')
  .description('Review a GitHub pull request or local changes')
  .option('--pr <pr>', 'The pull request number or URL to review')
  .option('--json', 'Output the review in JSON format', false)
  .option('-y, --yes', 'Automatically apply review feedback', false)
  .option(
    '--loop [count]',
    'Re-review after changes are applied.',
    (value) => {
      if (value === undefined || value === null) {
        return 1
      }
      const parsedValue = parseInt(value, 10)
      if (Number.isNaN(parsedValue) || parsedValue < 1) {
        throw new InvalidOptionArgumentError('Must be a positive number.')
      }
      return parsedValue
    },
    1,
  )
  .action(async (options: { pr?: string; json: boolean; yes: boolean; loop: number }, command: Command) => {
    const { json, pr, loop: maxIterations, yes: yesOption } = options
    const yes = maxIterations > 1 || yesOption
    let changesAppliedInThisIteration = false

    for (let i = 0; i < maxIterations; i++) {
      changesAppliedInThisIteration = false
      const input = { json, ...(pr && { pr }) }

      if (i > 0) {
        command.opts().silent ||
          (json ? console.error : console.log)(
            `
Re-running review (iteration ${i + 1} of ${maxIterations})...`,
          )
      }

      const reviewResult = await runWorkflow<ReviewWorkflowInput, ReviewResult, CliToolRegistry>('review', reviewWorkflow, command, input)

      if (reviewResult) {
        const formattedReview = formatReviewForConsole(reviewResult)
        if (json) {
          console.log(JSON.stringify(reviewResult, null, 2))
        } else if (formattedReview) {
          console.log(formattedReview)
        }

        let shouldRunTask = false
        if (reviewResult.specificReviews && reviewResult.specificReviews.length > 0) {
          if (yes) {
            shouldRunTask = true
          } else if (process.stdin.isTTY) {
            await new Promise((resolve) => setTimeout(resolve, 50)) // wait for ora to finish
            try {
              shouldRunTask = await confirm({
                message: 'Do you wish polka-codes to address the review results?',
                default: false,
              })
            } catch (error) {
              if (error instanceof Error && error.name === 'ExitPromptError') {
                return
              }
            }
          }
        }

        if (shouldRunTask && formattedReview) {
          changesAppliedInThisIteration = true
          const taskInstruction = `please address the review result:\n\n${formattedReview}`
          await runWorkflow('code', codeWorkflow, command, {
            task: taskInstruction,
          })
        }
      }

      if (maxIterations > 1 && !changesAppliedInThisIteration) {
        command.opts().silent || (json ? console.error : console.log)('\nNo more review feedback to apply. Exiting loop.')
        break
      }
    }
  })
