// generated by polka.codes

import { execSync } from 'node:child_process'
import { Console } from 'node:console'
import { confirm } from '@inquirer/prompts'
import { getProvider, type ProviderOptions, printEvent } from '@polka-codes/cli-shared'
import { reviewDiff, type SharedAgentOptions, UsageMeter } from '@polka-codes/core'
import { Command } from 'commander'
import { merge } from 'lodash'
import ora, { type Ora } from 'ora'
import { getModel } from '../getModel'
import { parseOptions } from '../options'
import prices from '../prices'
import { runTask } from './task'

type FileChange = {
  path: string
  status: string
}

function parseGitStatus(statusOutput: string): FileChange[] {
  const statusLines = statusOutput.split('\n').filter((line) => line)
  const files: FileChange[] = []

  for (const line of statusLines) {
    const indexStatus = line[0]
    const workingTreeStatus = line[1]
    const filepath = line.slice(3)

    const statuses = []
    if (indexStatus !== ' ' && indexStatus !== '?') {
      switch (indexStatus) {
        case 'A':
          statuses.push('Added (staged)')
          break
        case 'M':
          statuses.push('Modified (staged)')
          break
        case 'D':
          statuses.push('Deleted (staged)')
          break
        case 'R':
          statuses.push('Renamed (staged)')
          break
        case 'C':
          statuses.push('Copied (staged)')
          break
        default:
          statuses.push('Changed (staged)')
      }
    }
    if (workingTreeStatus !== ' ') {
      switch (workingTreeStatus) {
        case 'M':
          statuses.push('Modified (unstaged)')
          break
        case 'D':
          statuses.push('Deleted (unstaged)')
          break
        case '?':
          statuses.push('Untracked')
          break
        default:
          statuses.push('Changed (unstaged)')
      }
    }

    if (statuses.length > 0) {
      files.push({ path: filepath, status: statuses.join(', ') })
    }
  }

  return files
}

function parseGitDiffNameStatus(diffOutput: string): FileChange[] {
  const lines = diffOutput.split('\n').filter((line) => line.trim())
  return lines.map((line) => {
    const [status, ...pathParts] = line.split('\t')
    const path = pathParts.join('\t')
    let statusDescription: string
    switch (status[0]) {
      case 'A':
        statusDescription = 'Added'
        break
      case 'M':
        statusDescription = 'Modified'
        break
      case 'D':
        statusDescription = 'Deleted'
        break
      case 'R':
        statusDescription = 'Renamed'
        break
      case 'C':
        statusDescription = 'Copied'
        break
      case 'T':
        statusDescription = 'Type changed'
        break
      default:
        statusDescription = 'Unknown'
    }
    return { path, status: statusDescription }
  })
}

export const reviewCommand = new Command('review')
  .description('Review a GitHub pull request or local changes')
  .option('--pr <pr>', 'The pull request number or URL to review')
  .option('--json', 'Output the review in JSON format', false)
  .action(async (options: { pr?: string; json: boolean }, command: Command) => {
    const parentOptions = command.parent?.opts() ?? {}
    const { providerConfig, config } = parseOptions(parentOptions)
    const commandConfig = providerConfig.getConfigForCommand('review')

    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      console.error('Error: No provider specified. Please run "polka config" to configure your AI provider.')
      process.exit(1)
    }

    if (!options.json) {
      console.log('Provider:', commandConfig.provider)
      console.log('Model:', commandConfig.model)
    }

    const spinner = ora({
      text: 'Gathering information...',
      stream: process.stderr,
    }).start()

    const usage = new UsageMeter(merge(prices, config.prices ?? {}))
    const customConsole = options.json ? new Console(process.stderr, process.stderr) : console
    const onEvent = printEvent(parentOptions.verbose, usage, customConsole)
    const ai = getModel(commandConfig)
    const toolProviderOptions: ProviderOptions = {
      excludeFiles: parentOptions.config.excludeFiles,
      interactive: parentOptions.interactive,
    }
    const toolProvider = getProvider('analyzer', config, toolProviderOptions)
    const sharedAiOptions = {
      ai,
      usageMeter: usage,
      os: process.platform,
      provider: toolProvider,
      interactive: false,
      policies: [],
      toolFormat: commandConfig.toolFormat,
      callback: parentOptions.verbose > 0 ? onEvent : undefined,
    } satisfies SharedAgentOptions

    try {
      if (options.pr) {
        await reviewPR(options.pr, spinner, sharedAiOptions, options.json, command)
      } else {
        await reviewLocal(spinner, sharedAiOptions, options.json, command)
      }
    } catch (error) {
      spinner.fail(`Error reviewing: ${error instanceof Error ? error.message : String(error)}`)
      console.error(error)
      process.exit(1)
    }
    if (!options.json) {
      usage.printUsage()
    }
  })

async function reviewPR(prIdentifier: string, spinner: Ora, sharedAiOptions: any, isJsonOutput: boolean, command: Command) {
  const prNumberMatch = prIdentifier.match(/\d+$/)
  if (!prNumberMatch) {
    spinner.fail('Invalid PR number or URL.')
    process.exit(1)
  }
  const prNumber = prNumberMatch[0]

  try {
    execSync('gh --version', { stdio: 'ignore' })
  } catch {
    spinner.fail('Error: GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
    process.exit(1)
  }

  try {
    spinner.text = `Checking out PR #${prNumber}...`
    execSync(`gh pr checkout ${prNumber}`, { stdio: 'pipe' })
  } catch (error) {
    spinner.fail(`Error checking out PR #${prNumber}. Make sure the PR number is correct and you have access to the repository.`)
    console.error(error)
    process.exit(1)
  }

  spinner.text = 'Fetching pull request details...'
  const prDetails = JSON.parse(execSync(`gh pr view ${prNumber} --json title,body,commits`, { encoding: 'utf-8' }))
  const defaultBranch = execSync('gh repo view --json defaultBranchRef --jq .defaultBranchRef.name', {
    encoding: 'utf-8',
  }).trim()
  const commitMessages = prDetails.commits.map((c: any) => c.messageBody).join('\n---\n')
  spinner.text = 'Getting file changes...'
  let changedFiles: FileChange[] = []
  try {
    const diffNameStatus = execSync(`git diff --name-status --no-color ${defaultBranch}...HEAD`, { encoding: 'utf-8' })
    changedFiles = parseGitDiffNameStatus(diffNameStatus)
  } catch (_error) {
    // If we can't get file changes, continue without them
    console.warn('Warning: Could not retrieve file changes list')
  }

  printChangedFiles(changedFiles, spinner, isJsonOutput)

  spinner.text = 'Generating review...'
  const result = await reviewDiff(sharedAiOptions, {
    commitRange: `${defaultBranch}...HEAD`,
    pullRequestTitle: prDetails.title,
    pullRequestDescription: prDetails.body,
    commitMessages,
    changedFiles,
  })

  spinner.succeed('Review generated successfully')
  await handleReviewResult(result, isJsonOutput, command)
}

async function reviewLocal(spinner: Ora, sharedAiOptions: any, isJsonOutput: boolean, command: Command) {
  const gitStatus = execSync('git status --porcelain=v1', { encoding: 'utf-8' })
  const statusLines = gitStatus.split('\n').filter((line) => line)

  const hasStagedChanges = statusLines.some((line) => 'MARC'.includes(line[0]))
  const hasUnstagedChanges = statusLines.some((line) => 'MARCDU'.includes(line[1]))

  const changedFiles = parseGitStatus(gitStatus)

  if (hasStagedChanges) {
    spinner.text = 'Generating review for staged changes...'
    const stagedFiles = changedFiles.filter((file) => file.status.includes('staged'))
    printChangedFiles(stagedFiles, spinner, isJsonOutput)
    const result = await reviewDiff(sharedAiOptions, {
      staged: true,
      changedFiles: stagedFiles,
    })
    spinner.succeed('Review generated successfully')
    await handleReviewResult(result, isJsonOutput, command)
    return
  }

  if (hasUnstagedChanges) {
    spinner.text = 'Generating review for unstaged changes...'
    const unstagedFiles = changedFiles.filter((file) => file.status.includes('unstaged') || file.status.includes('Untracked'))
    printChangedFiles(unstagedFiles, spinner, isJsonOutput)
    const result = await reviewDiff(sharedAiOptions, {
      staged: false,
      changedFiles: unstagedFiles,
    })
    spinner.succeed('Review generated successfully')
    await handleReviewResult(result, isJsonOutput, command)
    return
  }

  spinner.text = 'No local changes detected. Falling back to branch diff...'
  spinner.render()

  try {
    execSync('gh --version', { stdio: 'ignore' })
  } catch {
    spinner.fail(
      'Error: GitHub CLI (gh) is not installed, and there are no local changes to review. Please install it from https://cli.github.com/ to review branch changes.',
    )
    process.exit(1)
  }

  const defaultBranch = execSync('gh repo view --json defaultBranchRef --jq .defaultBranchRef.name', {
    encoding: 'utf-8',
  }).trim()

  const currentBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim()

  if (currentBranch === defaultBranch) {
    spinner.succeed(`No changes to review. You are on the default branch ('${defaultBranch}').`)
    process.exit(0)
  }

  spinner.text = 'Getting file changes...'
  let branchChangedFiles: FileChange[] = []
  try {
    const diffNameStatus = execSync(`git diff --name-status --no-color ${defaultBranch}...${currentBranch}`, { encoding: 'utf-8' })
    branchChangedFiles = parseGitDiffNameStatus(diffNameStatus)
  } catch (_error) {
    // If we can't get file changes, continue without them
    console.warn('Warning: Could not retrieve file changes list')
  }

  printChangedFiles(branchChangedFiles, spinner, isJsonOutput)

  spinner.text = `Generating review for changes between '${defaultBranch}' and '${currentBranch}'...`
  const result = await reviewDiff(sharedAiOptions, {
    commitRange: `${defaultBranch}...${currentBranch}`,
    changedFiles: branchChangedFiles,
  })

  spinner.succeed('Review generated successfully')
  await handleReviewResult(result, isJsonOutput, command)
}

async function handleReviewResult(
  result: { overview: string; specificReviews: { file: string; lines: string; review: string }[] },
  isJsonOutput: boolean,
  command: Command,
) {
  if (isJsonOutput) {
    console.log(JSON.stringify(result, null, 2))
    return
  }

  const formatted = formatReviewForConsole(result)
  console.log(formatted)

  if (process.stdin.isTTY && result.specificReviews.length > 0) {
    const shouldRunTask = await confirm({
      message: 'Do you wish polka-codes to address the review results?',
    })

    if (shouldRunTask) {
      const taskInstruction = `please address the review result:

${formatted}`
      await runTask(taskInstruction, {}, command)
    }
  }
}

function formatReviewForConsole(output: { overview: string; specificReviews: { file: string; lines: string; review: string }[] }): string {
  let formatted = `### Overview\n\n${output.overview}`

  if (output.specificReviews.length > 0) {
    formatted += `\n\n### File-specific feedback\n`
    for (const item of output.specificReviews) {
      formatted += `\n- ${item.file}#${item.lines}\n\n${item.review}\n`
    }
  }
  return formatted
}

function printChangedFiles(changedFiles: FileChange[], spinner: Ora, isJsonOutput: boolean) {
  if (changedFiles.length === 0) {
    return
  }
  spinner.stop()
  const stream = isJsonOutput ? process.stderr : process.stdout
  const log = (message: string) =>
    stream.write(`${message}
`)
  log('Changed files:')
  for (const file of changedFiles) {
    log(`- ${file.status}: ${file.path}`)
  }
  spinner.start()
}
