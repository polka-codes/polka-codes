// generated by polka.codes

import type { StepRunResult, UsageMeter } from '@polka-codes/core'
import { Command, InvalidOptionArgumentError } from 'commander'
import { runWorkflowCommand } from '../runWorkflow'
import { type HandleResultOutput, reviewWorkflow } from '../workflows'
import { runTask } from './task'

export const reviewCommand = new Command('review')
  .description('Review a GitHub pull request or local changes')
  .option('--pr <pr>', 'The pull request number or URL to review')
  .option('--json', 'Output the review in JSON format', false)
  .option('-y, --yes', 'Automatically apply review feedback', false)
  .option(
    '--loop [count]',
    'Re-review after changes are applied.',
    (value) => {
      if (value === undefined || value === null) {
        return 1
      }
      const parsedValue = parseInt(value, 10)
      if (Number.isNaN(parsedValue) || parsedValue < 1) {
        throw new InvalidOptionArgumentError('Must be a positive number.')
      }
      return parsedValue
    },
    1,
  )
  .action(async (options: { pr?: string; json: boolean; yes: boolean; loop: number }, command: Command) => {
    const { json, pr, loop: maxIterations, yes: yesOption } = options
    const yes = maxIterations > 1 || yesOption
    let usageMeter: UsageMeter | undefined
    let changesAppliedInThisIteration = false

    const handleSuccess = async (result: StepRunResult<HandleResultOutput>, cmd?: Command, um?: UsageMeter) => {
      if (um) {
        if (usageMeter) {
          usageMeter.merge(um)
        } else {
          usageMeter = um
        }
      }

      if (result.type === 'success' && result.output.shouldRunTask) {
        changesAppliedInThisIteration = true
        if (!cmd) {
          throw new Error('Command object not available in handleSuccess')
        }
        const taskInstruction = `please address the review result:\n\n${result.output.formattedReview}`
        await runTask(taskInstruction, {}, cmd, {
          externalUsageMeter: usageMeter,
          suppressUsagePrint: true, // Suppress usage print within the loop
        })
      }
    }

    for (let i = 0; i < maxIterations; i++) {
      changesAppliedInThisIteration = false
      const input = { json, ...(pr && { pr }), yes }

      if (i > 0) {
        command.opts().silent ||
          console.log(`
Re-running review (iteration ${i + 1} of ${maxIterations})...`)
      }

      await runWorkflowCommand('review', reviewWorkflow, command, input, handleSuccess, {
        json,
        suppressUsagePrint: true, // Always suppress, let handleSuccess decide when to print
      })

      if (maxIterations > 1 && !changesAppliedInThisIteration) {
        command.opts().silent ||
          console.log(`
No more review feedback to apply. Exiting loop.`)
        break
      }
    }

    if (usageMeter && !json) {
      usageMeter.printUsage()
    }
  })
