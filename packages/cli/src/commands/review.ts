// generated by polka.codes

import { existsSync } from 'node:fs'
import { checkbox, select } from '@inquirer/prompts'
import { Command, InvalidOptionArgumentError } from 'commander'
import { code, reviewCode } from '../api'
import { createLogger } from '../logger'
import { formatReviewForConsole } from '../workflows/workflow.utils'

export const reviewCommand = new Command('review')
  .description('Review a GitHub pull request or local changes')
  .argument('[files...]', 'Specific files to review (use --context for review instructions)')
  .option('--pr <pr>', 'The pull request number to review', (value) => {
    const parsedValue = parseInt(value, 10)
    if (Number.isNaN(parsedValue) || parsedValue < 1) {
      throw new InvalidOptionArgumentError('Must be a positive number.')
    }
    return parsedValue
  })
  .option('--context <context>', 'Additional context for the review')
  .option('--json', 'Output the review in JSON format', false)
  .option('-y, --yes', 'Automatically apply review feedback', false)
  .option(
    '--loop [count]',
    'Re-review after changes are applied.',
    (value) => {
      if (value === undefined || value === null) {
        return 1
      }
      const parsedValue = parseInt(value, 10)
      if (Number.isNaN(parsedValue) || parsedValue < 1) {
        throw new InvalidOptionArgumentError('Must be a positive number.')
      }
      return parsedValue
    },
    1,
  )
  .action(
    async (files: string[], options: { pr?: number; context?: string; json: boolean; yes: boolean; loop: number }, command: Command) => {
      const { json, pr, context: contextOption, loop: maxIterations, yes: yesOption } = options
      const yes = maxIterations > 1 || yesOption
      let changesAppliedInThisIteration = false

      let context = contextOption
      let filesToReview = files

      // Heuristic to detect if the positional argument is intended as context
      if (files.length === 1 && !existsSync(files[0]) && files[0].includes(' ') && !context) {
        console.warn(
          'Warning: The argument looks like context but was passed as a file. Treating it as context. Please use --context for review instructions in the future.',
        )
        context = files[0]
        filesToReview = []
      }

      const globalOpts = (command.parent ?? command).opts()
      const { verbose } = globalOpts
      const logger = createLogger({
        verbose: verbose,
      })

      for (let i = 0; i < maxIterations; i++) {
        changesAppliedInThisIteration = false

        if (i > 0) {
          logger.debug(`Re-running review (iteration ${i + 1} of ${maxIterations})...`)
        }

        const reviewResult = await reviewCode({
          pr,
          files: filesToReview.length > 0 ? filesToReview : undefined,
          context,
          interactive: !yes && !json,
          ...globalOpts,
        })

        if (reviewResult) {
          let formattedReview = formatReviewForConsole(reviewResult)
          if (json) {
            console.log(JSON.stringify(reviewResult, null, 2))
          } else if (formattedReview) {
            logger.info(formattedReview)
          }

          let shouldRunTask = false
          if (reviewResult.specificReviews && reviewResult.specificReviews.length > 0) {
            if (yes) {
              shouldRunTask = true
            } else if (process.stdin.isTTY && !json) {
              await new Promise((resolve) => setTimeout(resolve, 50)) // wait for ora to finish
              try {
                const answer = await select({
                  message: 'Do you wish polka-codes to address the review results?',
                  choices: [
                    { name: 'No', value: 'no' },
                    { name: 'Yes', value: 'yes' },
                    { name: 'Select findings', value: 'select' },
                  ],
                  default: 'no',
                })

                if (answer === 'yes') {
                  shouldRunTask = true
                } else if (answer === 'select') {
                  const selectedIndices = await checkbox({
                    message: 'Select findings to address',
                    choices: reviewResult.specificReviews.map((review, index) => ({
                      name: `${review.file}:${review.lines} - ${review.review.split('\n')[0]}`,
                      value: index,
                      checked: true,
                    })),
                  })

                  if (selectedIndices.length > 0) {
                    shouldRunTask = true
                    reviewResult.specificReviews = reviewResult.specificReviews.filter((_, index) => selectedIndices.includes(index))
                    formattedReview = formatReviewForConsole(reviewResult)
                  }
                }
              } catch (error) {
                if (error instanceof Error && error.name === 'ExitPromptError') {
                  return
                }
              }
            }
          }

          if (shouldRunTask && formattedReview) {
            changesAppliedInThisIteration = true
            const taskInstruction = `please address the review result:\n\n${formattedReview}`
            await code({
              task: taskInstruction,
              interactive: !yes,
              ...globalOpts,
            })
          }
        }

        if (maxIterations > 1 && !changesAppliedInThisIteration) {
          logger.debug('No more review feedback to apply. Exiting loop.')
          break
        }
      }
    },
  )
