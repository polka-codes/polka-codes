// generated by polka.codes

import { checkbox, select } from '@inquirer/prompts'
import { Command, InvalidOptionArgumentError } from 'commander'
import { createLogger } from '../logger'
import { runWorkflow } from '../runWorkflow'
import type { CliToolRegistry } from '../workflow-tools'
import { codeWorkflow, type ReviewWorkflowInput, reviewWorkflow } from '../workflows'
import { formatReviewForConsole, type ReviewResult } from '../workflows/workflow.utils'

export const reviewCommand = new Command('review')
  .description('Review a GitHub pull request or local changes')
  .argument('[context]', 'Additional context for the review')
  .option('--pr <pr>', 'The pull request number to review', (value) => {
    const parsedValue = parseInt(value, 10)
    if (Number.isNaN(parsedValue) || parsedValue < 1) {
      throw new InvalidOptionArgumentError('Must be a positive number.')
    }
    return parsedValue
  })
  .option('--json', 'Output the review in JSON format', false)
  .option('-y, --yes', 'Automatically apply review feedback', false)
  .option(
    '--loop [count]',
    'Re-review after changes are applied.',
    (value) => {
      if (value === undefined || value === null) {
        return 1
      }
      const parsedValue = parseInt(value, 10)
      if (Number.isNaN(parsedValue) || parsedValue < 1) {
        throw new InvalidOptionArgumentError('Must be a positive number.')
      }
      return parsedValue
    },
    1,
  )
  .action(async (context: string | undefined, options: { pr?: number; json: boolean; yes: boolean; loop: number }, command: Command) => {
    const { json, pr, loop: maxIterations, yes: yesOption } = options
    const yes = maxIterations > 1 || yesOption
    let changesAppliedInThisIteration = false

    const globalOpts = (command.parent ?? command).opts()
    const { verbose } = globalOpts
    const logger = createLogger({
      verbose: verbose,
    })

    for (let i = 0; i < maxIterations; i++) {
      changesAppliedInThisIteration = false
      const input = { pr, context }

      if (i > 0) {
        logger.debug(`Re-running review (iteration ${i + 1} of ${maxIterations})...`)
      }

      const reviewResult = await runWorkflow<ReviewWorkflowInput, ReviewResult, CliToolRegistry>(reviewWorkflow, input, {
        commandName: 'review',
        command,
        logger,
        interactive: !yes && !json,
      })

      if (reviewResult) {
        let formattedReview = formatReviewForConsole(reviewResult)
        if (json) {
          console.log(JSON.stringify(reviewResult, null, 2))
        } else if (formattedReview) {
          logger.info(formattedReview)
        }

        let shouldRunTask = false
        if (reviewResult.specificReviews && reviewResult.specificReviews.length > 0) {
          if (yes) {
            shouldRunTask = true
          } else if (process.stdin.isTTY && !json) {
            await new Promise((resolve) => setTimeout(resolve, 50)) // wait for ora to finish
            try {
              const answer = await select({
                message: 'Do you wish polka-codes to address the review results?',
                choices: [
                  { name: 'No', value: 'no' },
                  { name: 'Yes', value: 'yes' },
                  { name: 'Select findings', value: 'select' },
                ],
                default: 'no',
              })

              if (answer === 'yes') {
                shouldRunTask = true
              } else if (answer === 'select') {
                const selectedIndices = await checkbox({
                  message: 'Select findings to address',
                  choices: reviewResult.specificReviews.map((review, index) => ({
                    name: `${review.file}:${review.lines} - ${review.review.split('\n')[0]}`,
                    value: index,
                    checked: true,
                  })),
                })

                if (selectedIndices.length > 0) {
                  shouldRunTask = true
                  reviewResult.specificReviews = reviewResult.specificReviews.filter((_, index) => selectedIndices.includes(index))
                  formattedReview = formatReviewForConsole(reviewResult)
                }
              }
            } catch (error) {
              if (error instanceof Error && error.name === 'ExitPromptError') {
                return
              }
            }
          }
        }

        if (shouldRunTask && formattedReview) {
          changesAppliedInThisIteration = true
          const taskInstruction = `please address the review result:\n\n${formattedReview}`
          await runWorkflow(
            codeWorkflow,
            {
              task: taskInstruction,
            },
            {
              commandName: 'code',
              command,
              logger,
              interactive: !yes,
            },
          )
        }
      }

      if (maxIterations > 1 && !changesAppliedInThisIteration) {
        logger.debug('No more review feedback to apply. Exiting loop.')
        break
      }
    }
  })
