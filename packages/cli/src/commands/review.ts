// generated by polka.codes

import { Console } from 'node:console'
import os from 'node:os'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { getProvider, type ProviderOptions, printEvent } from '@polka-codes/cli-shared'
import {
  type AgentStepSpec,
  combineHandlers,
  customStepSpecHandler,
  EnableCachePolicy,
  makeAgentStepSpecHandler,
  run,
  sequentialStepSpecHandler,
  UsageMeter,
  type WorkflowContext,
} from '@polka-codes/core'
import { Command } from 'commander'
import { merge } from 'lodash'
import ora from 'ora'
import { getModel } from '../getModel'
import { parseOptions } from '../options'
import prices from '../prices'
import { type ReviewWorkflowContext, reviewWorkflow } from '../workflows'
import { runTask } from './task'

export const reviewCommand = new Command('review')
  .description('Review a GitHub pull request or local changes')
  .option('--pr <pr>', 'The pull request number or URL to review')
  .option('--json', 'Output the review in JSON format', false)
  .action(async (options: { pr?: string; json: boolean }, command: Command) => {
    const parentOptions = command.parent?.opts() ?? {}
    const { providerConfig, config, verbose } = parseOptions(parentOptions)
    const commandConfig = providerConfig.getConfigForCommand('review')

    if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
      console.error('Error: No provider specified. Please run "polka config" to configure your AI provider.')
      process.exit(1)
    }

    if (!options.json) {
      console.log('Provider:', commandConfig.provider)
      console.log('Model:', commandConfig.model)
    }

    const agentStepHandler = makeAgentStepSpecHandler(async (_step: AgentStepSpec, _context: WorkflowContext): Promise<LanguageModelV2> => {
      const commandConfig = providerConfig.getConfigForCommand('review')
      if (!commandConfig || !commandConfig.provider || !commandConfig.model) {
        throw new Error('No provider specified for the agent step.')
      }
      // You can add logic here to select different models based on the step if needed
      return getModel(commandConfig)
    })

    const coreStepHandler = combineHandlers(customStepSpecHandler, sequentialStepSpecHandler, agentStepHandler)

    const spinner = ora({
      text: 'Gathering information...',
      stream: process.stderr,
    }).start()

    const usage = new UsageMeter(merge(prices, config.prices ?? {}), { maxMessages: config.maxMessageCount, maxCost: config.budget })
    const customConsole = options.json ? new Console(process.stderr, process.stderr) : console
    const onEvent = verbose > 0 ? printEvent(verbose, usage, customConsole) : undefined
    const toolProviderOptions: ProviderOptions = {
      excludeFiles: config.excludeFiles,
    }
    const toolProvider = getProvider(toolProviderOptions)

    const agentConfig = providerConfig.getConfigForCommand('review')

    const context: ReviewWorkflowContext = {
      ui: { spinner },
      provider: toolProvider,
      parameters: {
        toolFormat: config.toolFormat,
        os: os.platform(),
        policies: [EnableCachePolicy],
        modelParameters: agentConfig?.parameters,
        scripts: config.scripts,
        retryCount: config.retryCount,
        requestTimeoutSeconds: config.requestTimeoutSeconds,
      },
      verbose,
      agentCallback: onEvent,
      logger: customConsole,
    }

    const input = { json: options.json, ...(options.pr && { pr: options.pr }) }

    try {
      const result = await run(reviewWorkflow, context, coreStepHandler, input)

      if (result.type === 'success') {
        if (result.output.shouldRunTask) {
          const taskInstruction = `please address the review result:

${result.output.formattedReview}`
          await runTask(taskInstruction, {}, command)
        }
      } else if (result.type === 'error') {
        if (result.error) {
          spinner.fail(`Error reviewing: ${result.error.message}`)
          console.error(result.error)
        } else {
          spinner.fail('Error reviewing: An unknown error occurred')
        }
        process.exit(1)
      }
    } catch (error) {
      spinner.fail(`Error reviewing: ${error instanceof Error ? error.message : String(error)}`)
      console.error(error)
      process.exit(1)
    } finally {
      if (!options.json) {
        usage.printUsage()
      }
    }
  })
