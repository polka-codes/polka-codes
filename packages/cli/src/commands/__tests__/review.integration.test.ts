// Integration test for review command with --json flag
// generated by polka.codes

import { afterEach, beforeEach, describe, expect, it } from 'bun:test'
import { mkdirSync, rmSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'

describe('Review Command JSON Flag Integration Tests', () => {
  const testProjectDir = join(process.cwd(), 'test-review-json')
  const testFilePath = join(testProjectDir, 'test-file.ts')

  beforeEach(() => {
    // Create test project directory
    mkdirSync(testProjectDir, { recursive: true })

    // Initialize git repository
    const { spawnSync } = require('node:child_process')
    spawnSync('git', ['init'], { cwd: testProjectDir, stdio: 'ignore' })
    spawnSync('git', ['config', 'user.email', 'test@example.com'], { cwd: testProjectDir, stdio: 'ignore' })
    spawnSync('git', ['config', 'user.name', 'Test User'], { cwd: testProjectDir, stdio: 'ignore' })

    // Create a test file with code to review
    const testFileContent = `// Test file for review
function add(a: number, b: number): number {
  return a + b
}

function multiply(a: number, b: number): number {
  return a * b
}

// TODO: Fix this function
function buggyFunction(n: number) {
  if (n = 0) {  // Assignment instead of comparison
    return 0
  }
  return n
}
`
    writeFileSync(testFilePath, testFileContent)

    // Stage and commit the initial file
    spawnSync('git', ['add', '.'], { cwd: testProjectDir, stdio: 'ignore' })
    spawnSync('git', ['commit', '-m', 'Initial commit'], { cwd: testProjectDir, stdio: 'ignore' })
  })

  afterEach(() => {
    // Cleanup test project directory
    try {
      rmSync(testProjectDir, { recursive: true, force: true })
    } catch {
      // Directory doesn't exist
    }
  })

  describe('reviewCode API with JSON output', () => {
    it('should return ReviewResult with correct structure', async () => {
      // Modify the file to create changes
      const modifiedContent = `// Modified test file for review
function add(a: number, b: number): number {
  return a + b
}

function multiply(a: number, b: number): number {
  return a * b
}

// TODO: Fix this function
function buggyFunction(n: number) {
  if (n = 0) {  // Assignment instead of comparison
    return 0
  }
  return n
}

// New function with issues
function divide(a: number, b: number): number {
  return a / b  // No zero check
}
`
      writeFileSync(testFilePath, modifiedContent)

      // Mock the API call to avoid actual AI calls in tests
      // This test verifies the structure and JSON serialization
      const mockReviewResult = {
        overview: 'The code introduces a divide function without proper error handling.',
        specificReviews: [
          {
            file: 'test-file.ts',
            lines: '18',
            review: 'Consider adding zero-check for division operation to prevent runtime errors.',
          },
          {
            file: 'test-file.ts',
            lines: '11',
            review: 'The comparison operator should be === instead of = for assignment.',
          },
        ],
      }

      // Verify the result can be serialized to JSON
      const jsonOutput = JSON.stringify(mockReviewResult, null, 2)

      expect(jsonOutput).toBeDefined()
      expect(jsonOutput).toContain('"overview"')
      expect(jsonOutput).toContain('"specificReviews"')
      expect(jsonOutput).toContain('"file"')
      expect(jsonOutput).toContain('"lines"')
      expect(jsonOutput).toContain('"review"')

      // Verify the result can be parsed back
      const parsed = JSON.parse(jsonOutput)
      expect(parsed.overview).toBe(mockReviewResult.overview)
      expect(parsed.specificReviews).toHaveLength(2)
      expect(parsed.specificReviews[0].file).toBe('test-file.ts')
      expect(parsed.specificReviews[0].lines).toBe('18')
    })

    it('should handle review with no specific reviews', () => {
      const mockReviewResult = {
        overview: 'No issues found in the code changes.',
        specificReviews: [],
      }

      const jsonOutput = JSON.stringify(mockReviewResult, null, 2)

      expect(jsonOutput).toBeDefined()
      expect(jsonOutput).toContain('"overview"')
      expect(jsonOutput).toContain('"specificReviews"')

      const parsed = JSON.parse(jsonOutput)
      expect(parsed.overview).toBe('No issues found in the code changes.')
      expect(parsed.specificReviews).toEqual([])
    })

    it('should handle review with missing specificReviews field', () => {
      const mockReviewResult = {
        overview: 'Code looks good overall.',
      }

      const jsonOutput = JSON.stringify(mockReviewResult, null, 2)

      expect(jsonOutput).toBeDefined()
      expect(jsonOutput).toContain('"overview"')

      const parsed = JSON.parse(jsonOutput)
      expect(parsed.overview).toBe('Code looks good overall.')
      expect(parsed.specificReviews).toBeUndefined()
    })
  })

  describe('ReviewResult schema validation', () => {
    it('should validate ReviewResult structure', () => {
      // Test complete ReviewResult
      const completeResult = {
        overview: 'Test overview',
        specificReviews: [
          {
            file: 'test.ts',
            lines: '10',
            review: 'Test review comment',
          },
        ],
      }

      expect(completeResult.overview).toBeDefined()
      expect(typeof completeResult.overview).toBe('string')
      expect(Array.isArray(completeResult.specificReviews)).toBe(true)
      expect(completeResult.specificReviews?.[0].file).toBeDefined()
      expect(completeResult.specificReviews?.[0].lines).toBeDefined()
      expect(completeResult.specificReviews?.[0].review).toBeDefined()
    })

    it('should validate required fields in specificReviews', () => {
      const specificReview = {
        file: 'src/example.ts',
        lines: '42',
        review: 'This is a code review comment suggesting improvements.',
      }

      expect(specificReview.file).toBeDefined()
      expect(typeof specificReview.file).toBe('string')
      expect(specificReview.lines).toBeDefined()
      expect(typeof specificReview.lines).toBe('string')
      expect(specificReview.review).toBeDefined()
      expect(typeof specificReview.review).toBe('string')
    })

    it('should handle empty specificReviews array', () => {
      const result = {
        overview: 'No issues found',
        specificReviews: [],
      }

      expect(Array.isArray(result.specificReviews)).toBe(true)
      expect(result.specificReviews).toHaveLength(0)
    })
  })

  describe('JSON output formatting', () => {
    it('should format review output as valid JSON', () => {
      const reviewResult = {
        overview: 'Multiple issues found in the codebase.',
        specificReviews: [
          {
            file: 'src/utils.ts',
            lines: '15',
            review: 'Consider adding error handling for edge cases.',
          },
          {
            file: 'src/types.ts',
            lines: '8',
            review: 'Type definition could be more specific.',
          },
          {
            file: 'src/api.ts',
            lines: '23',
            review: 'Missing return type annotation.',
          },
        ],
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)

      // Verify it's valid JSON
      expect(() => JSON.parse(jsonOutput)).not.toThrow()

      // Verify formatting with indentation
      expect(jsonOutput).toContain('\n')
      expect(jsonOutput).toContain('  ')

      // Verify all fields are present
      const parsed = JSON.parse(jsonOutput)
      expect(parsed.overview).toBe(reviewResult.overview)
      expect(parsed.specificReviews).toHaveLength(3)
    })

    it('should handle special characters in review text', () => {
      const reviewResult = {
        overview: 'Code contains issues with special characters: "quotes", \n newlines, and \t tabs.',
        specificReviews: [
          {
            file: 'test.js',
            lines: '10',
            review: 'Line contains: "string with quotes", \'single quotes\', and emojis ðŸ›',
          },
        ],
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)

      // Should not throw when parsing
      expect(() => JSON.parse(jsonOutput)).not.toThrow()

      const parsed = JSON.parse(jsonOutput)
      expect(parsed.overview).toContain('"quotes"')
      expect(parsed.specificReviews![0].review).toContain('emojis ðŸ›')
    })

    it('should handle unicode characters in file paths and reviews', () => {
      const reviewResult = {
        overview: 'Review for internationalized code',
        specificReviews: [
          {
            file: 'src/ç»„ä»¶/æµ‹è¯•.ts',
            lines: '5',
            review: 'è€ƒè™‘æ·»åŠ å›½é™…åŒ–æ”¯æŒ',
          },
        ],
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)

      const parsed = JSON.parse(jsonOutput)
      expect(parsed.specificReviews![0].file).toBe('src/ç»„ä»¶/æµ‹è¯•.ts')
      expect(parsed.specificReviews![0].review).toBe('è€ƒè™‘æ·»åŠ å›½é™…åŒ–æ”¯æŒ')
    })
  })

  describe('Integration with review workflow', () => {
    it('should preserve data structure through serialization round-trip', () => {
      const originalResult = {
        overview: 'Comprehensive code review summary',
        specificReviews: [
          {
            file: 'src/core.ts',
            lines: '42',
            review: 'Function should handle null values',
          },
          {
            file: 'src/helpers.ts',
            lines: '15-20',
            review: 'Consider splitting this into smaller functions',
          },
          {
            file: 'config.json',
            lines: '1',
            review: 'Add validation for configuration values',
          },
        ],
      }

      // Serialize to JSON
      const jsonString = JSON.stringify(originalResult, null, 2)

      // Parse back from JSON
      const restoredResult = JSON.parse(jsonString)

      // Verify all data is preserved
      expect(restoredResult).toEqual(originalResult)
      expect(restoredResult.overview).toBe(originalResult.overview)
      expect(restoredResult.specificReviews).toHaveLength(originalResult.specificReviews!.length)

      for (let i = 0; i < restoredResult.specificReviews!.length; i++) {
        expect(restoredResult.specificReviews![i]).toEqual(originalResult.specificReviews![i])
      }
    })

    it('should handle complex line number formats', () => {
      const reviewResult = {
        overview: 'Issues found',
        specificReviews: [
          { file: 'test.ts', lines: '1', review: 'Single line' },
          { file: 'test.ts', lines: '10-15', review: 'Range of lines' },
          { file: 'test.ts', lines: '100,105', review: 'Multiple specific lines' },
          { file: 'test.ts', lines: '200-210,215', review: 'Mixed format' },
        ],
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)
      const parsed = JSON.parse(jsonOutput)

      expect(parsed.specificReviews![0].lines).toBe('1')
      expect(parsed.specificReviews![1].lines).toBe('10-15')
      expect(parsed.specificReviews![2].lines).toBe('100,105')
      expect(parsed.specificReviews![3].lines).toBe('200-210,215')
    })
  })

  describe('Edge cases and error handling', () => {
    it('should handle very long review comments', () => {
      const longReview = `${'This is a very long review comment. '.repeat(50)}End of review.`

      const reviewResult = {
        overview: 'Code has issues that need detailed explanation',
        specificReviews: [
          {
            file: 'long-file.ts',
            lines: '1-1000',
            review: longReview,
          },
        ],
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)
      const parsed = JSON.parse(jsonOutput)

      expect(parsed.specificReviews![0].review.length).toBe(longReview.length)
      expect(parsed.specificReviews![0].review).toBe(longReview)
    })

    it('should handle review with many specific reviews', () => {
      const specificReviews = Array.from({ length: 100 }, (_, i) => ({
        file: `file-${i}.ts`,
        lines: `${i + 1}`,
        review: `Review comment for file ${i}`,
      }))

      const reviewResult = {
        overview: 'Many issues found across the codebase',
        specificReviews,
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)
      const parsed = JSON.parse(jsonOutput)

      expect(parsed.specificReviews).toHaveLength(100)
      expect(parsed.specificReviews![99].file).toBe('file-99.ts')
    })

    it('should handle empty overview', () => {
      const reviewResult = {
        overview: '',
        specificReviews: [
          {
            file: 'test.ts',
            lines: '1',
            review: 'Specific review',
          },
        ],
      }

      const jsonOutput = JSON.stringify(reviewResult, null, 2)
      const parsed = JSON.parse(jsonOutput)

      expect(parsed.overview).toBe('')
      expect(parsed.specificReviews![0].review).toBe('Specific review')
    })
  })
})
