// generated by polka.codes
import { afterEach, beforeEach, describe, expect, it } from 'bun:test'
import { randomUUID } from 'node:crypto'
import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from 'node:fs'
import { tmpdir } from 'node:os'
import { join } from 'node:path'
import { loadConfig } from '@polka-codes/cli-shared'

/**
 * Test fixture for isolated temporary directory management
 */
class TempDirectoryFixture {
  private dir: string | null = null

  async setup(): Promise<string> {
    this.dir = join(tmpdir(), `test-script-${randomUUID()}`)
    mkdirSync(this.dir, { recursive: true })
    return this.dir
  }

  async teardown(): Promise<void> {
    if (this.dir) {
      try {
        rmSync(this.dir, { recursive: true, force: true })
      } catch (error) {
        console.error(`[TempDirectoryFixture] Failed to cleanup: ${this.dir}`, error)
      }
      this.dir = null
    }
  }

  getPath(...segments: string[]): string {
    if (!this.dir) {
      throw new Error('TempDirectoryFixture not initialized. Call setup() first.')
    }
    return join(this.dir, ...segments)
  }
}

describe('Script Generator Integration Tests', () => {
  let fixture: TempDirectoryFixture
  let testProjectDir: string
  let configPath: string
  let scriptsDir: string

  beforeEach(async () => {
    fixture = new TempDirectoryFixture()
    testProjectDir = await fixture.setup()
    configPath = join(testProjectDir, '.polkacodes.yml')
    scriptsDir = join(testProjectDir, '.polka-scripts')

    // Create test project directory
    mkdirSync(scriptsDir, { recursive: true })

    // Create initial config
    const configContent = `# PolkaCodes configuration
`
    writeFileSync(configPath, configContent)
  })

  afterEach(async () => {
    await fixture.teardown()
  })

  describe('Script template creation', () => {
    it('should create a valid script template', () => {
      const scriptName = 'test-script'
      const scriptPath = join(scriptsDir, `${scriptName}.ts`)

      // Create script template
      const template = `// Generated by polka.codes
import { code, commit } from '@polka-codes/cli'

export async function main(args: string[]) {
  console.log('Running script: ${scriptName}')
  console.log('Arguments:', args)

  // Your automation here
  // await code({ task: 'Add feature', interactive: false })
  // await commit({ all: true, context: 'Feature complete' })

  console.log('Script completed successfully')
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`

      writeFileSync(scriptPath, template)

      expect(existsSync(scriptPath)).toBe(true)

      const content = readFileSync(scriptPath, 'utf-8')
      expect(content).toContain('export async function main')
      expect(content).toContain(scriptName)
      expect(content).toContain("import { code, commit } from '@polka-codes/cli'")
    })

    it('should create script with proper structure', () => {
      const scriptName = 'structured-script'
      const scriptPath = join(scriptsDir, `${scriptName}.ts`)

      const template = `// Generated by polka.codes
export async function main(args: string[]) {
  return { success: true }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`

      writeFileSync(scriptPath, template)

      const content = readFileSync(scriptPath, 'utf-8')
      expect(content).toContain('// Generated by polka.codes')
      expect(content).toContain('export async function main')
      expect(content).toContain('if (import.meta.main)')
    })
  })

  describe('Script naming validation', () => {
    it('should reject script names with slashes', () => {
      const invalidNames = ['invalid/name', 'invalid\\name', 'path/to/script', 'path\\to\\script']

      for (const name of invalidNames) {
        expect(() => {
          // Simulate validation
          if (name.includes('/') || name.includes('\\')) {
            throw new Error('Script name cannot contain slashes')
          }
        }).toThrow('cannot contain slashes')
      }
    })

    it('should accept valid script names', () => {
      const validNames = ['deploy', 'build-and-deploy', 'test123', 'my_script', 'CamelCase']

      for (const name of validNames) {
        expect(() => {
          // Simulate validation
          if (name.includes('/') || name.includes('\\')) {
            throw new Error('Invalid name')
          }
        }).not.toThrow()
      }
    })
  })

  describe('Config update behavior', () => {
    it('should add scripts section if it does not exist', () => {
      // Start with config without scripts section
      writeFileSync(configPath, '# Empty config\n')

      // Simulate adding a script to config
      const currentContent = readFileSync(configPath, 'utf-8')
      const updatedContent = `${currentContent}
scripts:
  new-script: .polka-scripts/new-script.ts
`
      writeFileSync(configPath, updatedContent)

      const configContent = readFileSync(configPath, 'utf-8')
      expect(configContent).toContain('scripts:')
      expect(configContent).toContain('new-script')
    })

    it('should append to existing scripts section', () => {
      // Start with existing scripts
      const initialConfig = `scripts:
  existing-script: .polka-scripts/existing.ts
`
      writeFileSync(configPath, initialConfig)

      // Simulate adding another script
      const currentContent = readFileSync(configPath, 'utf-8')
      const updatedContent = `${currentContent}
  new-script: .polka-scripts/new.ts
`
      writeFileSync(configPath, updatedContent)

      const configContent = readFileSync(configPath, 'utf-8')
      expect(configContent).toContain('existing-script')
      expect(configContent).toContain('new-script')
    })

    it('should preserve existing config structure', () => {
      const initialConfig = `# Project configuration
defaultProvider: openai
defaultModel: gpt-4

maxMessageCount: 50
`
      writeFileSync(configPath, initialConfig)

      // Simulate adding scripts
      const currentContent = readFileSync(configPath, 'utf-8')
      const updatedContent = `${currentContent}
scripts:
  new-script: .polka-scripts/new.ts
`
      writeFileSync(configPath, updatedContent)

      const configContent = readFileSync(configPath, 'utf-8')
      expect(configContent).toContain('defaultProvider:')
      expect(configContent).toContain('defaultModel:')
      expect(configContent).toContain('maxMessageCount:')
      expect(configContent).toContain('scripts:')
      expect(configContent).toContain('new-script')
    })
  })

  describe('Script execution via runner', () => {
    it('should create executable script that can be run', async () => {
      const scriptName = 'runnable-script'
      const scriptPath = join(scriptsDir, `${scriptName}.ts`)

      const template = `// Generated by polka.codes
export async function main(args: string[]) {
  console.log('Running script: ${scriptName}')
  return { success: true, args }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`

      writeFileSync(scriptPath, template)

      // Verify script file exists
      expect(existsSync(scriptPath)).toBe(true)

      // Verify script can be imported (simulating execution)
      const absolutePath = join(scriptsDir, `${scriptName}.ts`)
      delete require.cache[absolutePath]
      const scriptModule = await import(absolutePath)

      expect(typeof scriptModule.main).toBe('function')

      const result = await scriptModule.main(['--test'])
      expect(result.success).toBe(true)
      expect(result.args).toEqual(['--test'])
    })

    it('should create script that accepts arguments', async () => {
      const scriptName = 'args-script'
      const scriptPath = join(scriptsDir, `${scriptName}.ts`)

      const template = `// Generated by polka.codes
export async function main(args: string[]) {
  return {
    scriptName: '${scriptName}',
    arguments: args,
    count: args.length
  }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`

      writeFileSync(scriptPath, template)

      // Test with arguments
      const absolutePath = join(scriptsDir, `${scriptName}.ts`)
      delete require.cache[absolutePath]
      const scriptModule = await import(absolutePath)

      const testArgs = ['--arg1', '--arg2', 'test-value']
      const result = await scriptModule.main(testArgs)

      expect(result.scriptName).toBe(scriptName)
      expect(result.arguments).toEqual(testArgs)
      expect(result.count).toBe(3)
    })
  })

  describe('Multiple script creation', () => {
    it('should handle multiple scripts in directory', () => {
      const scriptNames = ['script1', 'script2', 'script3']

      for (const name of scriptNames) {
        const scriptPath = join(scriptsDir, `${name}.ts`)
        const template = `export async function main(args: string[]) {
  return { name: '${name}' }
}

if (import.meta.main) {
  main(process.argv.slice(2))
}
`
        writeFileSync(scriptPath, template)
      }

      // Verify all scripts were created
      for (const name of scriptNames) {
        const scriptPath = join(scriptsDir, `${name}.ts`)
        expect(existsSync(scriptPath)).toBe(true)
      }

      // Verify config can be updated with all scripts
      const currentContent = readFileSync(configPath, 'utf-8')
      const scriptsSection = scriptNames.map((name) => `  ${name}: .polka-scripts/${name}.ts`).join('\n')
      const updatedContent = `${currentContent}
scripts:
${scriptsSection}
`
      writeFileSync(configPath, updatedContent)

      const configContent = readFileSync(configPath, 'utf-8')
      for (const name of scriptNames) {
        expect(configContent).toContain(name)
      }
    })
  })

  describe('Config loading after script creation', () => {
    it('should load config with newly created scripts', async () => {
      // Create script files
      writeFileSync(
        join(scriptsDir, 'deploy.ts'),
        `export async function main(args: string[]) {
  return { deployed: true }
}`,
      )
      writeFileSync(
        join(scriptsDir, 'build.ts'),
        `export async function main(args: string[]) {
  return { built: true }
}`,
      )

      // Update config
      const configContent = `
scripts:
  deploy:
    script: .polka-scripts/deploy.ts
    description: Deploy to production
  build:
    script: .polka-scripts/build.ts
    description: Build project
`
      writeFileSync(configPath, configContent)

      // Load and verify config
      const config = await loadConfig([], testProjectDir)
      expect(config).toBeDefined()
      expect(config?.scripts).toBeDefined()
      expect(config?.scripts?.deploy).toBeDefined()
      expect(config?.scripts?.build).toBeDefined()
    })
  })
})
