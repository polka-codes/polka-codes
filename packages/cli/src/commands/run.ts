/**
 * Run custom scripts command
 *
 * Provides explicit script execution with:
 * - List all available scripts
 * - Execute specific scripts by name
 * - Pass arguments to scripts
 * Generated by polka.codes
 */

import { spawnSync } from 'node:child_process'
import { loadConfig } from '@polka-codes/cli-shared'
import type { Config, Logger, ScriptConfig } from '@polka-codes/core'
import { Command } from 'commander'
import { createLogger } from '../logger'
import { ScriptRunner } from '../script'

/**
 * Execute a shell command with proper argument handling
 */
function executeShellCommand(fullCommand: string): void {
  const result = spawnSync(fullCommand, [], {
    stdio: 'inherit',
    shell: true,
  })

  if (result.status !== 0) {
    throw new Error(`Command failed with exit code ${result.status}`)
  }
}

export const runCommand = new Command('run')
  .description('Run custom scripts')
  .argument('[script-name]', 'Name of the script to run')
  .option('--list', 'List all available scripts')
  .option('--args <args...>', 'Arguments to pass to the script')
  .action(async (scriptName, options, command: Command) => {
    const globalOpts = (command.parent ?? command).opts()
    const { verbose } = globalOpts
    const logger = createLogger({
      verbose,
    })

    const config = await loadConfig()

    // Handle --list flag
    if (options.list) {
      listAvailableScripts(config, logger)
      return
    }

    // Validate script name provided
    if (!scriptName) {
      logger.error('Error: No script name provided')
      logger.info('Usage: polka run <script-name>')
      logger.info('   Use --list to see available scripts')
      process.exit(1)
    }

    // Find script in config
    const script = config?.scripts?.[scriptName]
    if (!script) {
      logger.error(`Error: Script '${scriptName}' not found`)
      logger.info('Available scripts:')
      listAvailableScripts(config, logger)
      process.exit(1)
    }

    // Execute the script
    await executeScript(script, scriptName, logger, options.args || [])
  })

/**
 * List all available scripts from config
 */
function listAvailableScripts(config: Config | undefined, logger: Logger) {
  const scripts = config?.scripts

  if (!scripts || Object.keys(scripts).length === 0) {
    logger.info('No custom scripts configured.')
    logger.info('Add scripts to your .polkacodes.yml:')
    logger.info('  scripts:')
    logger.info('    my-script:')
    logger.info('      script: ./scripts/my-script.ts')
    logger.info('      description: My custom automation')
    return
  }

  logger.info('Available scripts:')
  for (const [name, scriptConfig] of Object.entries(scripts)) {
    const desc = getScriptDescription(scriptConfig)
    logger.info(`  ${name}${desc ? ` - ${desc}` : ''}`)
  }
}

/**
 * Get description from a script configuration
 */
function getScriptDescription(script: ScriptConfig): string | undefined {
  if (typeof script === 'string') {
    return undefined
  }
  return script.description
}

/**
 * Execute a script (shell command, workflow, or TypeScript)
 */
async function executeScript(script: ScriptConfig, name: string, logger: Logger, args: string[]) {
  const runner = new ScriptRunner()

  try {
    // Determine script type and execute
    if (typeof script === 'string') {
      // Shell command - construct full command with properly quoted arguments
      const fullCommand = args.length > 0 ? `${script} ${quoteArgs(args)}` : script
      logger.debug(`Executing shell command: ${fullCommand}`)
      executeShellCommand(fullCommand)
    } else if ('command' in script) {
      // Shell command with description - construct full command with properly quoted arguments
      const fullCommand = args.length > 0 ? `${script.command} ${quoteArgs(args)}` : script.command
      logger.debug(`Executing shell command: ${fullCommand}`)
      executeShellCommand(fullCommand)
    } else if ('workflow' in script) {
      // Dynamic workflow YAML
      logger.error(`Error: workflow execution not yet implemented for '${name}'`)
      logger.info('Workflow scripts will be supported in a future update.')
      process.exit(1)
    } else if ('script' in script) {
      // TypeScript script
      logger.debug(`Executing TypeScript script: ${script.script}`)
      const result = await runner.execute({
        scriptPath: script.script,
        args,
        context: {},
        logger,
        timeout: script.timeout,
      })

      if (!result.success && result.error) {
        logger.error(`Script '${name}' failed: ${result.error.message}`)
        process.exit(1)
      }
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    logger.error(`Script '${name}' failed: ${errorMessage}`)
    process.exit(1)
  }
}

/**
 * Quote shell arguments to handle spaces and special characters
 * Note: Uses POSIX-style quoting (single quotes). For Windows cmd.exe compatibility,
 * consider using a cross-platform quoting library in the future.
 */
function quoteArgs(args: string[]): string {
  return args
    .map((arg) => {
      // Use single quotes and escape any existing single quotes
      return `'${arg.replace(/'/g, "'\\''")}'`
    })
    .join(' ')
}
