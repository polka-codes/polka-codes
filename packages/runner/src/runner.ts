import { getProvider, loadConfig } from '@polka-codes/cli-shared'
import {
  type FullToolInfo,
  ToolResponseType,
  executeCommand,
  listCodeDefinitionNames,
  listFiles,
  readFile,
  removeFile,
  renameFile,
  replaceInFile,
  responsePrompts,
  searchFiles,
  writeToFile,
} from '@polka-codes/core'
// Generated by polka.codes
import chalk from 'chalk'
import WebSocket from 'ws'

import { type WsOutgoingMessage, wsIncomingMessageSchema } from './types'

export interface RunnerOptions {
  taskId: string
  sessionToken: string
  githubToken?: string
  api: string
}

export async function runRunner(options: RunnerOptions): Promise<void> {
  if (!options.taskId) {
    console.error('Error: Task ID is required.')
    process.exit(1)
  }
  if (!options.githubToken) {
    console.error('Error: GitHub token is required. Provide it via --github-token or GITHUB_TOKEN environment variable.')
    process.exit(1)
  }
  if (!options.api) {
    console.error('Error: API URL is required.')
    process.exit(1)
  }

  // TODO: exit when failed to connect
  // TODO: Recreate ws when connection dropped unexpectedly

  const ws = new WebSocket(`${options.api}/${options.taskId}`, {
    headers: {
      'x-session-token': options.sessionToken,
      'x-github-token': options.githubToken,
    },
  })

  const sendMessage = (message: WsOutgoingMessage) => {
    try {
      const messageString = JSON.stringify(message)
      ws.send(messageString)
    } catch (error) {
      try {
        const errorMsg = JSON.stringify({ type: 'error', message: 'Failed to send message', details: String(error) })
        ws.send(errorMsg)
      } catch (sendError) {
        console.error(chalk.red('Failed to send generic error message:'), sendError)
      }
    }
  }

  const config = loadConfig() ?? {}

  // Create provider
  const provider = getProvider('coder', config || {}, {
    command: {
      onStarted(command) {
        console.log(`$ >>>> $ ${command}`)
      },
      onStdout(data) {
        process.stdout.write(data)
      },
      onStderr(data) {
        process.stderr.write(data)
      },
      onExit(code) {
        console.log(`$ <<<< $ Command exited with code: ${code}`)
      },
      onError(error) {
        console.log(`$ <<<< $ Command error: ${error}`)
      },
    },
    excludeFiles: config.excludeFiles,
    interactive: false,
  })

  console.log(chalk.green('Runner initialized with:'))
  console.log(`  API URL: ${options.api}`)
  console.log(`  Task ID: ${options.taskId}`)

  const availableTools = {
    [executeCommand.name]: executeCommand,
    [listCodeDefinitionNames.name]: listCodeDefinitionNames,
    [listFiles.name]: listFiles,
    [readFile.name]: readFile,
    [removeFile.name]: removeFile,
    [renameFile.name]: renameFile,
    [replaceInFile.name]: replaceInFile,
    [searchFiles.name]: searchFiles,
    [writeToFile.name]: writeToFile,
  } as Record<string, FullToolInfo>

  ws.on('message', async (data) => {
    try {
      const rawMessage = JSON.parse(data.toString())
      const message = wsIncomingMessageSchema.parse(rawMessage)

      switch (message.type) {
        case 'pending_tools': {
          console.log(
            chalk.blue(`Received tool requests for step ${message.step}:`),
            message.requests.map((r) => r.tool),
          )
          const responses: { index: number; tool: string; response: string }[] = []
          for (const request of message.requests) {
            let respMsg: string
            try {
              console.log(`Executing tool: ${request.tool} with params:`, request.params)

              const tool = availableTools[request.tool]
              if (tool) {
                const resp = await tool.handler(provider, request.params)
                if (resp.type === ToolResponseType.Reply) {
                  respMsg = responsePrompts.toolResults(request.tool, resp.message)
                } else {
                  respMsg = responsePrompts.errorInvokeTool(request.tool, `Unexpected tool response: ${JSON.stringify(resp)}`)
                }
              } else {
                respMsg = responsePrompts.errorInvokeTool(request.tool, 'Tool not available')
              }
            } catch (toolError) {
              console.error(chalk.red(`Error executing tool ${request.tool}:`), toolError)
              respMsg = responsePrompts.errorInvokeTool(request.tool, toolError)
            }

            responses.push({
              index: request.index,
              tool: request.tool,
              response: respMsg,
            })
          }

          sendMessage({
            type: 'pending_tools_response',
            step: message.step,
            responses,
          })
          break
        }

        case 'get_files': {
          console.log(chalk.blue('Received get_files request.'))

          // TODO: get git changed files and send it back

          break
        }

        case 'done': {
          console.log(chalk.blue('Received done message.'))
          process.exit(0)
          break
        }
      }
    } catch (error) {
      console.error(chalk.red('Error processing message:'), error)
    }
  })

  ws.on('error', (error) => {
    console.error(chalk.red('WebSocket error:'), error)
    process.exit(1) // Exit on error
  })
}
