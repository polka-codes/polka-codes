// generated by polka.codes

import type { LanguageModelV2 } from '@ai-sdk/provider'
import type { ExitReason, FullToolInfoV2, ToolResponse } from '@polka-codes/core'
import { ToolResponseType } from '@polka-codes/core'
import { jsonSchema, type ModelMessage, type ToolCallPart, type ToolSet } from 'ai'
import { camelCase } from 'lodash'
import { toJSONSchema } from 'zod'
import type { Workflow } from './workflow'

// Input definition for the workflow
export type AgentWorkflowInput = {
  messages: ModelMessage[]
  tools: Readonly<FullToolInfoV2[]>
  model: LanguageModelV2
  systemPrompt: string
  maxToolRoundTrips?: number
  requireToolUse?: boolean
  toolFormat: 'native'
}

// Output definition for a successful workflow execution
export type AgentWorkflowOutput = ExitReason

// Tool registry for the agent, including a special tool for LLM calls
export type AgentToolRegistry = {
  llm: {
    input: { messages: ModelMessage[]; tools: ToolSet }
    output: {
      finishReason: string
      usage: { promptTokens: number; completionTokens: number }
      message: ModelMessage
    }
  }
  [key: string]: { input: any; output: any }
}

// The workflow implementation
export const agentWorkflow: Workflow<AgentWorkflowInput, AgentWorkflowOutput, AgentToolRegistry> = {
  name: 'agent',
  description: 'A workflow that reimplements AgentBase logic using the workflow engine.',
  async *fn(input, _step, tools) {
    const { messages: initialMessages, tools: toolInfo, systemPrompt, maxToolRoundTrips = 50, requireToolUse } = input

    const messages: ModelMessage[] = [{ role: 'system', content: systemPrompt }, ...initialMessages]

    const toolSet: ToolSet = {}
    for (const tool of toolInfo) {
      const toolName = camelCase(tool.name)
      toolSet[toolName] = {
        description: tool.description,
        inputSchema: jsonSchema(toJSONSchema(tool.parameters) as any),
      }
    }

    for (let i = 0; i < maxToolRoundTrips; i++) {
      const { message: assistantMessage } = yield* tools.llm({
        messages,
        tools: toolSet,
      })

      messages.push(assistantMessage)

      const toolCalls: ToolCallPart[] = []
      if (typeof assistantMessage.content === 'object') {
        for (const part of assistantMessage.content) {
          if (part.type === 'tool-call') {
            toolCalls.push(part)
          }
        }
      }

      if (toolCalls.length > 0) {
        const toolResults: { toolCallId: string; toolName: string; output: any }[] = []
        toolProcessing: for (const toolCall of toolCalls) {
          const tool = toolInfo.find((t) => t.name === toolCall.toolName)
          if (!tool) {
            // This should not happen if the LLM is behaving
            toolResults.push({
              toolCallId: toolCall.toolCallId,
              toolName: toolCall.toolName,
              output: {
                type: 'error-text',
                value: `Tool ${toolCall.toolName} not found`,
              },
            })
            continue
          }
          const toolResponse: ToolResponse = yield* (tools as any)[toolCall.toolName]((toolCall as any).input)

          switch (toolResponse.type) {
            case ToolResponseType.Reply:
              toolResults.push({
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                output: toolResponse.message,
              })
              break
            case ToolResponseType.Exit:
            case ToolResponseType.HandOver:
            case ToolResponseType.Delegate:
              if (toolCalls.length > 1) {
                toolResults.push({
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  output: {
                    type: 'error-text',
                    value: `Error: The tool '${toolCall.toolName}' must be called alone, but it was called with other tools.`,
                  },
                })
                continue toolProcessing
              }
              if (toolResults.length > 0) {
                // Another tool already ran.
                break toolProcessing
              }
              // Otherwise, it's a clean exit.
              return toolResponse
            case ToolResponseType.Invalid:
            case ToolResponseType.Error:
              toolResults.push({
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                output: toolResponse.message,
              })
              break
          }
        }

        if (toolResults.length > 0) {
          messages.push({
            role: 'tool',
            content: toolResults.map((r) => ({ ...r, type: 'tool-result' })),
          })
        }
      } else {
        if (requireToolUse) {
          messages.push({
            role: 'user',
            content: 'You must use a tool to answer the user request.',
          })
          continue
        }
        const content =
          typeof assistantMessage.content === 'string'
            ? assistantMessage.content
            : assistantMessage.content.map((c) => ('text' in c ? c.text : '')).join('')
        return {
          type: ToolResponseType.Exit,
          message: content,
        }
      }
    }

    throw new Error('Maximum number of tool round trips reached.')
  },
}
