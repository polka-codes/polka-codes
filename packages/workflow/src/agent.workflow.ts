// generated by polka.codes

import type { ExitReason, FullToolInfo, TaskEvent, ToolResponse } from '@polka-codes/core'
import { parseJsonFromMarkdown, TaskEventKind, ToolResponseType } from '@polka-codes/core'
import { jsonSchema, type ToolCallPart, type ToolSet } from 'ai'
import { toJSONSchema, z } from 'zod'
import type { JsonModelMessage, JsonResponseMessage, JsonUserModelMessage } from './json-ai-types'
import type { WorkflowFn } from './workflow'

export type AgentWorkflowInput = {
  tools: Readonly<FullToolInfo[]>
  maxToolRoundTrips?: number
  userMessage: JsonUserModelMessage[]
  outputSchema?: z.ZodSchema
} & (
  | {
      messages: JsonModelMessage[]
    }
  | {
      systemPrompt: string
    }
)

export type AgentToolRegistry = {
  generateText: {
    input: { messages: JsonModelMessage[]; tools: ToolSet }
    output: JsonResponseMessage[]
  }
  taskEvent: {
    input: TaskEvent
    output: void
  }
  invokeTool: {
    input: { toolName: string; input: any }
    output: ToolResponse
  }
}

export const agentWorkflow: WorkflowFn<AgentWorkflowInput, ExitReason, AgentToolRegistry> = async (input, { step, tools }) => {
  const event = async (name: string, event: TaskEvent) => {
    await step(name, async () => {
      await tools.taskEvent(event)
    })
  }

  const { tools: toolInfo, maxToolRoundTrips = 200 } = input

  const messages: JsonModelMessage[] = 'systemPrompt' in input ? [{ role: 'system', content: input.systemPrompt }] : input.messages

  await event('start-task', { kind: TaskEventKind.StartTask, systemPrompt: 'systemPrompt' in input ? input.systemPrompt : '' })

  const toolSet: ToolSet = {}
  for (const tool of toolInfo) {
    toolSet[tool.name] = {
      description: tool.description,
      inputSchema: jsonSchema(toJSONSchema(tool.parameters)),
    }
  }

  let nextMessage: JsonModelMessage[] = input.userMessage

  for (let i = 0; i < maxToolRoundTrips; i++) {
    messages.push(...nextMessage)

    await event(`start-round-${i}`, { kind: TaskEventKind.StartRequest, userMessage: nextMessage as any }) // TODO: the type is not exactly matching but that's ok
    const assistantMessage = await step(`agent-round-${i}`, async () => {
      return await tools.generateText({
        messages,
        tools: toolSet,
      })
    })

    messages.push(...assistantMessage)

    const toolCalls: ToolCallPart[] = []
    for (const msg of assistantMessage) {
      if (typeof msg.content === 'string') {
        continue
      }
      if (msg.content) {
        for (const part of msg.content) {
          if (part.type === 'tool-call') {
            toolCalls.push(part as ToolCallPart)
          }
        }
      }
    }

    const textContent = assistantMessage
      .flatMap((m) => {
        if (typeof m.content === 'string') {
          return [m.content]
        }

        if (m.role === 'assistant' && Array.isArray(m.content)) {
          return m.content.map((part) => {
            if (part.type === 'text') {
              return part.text
            }
            return ''
          })
        }
        return []
      })
      .join('\n')

    await event(`end-round-${i}`, { kind: TaskEventKind.EndRequest, message: textContent })

    if (toolCalls.length === 0) {
      if (!input.outputSchema) {
        return { type: ToolResponseType.Exit, message: textContent }
      }

      const parsed = parseJsonFromMarkdown(textContent)
      if (!parsed.success) {
        const errorMessage = `Failed to parse JSON from markdown. Error: ${parsed.error}. Please correct the output. It MUST be in valid JSON format.`
        nextMessage = [{ role: 'user', content: errorMessage }]
        continue
      }

      const validated = input.outputSchema.safeParse(parsed.data)
      if (!validated.success) {
        const errorMessage = `Output validation failed. Error: ${z.prettifyError(validated.error)}. Please correct the output.`
        nextMessage = [{ role: 'user', content: errorMessage }]
        continue
      }
      return { type: ToolResponseType.Exit, message: textContent, object: validated.data }
    }

    const toolResults: { toolCallId: string; toolName: string; output: any }[] = []
    for (const toolCall of toolCalls) {
      await event(`event-tool-use-${toolCall.toolName}-${toolCall.toolCallId}`, {
        kind: TaskEventKind.ToolUse,
        tool: toolCall.toolName,
        params: toolCall.input as any,
      })
      const toolResponse: ToolResponse = await step(`invoke-tool-${toolCall.toolName}-${toolCall.toolCallId}`, async () => {
        return await tools.invokeTool({
          toolName: toolCall.toolName,
          input: toolCall.input,
        })
      })

      switch (toolResponse.type) {
        case ToolResponseType.Reply:
          await event(`event-tool-reply-${toolCall.toolName}-${toolCall.toolCallId}`, {
            kind: TaskEventKind.ToolReply,
            tool: toolCall.toolName,
            content: toolResponse.message,
          })
          toolResults.push({
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            output: toolResponse.message,
          })
          break
        case ToolResponseType.Error:
          await event(`event-tool-error-${toolCall.toolName}-${toolCall.toolCallId}`, {
            kind: TaskEventKind.ToolError,
            tool: toolCall.toolName,
            error: toolResponse.message,
          })
          toolResults.push({
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            output: toolResponse.message,
          })
          break
        case ToolResponseType.Invalid:
          await event(`event-tool-invalid-${toolCall.toolName}-${toolCall.toolCallId}`, {
            kind: TaskEventKind.ToolInvalid,
            tool: toolCall.toolName,
            content: toolResponse.message,
          })
          toolResults.push({
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            output: toolResponse.message,
          })
          break
        case ToolResponseType.Exit:
        case ToolResponseType.HandOver:
        case ToolResponseType.Delegate:
          if (toolCalls.length > 1) {
            toolResults.push({
              toolCallId: toolCall.toolCallId,
              toolName: toolCall.toolName,
              output: {
                type: 'error-text',
                value: `Error: The tool '${toolCall.toolName}' must be called alone, but it was called with other tools.`,
              },
            })
            break
          }
          if (toolResults.length > 0) {
            // Another tool already ran.
            break
          }
          // Otherwise, it's a clean exit.
          await event('end-task', { kind: TaskEventKind.EndTask, exitReason: toolResponse })
          return toolResponse
      }
    }

    nextMessage = [
      {
        role: 'tool',
        content: toolResults.map((r) => ({
          type: 'tool-result',
          ...r,
        })),
      },
    ]
  }

  throw new Error('Maximum number of tool round trips reached.')
}
