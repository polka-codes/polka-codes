// generated by polka.codes
import { expect, spyOn, test } from 'bun:test'
import type { ToolSignature, Workflow } from './workflow'
import { run, useTool } from './workflow'

type Tools = {
  add: ToolSignature<{ a: number; b: number }, number>
  concat: ToolSignature<{ a: string; b: string }, string>
}

const simpleWorkflow: Workflow<string, string, Tools> = {
  name: 'simple',
  description: 'A simple workflow',
  // biome-ignore lint/correctness/useYield: A workflow can have no tool calls
  async *fn(input, _step) {
    return `hello ${input}`
  },
}

const singleToolWorkflow: Workflow<number, number, Tools> = {
  name: 'singleTool',
  description: 'A workflow with a single tool',
  async *fn(input, _step) {
    const result = yield* useTool('add', { a: input, b: 2 })
    return result
  },
}

const multiToolWorkflow: Workflow<string, string, Tools> = {
  name: 'multiTool',
  description: 'A workflow with multiple tools',
  async *fn(input, _step) {
    const r1 = yield* useTool('concat', { a: 'hello', b: ' ' })
    const r2 = yield* useTool('concat', { a: r1, b: input })
    return r2
  },
}

const failingWorkflow: Workflow<null, null, Tools> = {
  name: 'failing',
  description: 'A failing workflow',
  // biome-ignore lint/correctness/useYield: A workflow can fail before any tool call
  async *fn() {
    throw new Error('test error')
  },
}

const failingAfterToolWorkflow: Workflow<number, number, Tools> = {
  name: 'failingAfterTool',
  description: 'A workflow that fails after a tool call',
  async *fn(input, _step) {
    yield* useTool('add', { a: input, b: 2 })
    throw new Error('failed after tool')
  },
}

test('should run a simple workflow', async () => {
  const result = await run(simpleWorkflow, 'world')
  expect(result).toMatchSnapshot()
})

test('should run a workflow with one tool', async () => {
  const result1 = await run(singleToolWorkflow, 3)
  expect(result1).toMatchSnapshot()

  if (result1.status !== 'pending') return

  const result2 = await result1.next(5)
  expect(result2).toMatchSnapshot()
})

test('should run a workflow with multiple tools', async () => {
  const result1 = await run(multiToolWorkflow, 'world')
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('hello ')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next('hello world')
  expect(result3).toMatchSnapshot()
})

test('should handle a failing workflow', async () => {
  const result = await run(failingWorkflow, null)
  if (result.status === 'failed') {
    expect({ status: result.status, error: (result.error as Error)?.message }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed')
  }
})

test('should handle failing after a tool call', async () => {
  const result1 = await run(failingAfterToolWorkflow, 3)
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next(5)
  if (result2.status === 'failed') {
    expect({ status: result2.status, error: (result2.error as Error)?.message }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed')
  }
})

test('should execute step for each call', async () => {
  const mock = {
    innerFn: async () => 'result',
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const stepWorkflow: Workflow<null, string, Tools> = {
    name: 'step',
    description: 'A workflow with steps',
    // biome-ignore lint/correctness/useYield: A workflow can have only steps and no tool calls
    async *fn(_input, step) {
      const r1 = await step('step1', mock.innerFn)
      const r2 = await step('step1', mock.innerFn)
      return `${r1}-${r2}`
    },
  }

  const result = await run(stepWorkflow, null)
  expect(result.status).toBe('completed')
  if (result.status === 'completed') {
    expect(result.output).toBe('result-result')
  }
  expect(innerFnSpy).toHaveBeenCalledTimes(2)
})

test('should support steps in a loop', async () => {
  const mock = {
    innerFn: async (i: number) => `result-${i}`,
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const loopWorkflow: Workflow<number, string, Tools> = {
    name: 'loop',
    description: 'A workflow with a loop',
    async *fn(input, step) {
      const results: string[] = []
      for (let i = 0; i < input; i++) {
        const r = await step('loopedStep', () => mock.innerFn(i))
        results.push(r)
      }
      return results.join(',')
    },
  }

  const result = await run(loopWorkflow, 3)
  expect(result.status).toBe('completed')
  if (result.status === 'completed') {
    expect(result.output).toBe('result-0,result-1,result-2')
  }
  expect(innerFnSpy).toHaveBeenCalledTimes(3)
})
