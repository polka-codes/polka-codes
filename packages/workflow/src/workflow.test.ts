// generated by polka.codes
import { expect, spyOn, test } from 'bun:test'
import { makeStepFn } from './helpers'
import type { ToolSignature, Workflow } from './workflow'
import { run } from './workflow'

type Tools = {
  add: ToolSignature<{ a: number; b: number }, number>
  concat: ToolSignature<{ a: string; b: string }, string>
}

const simpleWorkflow: Workflow<string, string, Tools> = {
  name: 'simple',
  description: 'A simple workflow',
  async *fn(input, _step) {
    return `hello ${input}`
  },
}

const singleToolWorkflow: Workflow<number, number, Tools> = {
  name: 'singleTool',
  description: 'A workflow with a single tool',
  async *fn(input, _step, tools) {
    const result = yield* tools.add({ a: input, b: 2 })
    return result
  },
}

const multiToolWorkflow: Workflow<string, string, Tools> = {
  name: 'multiTool',
  description: 'A workflow with multiple tools',
  async *fn(input, _step, tools) {
    const r1 = yield* tools.concat({ a: 'hello', b: ' ' })
    const r2 = yield* tools.concat({ a: r1, b: input })
    return r2
  },
}

const failingWorkflow: Workflow<null, null, Tools> = {
  name: 'failing',
  description: 'A failing workflow',
  async *fn() {
    throw new Error('test error')
  },
}

const failingAfterToolWorkflow: Workflow<number, number, Tools> = {
  name: 'failingAfterTool',
  description: 'A workflow that fails after a tool call',
  async *fn(input, _step, tools) {
    yield* tools.add({ a: input, b: 2 })
    throw new Error('failed after tool')
  },
}

test('should run a simple workflow', async () => {
  const result = await run(simpleWorkflow, 'world')
  expect(result).toMatchSnapshot()
})

test('should run a workflow with one tool', async () => {
  const result1 = await run(singleToolWorkflow, 3)
  expect(result1).toMatchSnapshot()

  if (result1.status !== 'pending') return

  const result2 = await result1.next(5)
  expect(result2).toMatchSnapshot()
})

test('should run a workflow with multiple tools', async () => {
  const result1 = await run(multiToolWorkflow, 'world')
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next('hello ')
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next('hello world')
  expect(result3).toMatchSnapshot()
})

test('should handle a failing workflow', async () => {
  const result = await run(failingWorkflow, null)
  if (result.status === 'failed') {
    expect({ status: result.status, error: (result.error as Error)?.message }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed')
  }
})

test('should handle failing after a tool call', async () => {
  const result1 = await run(failingAfterToolWorkflow, 3)
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next(5)
  if (result2.status === 'failed') {
    expect({ status: result2.status, error: (result2.error as Error)?.message }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed')
  }
})

test('should execute step for each call', async () => {
  const mock = {
    innerFn: async () => 'result',
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const stepWorkflow: Workflow<null, string, Tools> = {
    name: 'step',
    description: 'A workflow with steps',
    async *fn(_input, step) {
      const r1 = yield* step('step1', async function* () {
        return await mock.innerFn()
      })
      const r2 = yield* step('step2', async function* () {
        return await mock.innerFn()
      })
      return `${r1}-${r2}`
    },
  }

  const result = await run(stepWorkflow, null)
  expect(result.status).toBe('completed')
  if (result.status === 'completed') {
    expect(result.output).toBe('result-result')
  }
  expect(innerFnSpy).toHaveBeenCalledTimes(2)
})

test('should support steps in a loop', async () => {
  const mock = {
    innerFn: async (i: number) => `result-${i}`,
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const loopWorkflow: Workflow<number, string, Tools> = {
    name: 'loop',
    description: 'A workflow with a loop',
    async *fn(input, step) {
      const results: string[] = []
      for (let i = 0; i < input; i++) {
        const r = yield* step(`loopedStep-${i}`, async function* () {
          return await mock.innerFn(i)
        })
        results.push(r)
      }
      return results.join(',')
    },
  }

  const result = await run(loopWorkflow, 3)
  expect(result.status).toBe('completed')
  if (result.status === 'completed') {
    expect(result.output).toBe('result-0,result-1,result-2')
  }
  expect(innerFnSpy).toHaveBeenCalledTimes(3)
})

test('should resume workflow from a step', async () => {
  const results: Record<string, any | undefined> = {}
  let counts: Record<string, number> = {}

  const getStepResult = async (key: string): Promise<{ found: true; value: any | undefined } | { found: false }> => {
    if (Object.hasOwn(results, key)) {
      return { found: true, value: results[key] }
    }
    return { found: false }
  }
  const setStepResult = async (key: string, value: any | undefined) => {
    results[key] = value
  }
  const getAndIncrementCounts = async (key: string) => {
    counts[key] = (counts[key] || 0) + 1
    return counts[key]
  }

  const mock = {
    innerFn: async () => 'result',
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const stepWorkflow: Workflow<null, string, Tools> = {
    name: 'step',
    description: 'A workflow with steps',
    async *fn(_input, step) {
      const r1 = yield* step('step1', async function* () {
        return await mock.innerFn()
      })
      const r2 = yield* step('step2', async function* () {
        return await mock.innerFn()
      })
      return `${r1}-${r2}`
    },
  }

  const stepFn = makeStepFn({
    getStepResult,
    setStepResult,
    onEnterStep: async (name) => {
      await getAndIncrementCounts(name)
    },
  })

  // First run
  counts = {}
  const result1 = await run(stepWorkflow, null, stepFn)
  expect(result1.status).toBe('completed')
  if (result1.status === 'completed') {
    expect(result1.output).toBe('result-result')
  }
  expect(innerFnSpy).toHaveBeenCalledTimes(2)

  // Reset spy and run again. The results should be cached.
  innerFnSpy.mockClear()
  counts = {}

  const result2 = await run(stepWorkflow, null, stepFn)
  expect(result2.status).toBe('completed')
  if (result2.status === 'completed') {
    expect(result2.output).toBe('result-result')
  }
  expect(innerFnSpy).toHaveBeenCalledTimes(0)
})

test('should support tool calls in step functions', async () => {
  const stepWithToolsWorkflow: Workflow<number, number, Tools> = {
    name: 'stepWithTools',
    description: 'Step containing tool calls',
    async *fn(input, step, tools) {
      const result = yield* step('toolStep', async function* () {
        const sum = yield* tools.add({ a: input, b: 10 })
        return sum
      })
      return result
    },
  }

  const result1 = await run(stepWithToolsWorkflow, 5)
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next(15)
  expect(result2).toMatchSnapshot()
})

test('should support multiple tool calls in step functions', async () => {
  const stepWithMultipleToolsWorkflow: Workflow<number, number, Tools> = {
    name: 'stepWithMultipleTools',
    description: 'Step containing multiple tool calls',
    async *fn(input, step, tools) {
      const result = yield* step('multiToolStep', async function* () {
        const sum1 = yield* tools.add({ a: input, b: 5 })
        const sum2 = yield* tools.add({ a: sum1, b: 10 })
        return sum2
      })
      return result
    },
  }

  const result1 = await run(stepWithMultipleToolsWorkflow, 3)
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next(8)
  expect(result2).toMatchSnapshot()
  if (result2.status !== 'pending') return

  const result3 = await result2.next(18)
  expect(result3).toMatchSnapshot()
})

test('should cache results from generator steps', async () => {
  const results: Record<string, any | undefined> = {}
  let counts: Record<string, number> = {}

  const getStepResult = async (key: string): Promise<{ found: true; value: any | undefined } | { found: false }> => {
    if (Object.hasOwn(results, key)) {
      return { found: true, value: results[key] }
    }
    return { found: false }
  }
  const setStepResult = async (key: string, value: any | undefined) => {
    results[key] = value
  }
  const getAndIncrementCounts = async (key: string) => {
    counts[key] = (counts[key] || 0) + 1
    return counts[key]
  }

  const mock = {
    toolCalled: false,
  }

  const stepWithToolsWorkflow: Workflow<number, number, Tools> = {
    name: 'stepWithTools',
    description: 'Step containing tool calls',
    async *fn(input, step, tools) {
      const result = yield* step('toolStep', async function* () {
        mock.toolCalled = true
        const sum = yield* tools.add({ a: input, b: 10 })
        return sum
      })
      return result
    },
  }

  const stepFn = makeStepFn<Tools>({
    getStepResult,
    setStepResult,
    onEnterStep: async (name) => {
      await getAndIncrementCounts(name)
    },
  })

  counts = {}
  const result1 = await run(stepWithToolsWorkflow, 5, stepFn)
  expect(result1.status).toBe('pending')
  if (result1.status !== 'pending') return

  const result2 = await result1.next(15)
  expect(result2.status).toBe('completed')
  if (result2.status !== 'completed') return
  expect(result2.output).toBe(15)
  expect(mock.toolCalled).toBe(true)

  mock.toolCalled = false
  counts = {}

  const result3 = await run(stepWithToolsWorkflow, 5, stepFn)
  expect(result3.status).toBe('completed')
  if (result3.status !== 'completed') return
  expect(result3.output).toBe(15)
  expect(mock.toolCalled).toBe(false)
})

test('should support mixing regular and generator steps', async () => {
  const mock = {
    regularStep: async () => 100,
  }
  const regularStepSpy = spyOn(mock, 'regularStep')

  const mixedStepsWorkflow: Workflow<number, number, Tools> = {
    name: 'mixedSteps',
    description: 'Workflow with both regular and generator steps',
    async *fn(input, step, tools) {
      const regular = yield* step('regular', async function* () {
        return await mock.regularStep()
      })

      const withTool = yield* step('withTool', async function* () {
        const sum = yield* tools.add({ a: input, b: regular })
        return sum
      })

      const anotherRegular = yield* step('anotherRegular', async function* () {
        return withTool * 2
      })

      return anotherRegular
    },
  }

  const result1 = await run(mixedStepsWorkflow, 5)
  expect(result1).toMatchSnapshot()
  if (result1.status !== 'pending') return

  const result2 = await result1.next(105)
  expect(result2).toMatchSnapshot()

  expect(regularStepSpy).toHaveBeenCalledTimes(1)
})

test('should handle errors in generator steps', async () => {
  const failingGeneratorStepWorkflow: Workflow<number, number, Tools> = {
    name: 'failingGeneratorStep',
    description: 'Step that fails inside a generator',
    async *fn(input, step, tools) {
      const result = yield* step('failingStep', async function* () {
        yield* tools.add({ a: input, b: 10 })
        throw new Error('error in generator step')
      })
      return result
    },
  }

  const result1 = await run(failingGeneratorStepWorkflow, 5)
  expect(result1.status).toBe('pending')
  if (result1.status !== 'pending') return

  const result2 = await result1.next(15)
  if (result2.status === 'failed') {
    expect({ status: result2.status, error: (result2.error as Error)?.message }).toMatchSnapshot()
  } else {
    throw new Error('Workflow should have failed')
  }
})

test('should support generator steps in a loop', async () => {
  const loopWithGeneratorStepsWorkflow: Workflow<number, number, Tools> = {
    name: 'loopWithGeneratorSteps',
    description: 'Loop with generator steps',
    async *fn(input, step, tools) {
      let sum = input
      for (let i = 0; i < 3; i++) {
        sum = yield* step(`loopStep-${i}`, async function* () {
          const result = yield* tools.add({ a: sum, b: i })
          return result
        })
      }
      return sum
    },
  }

  let result: any = await run(loopWithGeneratorStepsWorkflow, 10)

  const expectedCalls = [
    { a: 10, b: 0 },
    { a: 10, b: 1 },
    { a: 11, b: 2 },
  ]

  for (let i = 0; i < expectedCalls.length; i++) {
    expect(result.status).toBe('pending')
    if (result.status !== 'pending') return

    expect(result.tool.input).toEqual(expectedCalls[i])
    result = await result.next(expectedCalls[i].a + expectedCalls[i].b)
  }

  expect(result.status).toBe('completed')
  if (result.status !== 'completed') return
  expect(result.output).toBe(13)
})
