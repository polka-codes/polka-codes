// generated by polka.codes
import { expect, spyOn, test } from 'bun:test'
import { createContext, makeStepFn, type ToolHandler, type ToolSignature, type WorkflowFn } from './workflow'

type Tools = {
  add: ToolSignature<{ a: number; b: number }, number>
  concat: ToolSignature<{ a: string; b: string }, string>
}

const simpleWorkflow: WorkflowFn<string, string, Tools> = async function simple(input, { step: _step }) {
  return `hello ${input}`
}

const singleToolWorkflow: WorkflowFn<number, number, Tools> = async function singleTool(input, { step: _step, toolHandler }) {
  const result = await toolHandler.add({ a: input, b: 2 })
  return result
}

const multiToolWorkflow: WorkflowFn<string, string, Tools> = async function multiTool(input, { step: _step, toolHandler }) {
  const r1 = await toolHandler.concat({ a: 'hello', b: ' ' })
  const r2 = await toolHandler.concat({ a: r1, b: input })
  return r2
}

const failingWorkflow: WorkflowFn<null, null, Tools> = async function failing() {
  throw new Error('test error')
}

const failingAfterToolWorkflow: WorkflowFn<number, number, Tools> = async function failingAfterTool(input, { step: _step, toolHandler }) {
  await toolHandler.add({ a: input, b: 2 })
  throw new Error('failed after tool')
}

const mockToolHandler: ToolHandler<Tools> = {
  add: async (input) => {
    return input.a + input.b
  },
  concat: async (input) => {
    return input.a + input.b
  },
}

test('should run a simple workflow', async () => {
  const context = createContext(mockToolHandler)
  const result = await simpleWorkflow('world', context)
  expect(result).toBe('hello world')
})

test('should run a workflow with one tool', async () => {
  const context = createContext(mockToolHandler)
  const result = await singleToolWorkflow(3, context)
  expect(result).toBe(5)
})

test('should run a workflow with multiple tools', async () => {
  const context = createContext(mockToolHandler)
  const result = await multiToolWorkflow('world', context)
  expect(result).toBe('hello world')
})

test('should handle a failing workflow', async () => {
  const context = createContext(mockToolHandler)
  await expect(failingWorkflow(null, context)).rejects.toThrow('test error')
})

test('should handle failing after a tool call', async () => {
  const context = createContext(mockToolHandler)
  await expect(failingAfterToolWorkflow(3, context)).rejects.toThrow('failed after tool')
})

test('should execute step for each call', async () => {
  const mock = {
    innerFn: async () => 'result',
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const stepWorkflow: WorkflowFn<null, string, Tools> = async function stepWorkflow(_input, { step }) {
    const r1 = await step('step1', async () => {
      return await mock.innerFn()
    })
    const r2 = await step('step2', async () => {
      return await mock.innerFn()
    })
    return `${r1}-${r2}`
  }

  const context = createContext(mockToolHandler)
  const result = await stepWorkflow(null, context)
  expect(result).toBe('result-result')
  expect(innerFnSpy).toHaveBeenCalledTimes(2)
})

test('should support steps in a loop', async () => {
  const mock = {
    innerFn: async (i: number) => `result-${i}`,
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const loopWorkflow: WorkflowFn<number, string, Tools> = async function loopWorkflow(input, { step }) {
    const results: string[] = []
    for (let i = 0; i < input; i++) {
      const r = await step(`loopedStep-${i}`, async () => {
        return await mock.innerFn(i)
      })
      results.push(r)
    }
    return results.join(',')
  }

  const context = createContext(mockToolHandler)
  const result = await loopWorkflow(3, context)
  expect(result).toBe('result-0,result-1,result-2')
  expect(innerFnSpy).toHaveBeenCalledTimes(3)
})

test('makeStepFn should cache results for same step name', async () => {
  const mock = {
    innerFn: async () => 'result',
  }
  const innerFnSpy = spyOn(mock, 'innerFn')
  const step = makeStepFn()

  const r1 = await step('step1', mock.innerFn)
  expect(r1).toBe('result')
  expect(innerFnSpy).toHaveBeenCalledTimes(1)

  // Call again with same step name
  const r2 = await step('step1', mock.innerFn)
  expect(r2).toBe('result')
  expect(innerFnSpy).toHaveBeenCalledTimes(1) // Should not be called again

  // Call with a different step name
  const r3 = await step('step2', mock.innerFn)
  expect(r3).toBe('result')
  expect(innerFnSpy).toHaveBeenCalledTimes(2) // Should be called again
})

test('makeStepFn should handle nested calls and cache them correctly', async () => {
  const mock = {
    innerFn: async () => 'inner-result',
    outerFn: async (s: string) => `outer-result-with-${s}`,
  }
  const innerFnSpy = spyOn(mock, 'innerFn')
  const outerFnSpy = spyOn(mock, 'outerFn')

  const step = makeStepFn()

  // First call to outer, which calls inner
  const r1 = await step('outer', async () => {
    const innerResult = await step('inner', mock.innerFn)
    return mock.outerFn(innerResult)
  })

  expect(r1).toBe('outer-result-with-inner-result')
  expect(innerFnSpy).toHaveBeenCalledTimes(1)
  expect(outerFnSpy).toHaveBeenCalledTimes(1)

  // Second call to outer, should be fully cached
  const r2 = await step('outer', async () => {
    const innerResult = await step('inner', mock.innerFn)
    return mock.outerFn(innerResult)
  })
  expect(r2).toBe('outer-result-with-inner-result')
  expect(innerFnSpy).toHaveBeenCalledTimes(1)
  expect(outerFnSpy).toHaveBeenCalledTimes(1)

  // Call inner again, should NOT be cached as it has a different call stack
  const r3 = await step('inner', mock.innerFn)
  expect(r3).toBe('inner-result')
  expect(innerFnSpy).toHaveBeenCalledTimes(2)
})

test('makeStepFn should not cache errors', async () => {
  let shouldThrow = true
  const mock = {
    innerFn: async () => {
      if (shouldThrow) {
        throw new Error('test error')
      }
      return 'result'
    },
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const step = makeStepFn()

  // First call, should throw
  await expect(step('step1', mock.innerFn)).rejects.toThrow('test error')
  expect(innerFnSpy).toHaveBeenCalledTimes(1)

  // Second call, should not throw and should execute again
  shouldThrow = false
  const r2 = await step('step1', mock.innerFn)
  expect(r2).toBe('result')
  expect(innerFnSpy).toHaveBeenCalledTimes(2)
})
