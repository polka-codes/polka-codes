// generated by polka.codes
import { expect, spyOn, test } from 'bun:test'
import { createContext, type ToolHandler, type ToolSignature, type WorkflowFn } from './workflow'

type Tools = {
  add: ToolSignature<{ a: number; b: number }, number>
  concat: ToolSignature<{ a: string; b: string }, string>
}

const simpleWorkflow: WorkflowFn<string, string, Tools> = async function simple(input, { step: _step }) {
  return `hello ${input}`
}

const singleToolWorkflow: WorkflowFn<number, number, Tools> = async function singleTool(input, { step: _step, toolHandler }) {
  const result = await toolHandler.add({ a: input, b: 2 })
  return result
}

const multiToolWorkflow: WorkflowFn<string, string, Tools> = async function multiTool(input, { step: _step, toolHandler }) {
  const r1 = await toolHandler.concat({ a: 'hello', b: ' ' })
  const r2 = await toolHandler.concat({ a: r1, b: input })
  return r2
}

const failingWorkflow: WorkflowFn<null, null, Tools> = async function failing() {
  throw new Error('test error')
}

const failingAfterToolWorkflow: WorkflowFn<number, number, Tools> = async function failingAfterTool(input, { step: _step, toolHandler }) {
  await toolHandler.add({ a: input, b: 2 })
  throw new Error('failed after tool')
}

const mockToolHandler: ToolHandler<Tools> = {
  add: async (input) => {
    return input.a + input.b
  },
  concat: async (input) => {
    return input.a + input.b
  },
}

test('should run a simple workflow', async () => {
  const context = createContext(mockToolHandler)
  const result = await simpleWorkflow('world', context)
  expect(result).toBe('hello world')
})

test('should run a workflow with one tool', async () => {
  const context = createContext(mockToolHandler)
  const result = await singleToolWorkflow(3, context)
  expect(result).toBe(5)
})

test('should run a workflow with multiple tools', async () => {
  const context = createContext(mockToolHandler)
  const result = await multiToolWorkflow('world', context)
  expect(result).toBe('hello world')
})

test('should handle a failing workflow', async () => {
  const context = createContext(mockToolHandler)
  await expect(failingWorkflow(null, context)).rejects.toThrow('test error')
})

test('should handle failing after a tool call', async () => {
  const context = createContext(mockToolHandler)
  await expect(failingAfterToolWorkflow(3, context)).rejects.toThrow('failed after tool')
})

test('should execute step for each call', async () => {
  const mock = {
    innerFn: async () => 'result',
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const stepWorkflow: WorkflowFn<null, string, Tools> = async function stepWorkflow(_input, { step }) {
    const r1 = await step('step1', async () => {
      return await mock.innerFn()
    })
    const r2 = await step('step2', async () => {
      return await mock.innerFn()
    })
    return `${r1}-${r2}`
  }

  const context = createContext(mockToolHandler)
  const result = await stepWorkflow(null, context)
  expect(result).toBe('result-result')
  expect(innerFnSpy).toHaveBeenCalledTimes(2)
})

test('should support steps in a loop', async () => {
  const mock = {
    innerFn: async (i: number) => `result-${i}`,
  }
  const innerFnSpy = spyOn(mock, 'innerFn')

  const loopWorkflow: WorkflowFn<number, string, Tools> = async function loopWorkflow(input, { step }) {
    const results: string[] = []
    for (let i = 0; i < input; i++) {
      const r = await step(`loopedStep-${i}`, async () => {
        return await mock.innerFn(i)
      })
      results.push(r)
    }
    return results.join(',')
  }

  const context = createContext(mockToolHandler)
  const result = await loopWorkflow(3, context)
  expect(result).toBe('result-0,result-1,result-2')
  expect(innerFnSpy).toHaveBeenCalledTimes(3)
})
