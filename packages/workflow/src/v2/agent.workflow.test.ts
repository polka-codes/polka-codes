// generated by polka.codes

import { expect, spyOn, test } from 'bun:test'
import { type FullToolInfoV2, type ToolResponse, ToolResponseType } from '@polka-codes/core'
import type { ModelMessage, UserModelMessage } from 'ai'
import { z } from 'zod'
import { type JsonResponseMessage, toJsonModelMessage } from '../json-ai-types'
import { type AgentToolRegistry, agentWorkflow } from './agent.workflow'
import { createContext, type ToolHandler } from './workflow'

const createMockTool = (name: string, description: string, handler: (args: any) => Promise<ToolResponse>): FullToolInfoV2 => ({
  name,
  description,
  parameters: z.object({
    path: z.string().describe('The path to list files from'),
  }),
  handler,
  isAvailable: () => true,
})

const listFilesTool = createMockTool('listFiles', 'List files in a directory', async ({ path }: { path: string }) => {
  if (path === './src') {
    return {
      type: ToolResponseType.Reply,
      message: {
        type: 'json',
        value: ['index.ts', 'agent.workflow.ts'],
      },
    }
  }
  return {
    type: ToolResponseType.Reply,
    message: { type: 'json', value: [] },
  }
})

const exitTool = createMockTool('exitTool', 'Exit the workflow', async () => ({
  type: ToolResponseType.Exit,
  message: 'Workflow exited',
}))

const handOverTool = createMockTool('handOverTool', 'Hand over to another agent', async () => ({
  type: ToolResponseType.HandOver,
  agentName: 'test-agent',
  task: 'test-task',
}))

const _delegateTool = createMockTool('delegateTool', 'Delegate to another agent', async () => ({
  type: ToolResponseType.Delegate,
  agentName: 'test-agent',
  task: 'test-task',
}))

const _errorTool = createMockTool('errorTool', 'Return an error', async () => ({
  type: ToolResponseType.Error,
  message: { type: 'error-text', value: 'Something went wrong' },
}))

const _invalidTool = createMockTool('invalidTool', 'Return invalid', async () => ({
  type: ToolResponseType.Invalid,
  message: { type: 'error-text', value: 'Invalid arguments' },
}))

test('should run agent workflow with a tool call and reply', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'listFiles',
          input: { path: './src' },
        },
      ],
    },
    {
      role: 'assistant',
      content: 'The files are index.ts and agent.workflow.ts',
    },
  ]

  const initialMessages: UserModelMessage[] = [{ role: 'user', content: 'What are the files in the src directory?' }]

  const tools = [listFilesTool]
  const spied = { fn: (_: any) => {} }
  const taskEventSpy = spyOn(spied, 'fn')

  const toolHandler: ToolHandler<AgentToolRegistry> = async (tool, input: any) => {
    switch (tool) {
      case 'generateText': {
        const response = mockResponses.shift()
        return [response!] as JsonResponseMessage[]
      }
      case 'invokeTool': {
        const { toolName, input: toolInput } = input
        const toolInfo = tools.find((t) => t.name === toolName)
        if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
        return toolInfo.handler({} as any, toolInput)
      }
      case 'taskEvent':
        taskEventSpy(input)
        return
    }
  }

  const result = await agentWorkflow(
    {
      userMessage: initialMessages.map(toJsonModelMessage) as any,
      tools,
      systemPrompt: 'You are a helpful assistant.',
    },
    createContext(toolHandler),
  )

  expect(result).toEqual({
    type: ToolResponseType.Exit,
    message: 'The files are index.ts and agent.workflow.ts',
  })
})

test('should exit when a tool returns an Exit response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'exitTool',
          input: {},
        },
      ],
    },
  ]

  const tools = [exitTool]
  const spied = { fn: (_: any) => {} }
  const taskEventSpy = spyOn(spied, 'fn')

  const toolHandler: ToolHandler<AgentToolRegistry> = async (tool, input: any) => {
    switch (tool) {
      case 'generateText': {
        const response = mockResponses.shift()
        return [response!] as JsonResponseMessage[]
      }
      case 'invokeTool': {
        const { toolName, input: toolInput } = input
        const toolInfo = tools.find((t) => t.name === toolName)
        if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
        return toolInfo.handler({} as any, toolInput)
      }
      case 'taskEvent':
        taskEventSpy(input)
        return
    }
  }

  const result = await agentWorkflow(
    {
      userMessage: [toJsonModelMessage({ role: 'user', content: 'Please exit.' })] as any,
      tools,
      systemPrompt: 'You are a helpful assistant.',
    },
    createContext(toolHandler),
  )

  expect(result).toEqual({
    type: ToolResponseType.Exit,
    message: 'Workflow exited',
  })
})

test('should exit when a tool returns a HandOver response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'handOverTool',
          input: {},
        },
      ],
    },
  ]

  const tools = [handOverTool]

  const toolHandler: ToolHandler<AgentToolRegistry> = async (tool, input: any) => {
    switch (tool) {
      case 'generateText': {
        const response = mockResponses.shift()
        return [response!] as JsonResponseMessage[]
      }
      case 'invokeTool': {
        const { toolName, input: toolInput } = input
        const toolInfo = tools.find((t) => t.name === toolName)
        if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
        return toolInfo.handler({} as any, toolInput)
      }
      case 'taskEvent':
        return
    }
  }

  const result = await agentWorkflow(
    {
      userMessage: [toJsonModelMessage({ role: 'user', content: 'Please hand over.' })] as any,
      tools,
      systemPrompt: 'You are a helpful assistant.',
    },
    createContext(toolHandler),
  )

  expect(result).toEqual({
    type: ToolResponseType.HandOver,
    agentName: 'test-agent',
    task: 'test-task',
  })
})

test('should fail if maxToolRoundTrips is exceeded', async () => {
  const mockResponses: ModelMessage[] = Array(12).fill({
    role: 'assistant',
    content: [
      {
        type: 'tool-call',
        toolCallId: 'tool-call-1',
        toolName: 'listFiles',
        input: { path: './src' },
      },
    ],
  })

  const tools = [listFilesTool]

  const toolHandler: ToolHandler<AgentToolRegistry> = async (tool, input: any) => {
    switch (tool) {
      case 'generateText': {
        const response = mockResponses.shift()
        return [response!] as JsonResponseMessage[]
      }
      case 'invokeTool': {
        const { toolName, input: toolInput } = input
        const toolInfo = tools.find((t) => t.name === toolName)
        if (!toolInfo) throw new Error(`Tool not found: ${toolName}`)
        return toolInfo.handler({} as any, toolInput)
      }
      case 'taskEvent':
        return
    }
  }

  await expect(
    agentWorkflow(
      {
        userMessage: [toJsonModelMessage({ role: 'user', content: 'List files.' })] as any,
        tools,
        systemPrompt: 'You are a helpful assistant.',
        maxToolRoundTrips: 10,
      },
      createContext(toolHandler),
    ),
  ).rejects.toThrow('Maximum number of tool round trips reached.')
})
