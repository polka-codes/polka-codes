// generated by polka.codes

import { expect, test } from 'bun:test'
import assert from 'node:assert/strict'
import { type FullToolInfoV2, type ToolResponse, ToolResponseType } from '@polka-codes/core'
import type { ModelMessage, UserModelMessage } from 'ai'
import { z } from 'zod'
import { type AgentWorkflowInput, agentWorkflow } from './agent.workflow'
import { type JsonResponseMessage, toJsonModelMessage } from './json-ai-types'
import { run, type WorkflowResult } from './workflow'

const createMockTool = (name: string, description: string, handler: (args: any) => Promise<ToolResponse>): FullToolInfoV2 => ({
  name,
  description,
  parameters: z.object({
    path: z.string().describe('The path to list files from'),
  }),
  handler,
  isAvailable: () => true,
})

const listFilesTool = createMockTool('listFiles', 'List files in a directory', async ({ path }: { path: string }) => {
  if (path === './src') {
    return {
      type: ToolResponseType.Reply,
      message: {
        type: 'json',
        value: ['index.ts', 'agent.workflow.ts'],
      },
    }
  }
  return {
    type: ToolResponseType.Reply,
    message: { type: 'json', value: [] },
  }
})

const exitTool = createMockTool('exitTool', 'Exit the workflow', async () => ({
  type: ToolResponseType.Exit,
  message: 'Workflow exited',
}))

const handOverTool = createMockTool('handOverTool', 'Hand over to another agent', async () => ({
  type: ToolResponseType.HandOver,
  agentName: 'test-agent',
  task: 'test-task',
}))

const delegateTool = createMockTool('delegateTool', 'Delegate to another agent', async () => ({
  type: ToolResponseType.Delegate,
  agentName: 'test-agent',
  task: 'test-task',
}))

const errorTool = createMockTool('errorTool', 'Return an error', async () => ({
  type: ToolResponseType.Error,
  message: { type: 'error-text', value: 'Something went wrong' },
}))

const invalidTool = createMockTool('invalidTool', 'Return invalid', async () => ({
  type: ToolResponseType.Invalid,
  message: { type: 'error-text', value: 'Invalid arguments' },
}))

test('should run agent workflow with a tool call and reply', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'listFiles',
          input: { path: './src' },
        },
      ],
    },
    {
      role: 'assistant',
      content: 'The files are index.ts and agent.workflow.ts',
    },
  ]

  const initialMessages: UserModelMessage[] = [{ role: 'user', content: 'What are the files in the src directory?' }]

  const tools = [listFilesTool]

  const result1 = await run(agentWorkflow, {
    userMessage: initialMessages.map(toJsonModelMessage) as any,
    tools,
    systemPrompt: 'You are a helpful assistant.',
  })

  expect(result1.status).toBe('pending')
  assert(result1.status === 'pending')
  expect(result1.tool.tool).toBe('taskEvent')

  const result2 = await result1.next()
  assert(result2.status === 'pending')
  expect(result2.tool.tool).toBe('taskEvent')

  const result3 = await result2.next()
  assert(result3.status === 'pending')
  expect(result3.tool.tool).toBe('generateText')

  const result4 = await result3.next(mockResponses.slice(0, 1) as JsonResponseMessage[])
  assert(result4.status === 'pending')
  expect(result4.tool.tool).toBe('taskEvent') // EndRequest

  const result5 = await result4.next()
  assert(result5.status === 'pending')
  expect(result5.tool.tool).toBe('taskEvent') // ToolUse

  const result6 = await result5.next()
  assert(result6.status === 'pending')
  expect(result6.tool.tool).toBe('invokeTool')
  expect(result6.tool.input).toEqual({ toolName: 'listFiles', input: { path: './src' } })

  const listFilesResponse = await listFilesTool.handler({} as any, (result6.tool.input as any).input)
  const result7 = await result6.next(listFilesResponse)
  assert(result7.status === 'pending')
  expect(result7.tool.tool).toBe('taskEvent') // ToolReply

  const result8 = await result7.next()
  assert(result8.status === 'pending')
  expect(result8.tool.tool).toBe('taskEvent') // start-round-1

  const result9 = await result8.next()
  assert(result9.status === 'pending')
  expect(result9.tool.tool).toBe('generateText')

  const result10 = await result9.next(mockResponses.slice(1, 2) as JsonResponseMessage[])
  assert(result10.status === 'pending')
  expect(result10.tool.tool).toBe('taskEvent') // end-round-1

  const result11 = await result10.next()
  assert(result11.status === 'completed')

  expect(result11.output).toEqual({
    type: ToolResponseType.Exit,
    message: 'The files are index.ts and agent.workflow.ts',
  })
})

test('should exit when a tool returns an Exit response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'exitTool',
          input: {},
        },
      ],
    },
  ]

  const tools = [exitTool]

  const result1 = await run(agentWorkflow, {
    userMessage: [toJsonModelMessage({ role: 'user', content: 'Please exit.' })] as any,
    tools,
    systemPrompt: 'You are a helpful assistant.',
  })
  assert(result1.status === 'pending')
  expect(result1.tool.tool).toBe('taskEvent')

  const result2 = await result1.next()
  assert(result2.status === 'pending')
  expect(result2.tool.tool).toBe('taskEvent')

  const result3 = await result2.next()
  assert(result3.status === 'pending')
  expect(result3.tool.tool).toBe('generateText')

  const result4 = await result3.next(mockResponses as JsonResponseMessage[])
  assert(result4.status === 'pending')
  expect(result4.tool.tool).toBe('taskEvent')

  const result5 = await result4.next()
  assert(result5.status === 'pending')
  expect(result5.tool.tool).toBe('taskEvent')

  const result6 = await result5.next()
  assert(result6.status === 'pending')
  expect(result6.tool.tool).toBe('invokeTool')

  const toolResponse = await exitTool.handler({} as any, (result6.tool.input as any).input)
  const result7 = await result6.next(toolResponse)
  assert(result7.status === 'pending')
  expect(result7.tool.tool).toBe('taskEvent')

  const finalResult = await result7.next()
  assert(finalResult.status === 'completed')

  expect(finalResult.output).toEqual({
    type: ToolResponseType.Exit,
    message: 'Workflow exited',
  })
})

test('should exit when a tool returns a HandOver response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'handOverTool',
          input: {},
        },
      ],
    },
  ]

  const tools = [handOverTool]

  const result1 = await run(agentWorkflow, {
    userMessage: [toJsonModelMessage({ role: 'user', content: 'Please hand over.' })] as any,
    tools,
    systemPrompt: 'You are a helpful assistant.',
  })
  expect(result1.status).toBe('pending')
  assert(result1.status === 'pending')
  expect(result1.tool.tool).toBe('taskEvent')

  const result2 = await result1.next()
  expect(result2.status).toBe('pending')
  assert(result2.status === 'pending')
  expect(result2.tool.tool).toBe('taskEvent')

  const result3 = await result2.next()
  expect(result3.status).toBe('pending')
  assert(result3.status === 'pending')
  expect(result3.tool.tool).toBe('generateText')

  const result4 = await result3.next(mockResponses as JsonResponseMessage[])
  assert(result4.status === 'pending')
  expect(result4.tool.tool).toBe('taskEvent')

  const result5 = await result4.next()
  assert(result5.status === 'pending')
  expect(result5.tool.tool).toBe('taskEvent')

  const result6 = await result5.next()
  assert(result6.status === 'pending')
  expect(result6.tool.tool).toBe('invokeTool')

  const toolResponse = await handOverTool.handler({} as any, (result6.tool.input as any).input)
  const result7 = await result6.next(toolResponse)
  assert(result7.status === 'pending')
  expect(result7.tool.tool).toBe('taskEvent')

  const finalResult = await result7.next()
  expect(finalResult.status).toBe('completed')
  assert(finalResult.status === 'completed')

  expect(finalResult.output).toEqual({
    type: ToolResponseType.HandOver,
    agentName: 'test-agent',
    task: 'test-task',
  })
})

test('should exit when a tool returns a Delegate response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'delegateTool',
          input: {},
        },
      ],
    },
  ]

  const tools = [delegateTool]

  const result1 = await run(agentWorkflow, {
    userMessage: [toJsonModelMessage({ role: 'user', content: 'Please delegate.' })] as any,
    tools,
    systemPrompt: 'You are a helpful assistant.',
  })
  expect(result1.status).toBe('pending')
  assert(result1.status === 'pending')
  expect(result1.tool.tool).toBe('taskEvent')

  const result2 = await result1.next()
  expect(result2.status).toBe('pending')
  assert(result2.status === 'pending')
  expect(result2.tool.tool).toBe('taskEvent')

  const result3 = await result2.next()
  expect(result3.status).toBe('pending')
  assert(result3.status === 'pending')
  expect(result3.tool.tool).toBe('generateText')

  const result4 = await result3.next(mockResponses as JsonResponseMessage[])
  assert(result4.status === 'pending')
  expect(result4.tool.tool).toBe('taskEvent')

  const result5 = await result4.next()
  assert(result5.status === 'pending')
  expect(result5.tool.tool).toBe('taskEvent')

  const result6 = await result5.next()
  assert(result6.status === 'pending')
  expect(result6.tool.tool).toBe('invokeTool')

  const toolResponse = await delegateTool.handler({} as any, (result6.tool.input as any).input)
  const result7 = await result6.next(toolResponse)
  assert(result7.status === 'pending')
  expect(result7.tool.tool).toBe('taskEvent')

  const finalResult = await result7.next()
  expect(finalResult.status).toBe('completed')
  assert(finalResult.status === 'completed')

  expect(finalResult.output).toEqual({
    type: ToolResponseType.Delegate,
    agentName: 'test-agent',
    task: 'test-task',
  })
})

test('should handle Error and Invalid tool responses', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'errorTool',
          input: {},
        },
        {
          type: 'tool-call',
          toolCallId: 'tool-call-2',
          toolName: 'invalidTool',
          input: {},
        },
      ],
    },
    {
      role: 'assistant',
      content: 'Done.',
    },
  ]

  const tools = [errorTool, invalidTool]

  const result1 = await run(agentWorkflow, {
    userMessage: [toJsonModelMessage({ role: 'user', content: 'Run tools that fail.' })] as any,
    tools,
    systemPrompt: 'You are a helpful assistant.',
  })
  expect(result1.status).toBe('pending')
  assert(result1.status === 'pending')
  expect(result1.tool.tool).toBe('taskEvent')

  const result2 = await result1.next()
  expect(result2.status).toBe('pending')
  assert(result2.status === 'pending')
  expect(result2.tool.tool).toBe('taskEvent')

  const result3 = await result2.next()
  expect(result3.status).toBe('pending')
  assert(result3.status === 'pending')
  expect(result3.tool.tool).toBe('generateText')

  const result4 = await result3.next(mockResponses.slice(0, 1) as JsonResponseMessage[])
  assert(result4.status === 'pending')
  expect(result4.tool.tool).toBe('taskEvent')

  const result5 = await result4.next()
  assert(result5.status === 'pending')
  expect(result5.tool.tool).toBe('taskEvent')

  const result6 = await result5.next()
  assert(result6.status === 'pending')
  expect(result6.tool.tool).toBe('invokeTool')

  const errorResponse = await errorTool.handler({} as any, (result6.tool.input as any).input)
  const result7 = await result6.next(errorResponse)
  assert(result7.status === 'pending')
  expect(result7.tool.tool).toBe('taskEvent') // ToolReply for errorTool

  const result8 = await result7.next()
  assert(result8.status === 'pending')
  expect(result8.tool.tool).toBe('taskEvent') // ToolUse for invalidTool

  const result9 = await result8.next()
  assert(result9.status === 'pending')
  expect(result9.tool.tool).toBe('invokeTool')

  const invalidResponse = await invalidTool.handler({} as any, (result9.tool.input as any).input)
  const result10 = await result9.next(invalidResponse)
  assert(result10.status === 'pending')
  expect(result10.tool.tool).toBe('taskEvent') // ToolReply for invalidTool

  const result11 = await result10.next()
  assert(result11.status === 'pending')
  expect(result11.tool.tool).toBe('taskEvent') // start-round-1

  const result12 = await result11.next()
  assert(result12.status === 'pending')
  expect(result12.tool.tool).toBe('generateText')
})

test('should fail if maxToolRoundTrips is exceeded', async () => {
  const mockResponses: ModelMessage[] = Array(12).fill({
    role: 'assistant',
    content: [
      {
        type: 'tool-call',
        toolCallId: 'tool-call-1',
        toolName: 'listFiles',
        input: { path: './src' },
      },
    ],
  })

  const tools = [listFilesTool]

  let currentResult: WorkflowResult<AgentWorkflowInput, any, any> = await run(agentWorkflow, {
    userMessage: [toJsonModelMessage({ role: 'user', content: 'List files.' })] as any,
    tools,
    systemPrompt: 'You are a helpful assistant.',
    maxToolRoundTrips: 10,
  })

  for (let i = 0; i < 100; i++) {
    if (currentResult.status !== 'pending') {
      break
    }
    let toolResponse: any
    if (currentResult.tool.tool === 'generateText') {
      const response = mockResponses.shift()
      toolResponse = response ? [response] : []
    } else if (currentResult.tool.tool === 'invokeTool') {
      toolResponse = await listFilesTool.handler({} as any, (currentResult.tool.input as any).input)
    } else if (currentResult.tool.tool === 'taskEvent') {
      toolResponse = undefined
    }
    currentResult = await currentResult.next(toolResponse as any)
  }

  expect(currentResult.status).toBe('failed')
  if (currentResult.status === 'failed') {
    expect((currentResult.error as Error).message).toBe('Maximum number of tool round trips reached.')
  }
})
