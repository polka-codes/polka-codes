// generated by polka.codes
import { expect, test } from 'bun:test'
import type { LanguageModelV2 } from '@ai-sdk/provider'
import { type FullToolInfoV2, type ToolResponse, ToolResponseType } from '@polka-codes/core'
import type { AssistantModelMessage, ModelMessage } from 'ai'
import { z } from 'zod'
import { type AgentWorkflowInput, agentWorkflow } from './agent.workflow'
import { run, type WorkflowResult } from './workflow'

const mockLanguageModel = (responses: ModelMessage[]): LanguageModelV2 => {
  let responseIndex = 0
  return {
    provider: 'mock-provider',
    modelId: 'mock-model',
    doGenerate: async () => {
      const response = responses[responseIndex++]
      if (!response) {
        throw new Error('No more mock responses')
      }
      return {
        finishReason: 'stop',
        usage: { promptTokens: 10, completionTokens: 10 },
        message: response,
      }
    },
  } as any
}

const createMockTool = (name: string, description: string, handler: (args: any) => Promise<ToolResponse>): FullToolInfoV2 => ({
  name,
  description,
  parameters: z.object({
    path: z.string().describe('The path to list files from'),
  }),
  handler,
  isAvailable: () => true,
})

const listFilesTool = createMockTool('listFiles', 'List files in a directory', async ({ path }: { path: string }) => {
  if (path === './src') {
    return {
      type: ToolResponseType.Reply,
      message: {
        type: 'json',
        value: ['index.ts', 'agent.workflow.ts'],
      },
    }
  }
  return {
    type: ToolResponseType.Reply,
    message: { type: 'json', value: [] },
  }
})

const exitTool = createMockTool('exitTool', 'Exit the workflow', async () => ({
  type: ToolResponseType.Exit,
  message: 'Workflow exited',
}))

const handOverTool = createMockTool('handOverTool', 'Hand over to another agent', async () => ({
  type: ToolResponseType.HandOver,
  agentName: 'test-agent',
  task: 'test-task',
}))

const delegateTool = createMockTool('delegateTool', 'Delegate to another agent', async () => ({
  type: ToolResponseType.Delegate,
  agentName: 'test-agent',
  task: 'test-task',
}))

const errorTool = createMockTool('errorTool', 'Return an error', async () => ({
  type: ToolResponseType.Error,
  message: { type: 'error-text', value: 'Something went wrong' },
}))

const invalidTool = createMockTool('invalidTool', 'Return invalid', async () => ({
  type: ToolResponseType.Invalid,
  message: { type: 'error-text', value: 'Invalid arguments' },
}))

test('should run agent workflow with a tool call and reply', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'listFiles',
          input: { path: './src' },
        },
      ],
    } as AssistantModelMessage,
    {
      role: 'assistant',
      content: 'The files are index.ts and agent.workflow.ts',
    } as AssistantModelMessage,
  ]

  const model = mockLanguageModel(mockResponses)

  const initialMessages: ModelMessage[] = [{ role: 'user', content: 'What are the files in the src directory?' }]

  const tools = [listFilesTool]

  const result1 = await run(agentWorkflow, {
    messages: initialMessages,
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
  })

  expect(result1.status).toBe('pending')
  if (result1.status !== 'pending') return

  expect(result1.tool.tool).toBe('llm')

  const result2 = await result1.next(await model.doGenerate!({} as any))

  expect(result2.status).toBe('pending')
  if (result2.status !== 'pending') return

  expect(result2.tool.tool).toBe('listFiles')
  expect(result2.tool.input).toEqual({ path: './src' })

  const listFilesResponse = await listFilesTool.handler({} as any, result2.tool.input)
  const result3 = await result2.next(listFilesResponse)

  expect(result3.status).toBe('pending')
  if (result3.status !== 'pending') return

  expect(result3.tool.tool).toBe('llm')

  const result4 = await result3.next(await model.doGenerate!({} as any))

  expect(result4.status).toBe('completed')
  if (result4.status !== 'completed') return

  expect(result4.output).toEqual({
    type: ToolResponseType.Exit,
    message: 'The files are index.ts and agent.workflow.ts',
  })
})

test('should exit when a tool returns an Exit response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'exitTool',
          input: {},
        },
      ],
    } as AssistantModelMessage,
  ]

  const model = mockLanguageModel(mockResponses)
  const tools = [exitTool]

  const result1 = await run(agentWorkflow, {
    messages: [{ role: 'user', content: 'Please exit.' }],
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
  })

  const result2 = await (result1 as any).next(await model.doGenerate!({} as any))
  if (result2.status !== 'pending') throw new Error('Expected pending status')

  const toolResponse = await exitTool.handler({} as any, result2.tool.input)
  const finalResult = await result2.next(toolResponse)

  expect(finalResult.status).toBe('completed')
  if (finalResult.status !== 'completed') return

  expect(finalResult.output).toEqual({
    type: ToolResponseType.Exit,
    message: 'Workflow exited',
  })
})

test('should exit when a tool returns a HandOver response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'handOverTool',
          input: {},
        },
      ],
    } as AssistantModelMessage,
  ]

  const model = mockLanguageModel(mockResponses)
  const tools = [handOverTool]

  const result1 = await run(agentWorkflow, {
    messages: [{ role: 'user', content: 'Please hand over.' }],
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
  })

  const result2 = await (result1 as any).next(await model.doGenerate!({} as any))
  if (result2.status !== 'pending') throw new Error('Expected pending status')

  const toolResponse = await handOverTool.handler({} as any, result2.tool.input)
  const finalResult = await result2.next(toolResponse)

  expect(finalResult.status).toBe('completed')
  if (finalResult.status !== 'completed') return

  expect(finalResult.output).toEqual({
    type: ToolResponseType.HandOver,
    agentName: 'test-agent',
    task: 'test-task',
  })
})

test('should exit when a tool returns a Delegate response', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'delegateTool',
          input: {},
        },
      ],
    } as AssistantModelMessage,
  ]

  const model = mockLanguageModel(mockResponses)
  const tools = [delegateTool]

  const result1 = await run(agentWorkflow, {
    messages: [{ role: 'user', content: 'Please delegate.' }],
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
  })

  const result2 = await (result1 as any).next(await model.doGenerate!({} as any))
  if (result2.status !== 'pending') throw new Error('Expected pending status')

  const toolResponse = await delegateTool.handler({} as any, result2.tool.input)
  const finalResult = await result2.next(toolResponse)

  expect(finalResult.status).toBe('completed')
  if (finalResult.status !== 'completed') return

  expect(finalResult.output).toEqual({
    type: ToolResponseType.Delegate,
    agentName: 'test-agent',
    task: 'test-task',
  })
})

test('should handle Error and Invalid tool responses', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'errorTool',
          input: {},
        },
        {
          type: 'tool-call',
          toolCallId: 'tool-call-2',
          toolName: 'invalidTool',
          input: {},
        },
      ],
    } as AssistantModelMessage,
    {
      role: 'assistant',
      content: 'Done.',
    } as AssistantModelMessage,
  ]

  const model = mockLanguageModel(mockResponses)
  const tools = [errorTool, invalidTool]

  const result1 = await run(agentWorkflow, {
    messages: [{ role: 'user', content: 'Run tools that fail.' }],
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
  })

  const result2 = await (result1 as any).next(await model.doGenerate!({} as any))
  if (result2.status !== 'pending') throw new Error('Expected pending status')

  const errorResponse = await errorTool.handler({} as any, result2.tool.input)
  const result3 = await result2.next(errorResponse)
  if (result3.status !== 'pending') throw new Error('Expected pending status')

  const invalidResponse = await invalidTool.handler({} as any, result3.tool.input)
  const result4 = await result3.next(invalidResponse)
  if (result4.status !== 'pending') throw new Error('Expected pending status')

  expect(result4.tool.tool).toBe('llm')
})

test('should re-prompt if requireToolUse is true and no tool is called', async () => {
  const mockResponses: ModelMessage[] = [
    {
      role: 'assistant',
      content: 'I should use a tool for this.',
    } as AssistantModelMessage,
    {
      role: 'assistant',
      content: [
        {
          type: 'tool-call',
          toolCallId: 'tool-call-1',
          toolName: 'listFiles',
          input: { path: './src' },
        },
      ],
    } as AssistantModelMessage,
    {
      role: 'assistant',
      content: 'Final answer.',
    } as AssistantModelMessage,
  ]

  const model = mockLanguageModel(mockResponses)
  const tools = [listFilesTool]

  const result1 = await run(agentWorkflow, {
    messages: [{ role: 'user', content: 'List files.' }],
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
    requireToolUse: true,
  })

  const result2 = await (result1 as any).next(await model.doGenerate!({} as any))
  if (result2.status !== 'pending') throw new Error('Expected pending status')

  // The workflow should re-prompt, so the next tool is llm
  expect(result2.tool.tool).toBe('llm')

  const result3 = await result2.next(await model.doGenerate!({} as any))
  if (result3.status !== 'pending') throw new Error('Expected pending status')

  expect(result3.tool.tool).toBe('listFiles')
})

test('should fail if maxToolRoundTrips is exceeded', async () => {
  const mockResponses: ModelMessage[] = Array(12).fill({
    role: 'assistant',
    content: [
      {
        type: 'tool-call',
        toolCallId: 'tool-call-1',
        toolName: 'listFiles',
        input: { path: './src' },
      },
    ],
  } as AssistantModelMessage)

  const model = mockLanguageModel(mockResponses)
  const tools = [listFilesTool]

  let currentResult: WorkflowResult<AgentWorkflowInput, any, any> = await run(agentWorkflow, {
    messages: [{ role: 'user', content: 'List files.' }],
    tools,
    model,
    systemPrompt: 'You are a helpful assistant.',
    toolFormat: 'native',
    maxToolRoundTrips: 10,
  })

  for (let i = 0; i < 20; i++) {
    if (currentResult.status !== 'pending') {
      expect(currentResult.status as string).toBe('pending') // Fail early
      return
    }
    const toolResponse =
      currentResult.tool.tool === 'llm'
        ? await model.doGenerate!({} as any)
        : await listFilesTool.handler({} as any, currentResult.tool.input)
    currentResult = await currentResult.next(toolResponse as any)
  }

  expect(currentResult.status).toBe('failed')
  if (currentResult.status === 'failed') {
    expect((currentResult.error as Error).message).toBe('Maximum number of tool round trips reached.')
  }
})
