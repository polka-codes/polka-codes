// generated by polka.codes
import { describe, expect, it } from 'bun:test'
import type { FilesystemProvider, ToolResponse } from '@polka-codes/core'
import { readFile, ToolResponseType } from '@polka-codes/core'
import { createCoreToolsExecutor } from './tool-adapter'
import type { ToolSignature, Workflow } from './workflow'
import { run } from './workflow'

describe('tool-adapter integration', () => {
  it('should run a workflow with a core tool', async () => {
    const mockProvider: FilesystemProvider = {
      readFile: async (path: string) => `content of ${path}`,
    }

    const coreTools = {
      readFile,
    }

    const executor = createCoreToolsExecutor(coreTools, mockProvider) as any

    type TestTools = {
      readFile: ToolSignature<{ path: string }, string>
    }

    const testWorkflow: Workflow<{ path: string }, string, TestTools> = {
      name: 'test',
      description: 'test workflow',
      async *fn(input, _step, useTool) {
        const fileContent = yield* useTool('readFile', { path: input.path })
        return `file content is: ${fileContent}`
      },
    }

    const initialResult = await run(testWorkflow, { path: 'test.txt' })

    expect(initialResult.status).toBe('pending')
    if (initialResult.status !== 'pending') {
      return
    }

    expect(initialResult.tool.tool).toBe('readFile')
    const toolResult: ToolResponse = await executor.readFile(initialResult.tool.input as { path: string })

    expect(toolResult.type).toBe(ToolResponseType.Reply)
    if (toolResult.type !== ToolResponseType.Reply) {
      return
    }
    expect(toolResult.message.type).toBe('text')
    if (toolResult.message.type !== 'text') {
      return
    }

    const finalResult = await initialResult.next(toolResult.message.value)

    expect(finalResult.status).toBe('completed')
    if (finalResult.status !== 'completed') {
      return
    }

    expect(finalResult.output).toBe('file content is: <read_file_file_content path="test.txt">content of test.txt</read_file_file_content>')
  })
})
