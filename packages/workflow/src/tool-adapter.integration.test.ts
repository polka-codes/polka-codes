// generated by polka.codes
import { describe, expect, it } from 'bun:test'
import type { FilesystemProvider } from '@polka-codes/core'
import { readFile, ToolResponseType } from '@polka-codes/core'
import { type CoreToolsToWorkflowTools, createCoreToolsExecutor } from './tool-adapter'
import type { Workflow } from './workflow'
import { run } from './workflow'

describe('tool-adapter integration', () => {
  it('should run a workflow with a core tool', async () => {
    const mockProvider: FilesystemProvider = {
      readFile: async (path: string) => {
        return `content of ${path}`
      },
    }

    const coreTools = {
      readFile,
    }

    type TestTools = CoreToolsToWorkflowTools<typeof coreTools>

    const executor = createCoreToolsExecutor(coreTools, mockProvider)

    const testWorkflow: Workflow<{ path: string[] }, string, TestTools> = {
      name: 'test',
      description: 'test workflow',
      async *fn(input, _step, useTool) {
        const fileContent = yield* useTool('readFile', { path: input.path, includeIgnored: undefined })
        if (fileContent.type !== ToolResponseType.Reply) {
          throw new Error('unexpected tool response')
        }
        if (fileContent.message.type !== 'text') {
          throw new Error('unexpected tool response')
        }
        return `file content is: ${fileContent.message.value}`
      },
    }

    const initialResult = await run(testWorkflow, { path: ['test.txt'] })

    expect(initialResult.status).toBe('pending')
    if (initialResult.status !== 'pending') {
      return
    }

    expect(initialResult.tool.tool).toBe('readFile')
    const toolResult = await executor.readFile(initialResult.tool.input)

    const finalResult = await initialResult.next(toolResult)

    expect(finalResult.status).toBe('completed')
    if (finalResult.status !== 'completed') {
      return
    }

    expect(finalResult.output).toBe('file content is: <read_file_file_content path="test.txt">content of test.txt</read_file_file_content>')
  })
})
