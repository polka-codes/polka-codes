// generated by polka.codes
import type { PlainJson, StepFn, ToolRegistry } from './workflow'

export const makeStepFn = <TTools extends ToolRegistry = any>(fns?: {
  getStepResult: (key: string) => Promise<{ found: true; value: PlainJson | undefined } | { found: false }>
  setStepResult: (key: string, value: PlainJson | undefined) => Promise<void>
  getAndIncrementCounts: (key: string) => Promise<number>
}): StepFn<TTools> => {
  const resolvedFns =
    fns ??
    (() => {
      const results: Record<string, PlainJson | undefined> = {}
      const counts: Record<string, number> = {}
      return {
        getStepResult: async (key: string) => {
          if (Object.hasOwn(results, key)) {
            return { found: true, value: results[key] }
          }
          return { found: false }
        },
        setStepResult: async (key: string, value: PlainJson | undefined) => {
          results[key] = value
        },
        getAndIncrementCounts: async (key: string) => {
          counts[key] = (counts[key] || 0) + 1
          return counts[key]
        },
      }
    })()

  const stepFn: any = (name: string, fn: any) => {
    let generator: AsyncGenerator<any, any, any> | null = null

    const createGenerator = () => {
      async function* impl() {
        const currentCounts = await resolvedFns.getAndIncrementCounts(name)

        const key = `${name}#${currentCounts}`
        const existingResult = await resolvedFns.getStepResult(key)
        if (existingResult.found) {
          return existingResult.value as any
        }

        const resultOrGenerator = fn()

        if (resultOrGenerator && typeof resultOrGenerator.next === 'function') {
          const result = yield* resultOrGenerator
          await resolvedFns.setStepResult(key, result ?? undefined)
          return result
        }

        const result = await resultOrGenerator
        await resolvedFns.setStepResult(key, result ?? undefined)
        return result
      }

      return impl()
    }

    const dualReturn: any = {
      // biome-ignore lint/suspicious/noThenProperty: Required to make the return value thenable
      async then(onFulfilled?: any, onRejected?: any) {
        if (!generator) {
          generator = createGenerator()
        }

        const iterResult = await generator.next()
        if (iterResult.done) {
          return Promise.resolve(iterResult.value).then(onFulfilled, onRejected)
        }
        return Promise.resolve(generator).then(onFulfilled, onRejected)
      },
      [Symbol.asyncIterator]() {
        if (!generator) {
          generator = createGenerator()
        }
        return generator
      },
      next(value?: any) {
        if (!generator) {
          generator = createGenerator()
        }
        return generator.next(value)
      },
      return(value?: any) {
        if (!generator) {
          generator = createGenerator()
        }
        return generator.return(value)
      },
      throw(e?: any) {
        if (!generator) {
          generator = createGenerator()
        }
        return generator.throw(e)
      },
    }

    return dualReturn
  }

  return stepFn
}
